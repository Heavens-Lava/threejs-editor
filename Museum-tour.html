<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Museum Virtual Tour</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;400&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        min-height: 100vh;
        font-family: "Montserrat", Arial, sans-serif;
        background: linear-gradient(
          135deg,
          #0f2027 0%,
          #203a43 50%,
          #2c5364 100%
        );
      }
      .app-header {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        z-index: 200;
        display: flex;
        align-items: center;
        gap: 18px;
        padding: 28px 0 0 0;
        justify-content: center;
        pointer-events: none;
      }
      .app-header .logo {
        font-size: 2.5rem;
        color: #fbbf24;
        filter: drop-shadow(0 2px 8px #0008);
      }
      .app-header .title {
        font-size: 2.2rem;
        font-weight: 700;
        background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-fill-color: transparent;
        letter-spacing: 1px;
        filter: drop-shadow(0 2px 8px #0006);
      }
      #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      #instructions {
        position: absolute;
        top: 120px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border-radius: 18px;
        border: 1.5px solid rgba(255, 255, 255, 0.18);
        color: #fff;
        padding: 32px 38px 24px 38px;
        text-align: center;
        z-index: 100;
        min-width: 320px;
        max-width: 90vw;
      }
      #instructions h3 {
        margin: 0 0 16px 0;
        font-size: 1.7rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        color: #fbbf24;
        text-shadow: 0 2px 8px #0008;
      }
      #instructions p {
        margin: 7px 0;
        font-size: 1.08rem;
        color: #fff;
        opacity: 0.93;
        text-shadow: 0 1px 4px #0006;
      }
      #start-tour-btn {
        margin-top: 22px;
        padding: 14px 38px;
        font-size: 1.15rem;
        font-weight: 700;
        color: #fff;
        background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%);
        border: none;
        border-radius: 12px;
        box-shadow: 0 4px 16px rgba(251, 191, 36, 0.18);
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      #start-tour-btn:hover {
        background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        transform: translateY(-2px) scale(1.04);
      }
      .hide {
        display: none;
      }
      #loader-status {
        position: absolute;
        left: 20px;
        bottom: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 13px;
        z-index: 120;
        max-width: 320px;
      }
      @media (max-width: 600px) {
        .app-header .title {
          font-size: 1.2rem;
        }
        #instructions {
          padding: 18px 8vw 16px 8vw;
          min-width: 0;
        }
        #instructions h3 {
          font-size: 1.1rem;
        }
        #start-tour-btn {
          font-size: 1rem;
          padding: 10px 18px;
        }
      }
    </style>
  </head>
  <body>
    <div id="instructions">
      <h3>Welcome to the Museum Virtual Tour</h3>
      <p>Explore the museum at your own pace in a beautiful 3D environment.</p>
      <p><strong>Controls:</strong></p>
      <p>WASD or Arrow Keys – Move</p>
      <p>Space – Jump</p>
      <p>F – Toggle Fly Mode</p>
      <p>E – Fly Up / Q – Fly Down (while flying)</p>
      <p>Mouse – Look around</p>
      <p>ESC – Exit</p>
      <button id="start-tour-btn">Start Tour</button>
      <button
        id="edit-tour-btn"
        style="
          margin-left: 10px;
          background: #f59e0b;
          border: none;
          color: white;
          padding: 12px 24px;
          font-size: 16px;
          border-radius: 5px;
          cursor: pointer;
        "
      >
        Edit Tour
      </button>
      <button
        id="exit-edit-btn"
        style="
          margin-left: 10px;
          background: #ef4444;
          border: none;
          color: white;
          padding: 12px 24px;
          font-size: 16px;
          border-radius: 5px;
          cursor: pointer;
          display: none;
        "
        title="Exit edit mode and return to tour mode"
      >
        <i class="fas fa-times"></i> Exit Edit Mode
      </button>
      <button
        id="save-world-btn-main"
        style="
          margin-left: 10px;
          background: #10b981;
          border: none;
          color: white;
          padding: 12px 24px;
          font-size: 16px;
          border-radius: 5px;
          cursor: pointer;
          display: none;
        "
        title="Save current object positions to JSON file"
      >
        <i class="fas fa-download"></i> Save World
      </button>
    </div>
    <canvas id="canvas"></canvas>
    <button
      id="explorer-back-btn"
      aria-label="Back to Explorer"
      title="Back to Explorer"
      style="
        position: absolute;
        left: 20px;
        top: 20px;
        z-index: 220;
        background: #0a2e52;
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      "
    >
      Back to Explorer
    </button>
    
    <button
      id="toggle-colliders-btn"
      aria-pressed="false"
      title="Toggle collider debug (C)"
      style="
        position: absolute;
        top: 100px;
        right: 20px;
        z-index: 110;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      "
    >
      Colliders: OFF (C)
    </button>
    <button
      id="toggle-solid-colliders-btn"
      aria-pressed="false"
      title="Toggle solid collider view (Shift+C)"
      style="
        position: absolute;
        top: 140px;
        right: 20px;
        z-index: 110;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      "
    >
      Solid: OFF (Shift+C)
    </button>
    <button
      id="toggle-bvh-collision-btn"
      aria-pressed="true"
      title="Toggle triangle vs box collision (B)"
      style="
        position: absolute;
        top: 180px;
        right: 20px;
        z-index: 110;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      "
    >
      Collision: Triangle (B)
    </button>
    <button
      id="toggle-ui-btn"
      aria-pressed="false"
      title="Toggle UI visibility (H)"
      style="
        position: absolute;
        top: 220px;
        right: 20px;
        z-index: 110;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      "
    >
      Hide UI (H)
    </button>
    <div id="loader-status" role="status" aria-live="polite">
      Model: waiting to start...
    </div>
    <!-- Quick test UI: paste a model URL and test loading -->
    <div
      style="
        position: absolute;
        left: 20px;
        bottom: 72px;
        z-index: 130;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px;
        border-radius: 6px;
      "
    >
      <input
        id="model-test-url"
        placeholder="Paste model URL to test"
        style="width: 340px; padding: 6px; font-size: 13px"
      />
      <button
        id="model-test-btn"
        style="margin-left: 6px; padding: 6px 8px; font-size: 13px"
      >
        Test URL
      </button>
    </div>

    <!-- Three.js Development Panel Toggle Button -->
    <button
      id="toggle-dev-panel-btn"
      title="Toggle Developer Tools (Shift+T)"
      style="
        position: absolute;
        top: 220px;
        right: 20px;
        z-index: 110;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        border: none;
        padding: 10px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      "
    >
      <i class="fas fa-tools"></i> Dev Tools (Shift+T)
    </button>

    <!-- Edit Mode Indicator -->
    <div
      id="edit-mode-indicator"
      style="
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(239, 68, 68, 0.95);
        color: #fff;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        z-index: 110;
        display: none;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.3);
      "
    >
      <i class="fas fa-edit"></i> EDIT MODE ACTIVE - Click objects to select
    </div>

    <!-- Mode Toggle Hint -->
    <div
      id="mode-toggle-hint"
      style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        z-index: 110;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
      "
    >
      <i class="fas fa-keyboard"></i> <span id="mode-toggle-text">Enter Edit Mode (K)</span>
    </div>

    <!-- Three.js Development Panel -->
    <div
      id="dev-panel"
      style="
        position: fixed;
        top: 0;
        right: -600px;
        width: 600px;
        height: 100vh;
        background: rgba(20, 20, 30, 0.98);
        backdrop-filter: blur(10px);
        z-index: 9999;
        transition: right 0.3s ease;
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
        overflow-y: auto;
        font-family: 'Segoe UI', sans-serif;
      "
    >
      <!-- Panel Header -->
      <div
        style="
          position: sticky;
          top: 0;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 16px 20px;
          z-index: 10;
          border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <h2
            style="margin: 0; color: #fff; font-size: 1.4rem; font-weight: 700"
          >
            <i class="fas fa-cube"></i> Three.js Developer Tools for Museum Tour
          </h2>
          <button
            id="close-dev-panel-btn"
            style="
              background: rgba(255, 255, 255, 0.2);
              border: none;
              color: #fff;
              padding: 8px 12px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
              font-weight: 600;
            "
          >
            <i class="fas fa-times"></i> Close
          </button>
        </div>
      </div>

      <!-- Tab Navigation -->
      <div
        style="
          display: flex;
          background: rgba(0, 0, 0, 0.3);
          border-bottom: 2px solid rgba(255, 255, 255, 0.05);
        "
      >
        <button
          class="dev-tab active"
          data-tab="editor"
          style="
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            padding: 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 3px solid #667eea;
            transition: all 0.2s;
          "
        >
          <i class="fas fa-pencil-ruler"></i> Editor
        </button>
        <button
          class="dev-tab"
          data-tab="tools"
          style="
            flex: 1;
            background: transparent;
            border: none;
            color: #aaa;
            padding: 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
          "
        >
          <i class="fas fa-toolbox"></i> Tools
        </button>
        <button
          class="dev-tab"
          data-tab="export"
          style="
            flex: 1;
            background: transparent;
            border: none;
            color: #aaa;
            padding: 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
          "
        >
          <i class="fas fa-file-export"></i> Export
        </button>
        <button
          class="dev-tab"
          data-tab="docs"
          style="
            flex: 1;
            background: transparent;
            border: none;
            color: #aaa;
            padding: 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
          "
        >
          <i class="fas fa-book"></i> Docs
        </button>
      </div>

      <!-- Tab Content -->
      <div style="padding: 0">
        <!-- Editor Tab -->
        <div id="tab-editor" class="tab-content" style="display: block">
          <div style="padding: 20px; color: #fff">
            <h3 style="margin: 0 0 12px 0; color: #667eea; font-size: 1.1rem">
              <i class="fas fa-magic"></i> In-Game World Editor
            </h3>
            <p
              style="
                margin: 0 0 16px 0;
                font-size: 13px;
                color: #ccc;
                line-height: 1.6;
              "
            >
              Edit your world directly in-game! Click objects to select them,
              then move, rotate, and scale in real-time.
            </p>

            <!-- Editor Mode Info -->
            <div
              style="
                background: rgba(251, 191, 36, 0.1);
                border: 2px solid rgba(251, 191, 36, 0.3);
                padding: 16px;
                border-radius: 8px;
                margin-bottom: 16px;
              "
            >
              <h4
                style="margin: 0 0 12px 0; color: #fbbf24; font-size: 0.95rem"
              >
                <i class="fas fa-info-circle"></i> Editor Mode Active
              </h4>
              <p
                style="
                  margin: 0;
                  font-size: 12px;
                  color: #ccc;
                  line-height: 1.5;
                "
              >
                <strong>How to use:</strong> Click any object in the scene to
                select it. Use the transform controls and input fields below to
                manipulate objects. Use your mouse to orbit the camera around
                the scene.
              </p>
              <p
                style="
                  margin: 8px 0 0 0;
                  font-size: 11px;
                  color: #999;
                  line-height: 1.4;
                "
              >
                <em
                  >Tip: To return to game mode, refresh the page and click
                  "Start Tour" instead.</em
                >
              </p>
            </div>

            <!-- Spawn Point Controls -->
            <div
              style="
                background: rgba(16, 185, 129, 0.1);
                border: 2px solid rgba(16, 185, 129, 0.3);
                padding: 16px;
                border-radius: 8px;
                margin-bottom: 16px;
              "
            >
              <h4
                style="margin: 0 0 12px 0; color: #10b981; font-size: 0.95rem"
              >
                <i class="fas fa-map-marker-alt"></i> Player Spawn Point
              </h4>
              <p
                style="
                  margin: 0 0 12px 0;
                  font-size: 12px;
                  color: #ccc;
                  line-height: 1.5;
                "
              >
                Set the starting position and rotation for players entering the tour.
              </p>

              <!-- Spawn Point Position -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Position:</label
                >
                <div
                  style="
                    display: grid;
                    grid-template-columns: auto 1fr auto 1fr auto 1fr;
                    gap: 6px;
                    align-items: center;
                  "
                >
                  <span style="font-size: 12px; color: #ef4444">X</span>
                  <input
                    id="spawn-pos-x"
                    type="number"
                    step="0.1"
                    value="-2"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #10b981">Y</span>
                  <input
                    id="spawn-pos-y"
                    type="number"
                    step="0.1"
                    value="1.6"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #3b82f6">Z</span>
                  <input
                    id="spawn-pos-z"
                    type="number"
                    step="0.1"
                    value="32"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                </div>
              </div>

              <!-- Spawn Point Rotation -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Rotation (Y-axis, in degrees):</label
                >
                <input
                  id="spawn-rot-y"
                  type="number"
                  step="1"
                  value="0"
                  style="
                    width: 100%;
                    padding: 8px;
                    font-size: 12px;
                    border-radius: 4px;
                    border: 1px solid #555;
                    background: #2a2a2a;
                    color: #fff;
                  "
                />
              </div>

              <!-- Spawn Point Actions -->
              <div style="display: flex; gap: 8px">
                <button
                  id="update-spawn-btn"
                  style="
                    flex: 1;
                    background: #10b981;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 600;
                  "
                >
                  <i class="fas fa-check"></i> Update Spawn Point
                </button>
                <button
                  id="teleport-to-spawn-btn"
                  style="
                    flex: 1;
                    background: #3b82f6;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 600;
                  "
                >
                  <i class="fas fa-location-arrow"></i> Teleport to Spawn
                </button>
              </div>
            </div>

            <!-- Undo/Redo Controls -->
            <div style="display: flex; gap: 8px; margin-bottom: 16px">
              <button
                id="undo-btn"
                disabled
                style="
                  flex: 1;
                  background: #667eea;
                  color: #fff;
                  border: none;
                  padding: 10px;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: 13px;
                  font-weight: 600;
                  opacity: 0.5;
                "
              >
                <i class="fas fa-undo"></i> Undo (Ctrl+Z)
              </button>
              <button
                id="redo-btn"
                disabled
                style="
                  flex: 1;
                  background: #667eea;
                  color: #fff;
                  border: none;
                  padding: 10px;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: 13px;
                  font-weight: 600;
                  opacity: 0.5;
                "
              >
                <i class="fas fa-redo"></i> Redo (Ctrl+Y)
              </button>
            </div>

            <!-- Selected Object Info -->
            <div
              id="selected-object-panel"
              style="
                background: rgba(255, 255, 255, 0.05);
                padding: 16px;
                border-radius: 8px;
                margin-bottom: 16px;
                display: none;
              "
            >
              <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
                <i class="fas fa-crosshairs"></i> Selected:
                <span id="selected-object-name">None</span>
              </h4>

              <!-- Transform Controls -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Transform Mode:</label
                >
                <div style="display: flex; gap: 6px">
                  <button
                    class="transform-mode-btn"
                    data-mode="translate"
                    style="
                      flex: 1;
                      background: #667eea;
                      color: #fff;
                      border: none;
                      padding: 8px;
                      border-radius: 6px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    <i class="fas fa-arrows-alt"></i> Move
                  </button>
                  <button
                    class="transform-mode-btn"
                    data-mode="rotate"
                    style="
                      flex: 1;
                      background: #555;
                      color: #fff;
                      border: none;
                      padding: 8px;
                      border-radius: 6px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    <i class="fas fa-sync-alt"></i> Rotate
                  </button>
                  <button
                    class="transform-mode-btn"
                    data-mode="scale"
                    style="
                      flex: 1;
                      background: #555;
                      color: #fff;
                      border: none;
                      padding: 8px;
                      border-radius: 6px;
                      cursor: pointer;
                      font-size: 12px;
                    "
                  >
                    <i class="fas fa-expand"></i> Scale
                  </button>
                </div>
              </div>

              <!-- Position Controls -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Position:</label
                >
                <div
                  style="
                    display: grid;
                    grid-template-columns: auto 1fr auto 1fr auto 1fr;
                    gap: 6px;
                    align-items: center;
                  "
                >
                  <span style="font-size: 12px; color: #ef4444">X</span>
                  <input
                    id="obj-pos-x"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #10b981">Y</span>
                  <input
                    id="obj-pos-y"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #3b82f6">Z</span>
                  <input
                    id="obj-pos-z"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                </div>
              </div>

              <!-- Rotation Controls -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Rotation (degrees):</label
                >
                <div
                  style="
                    display: grid;
                    grid-template-columns: auto 1fr auto 1fr auto 1fr;
                    gap: 6px;
                    align-items: center;
                  "
                >
                  <span style="font-size: 12px; color: #ef4444">X</span>
                  <input
                    id="obj-rot-x"
                    type="number"
                    step="1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #10b981">Y</span>
                  <input
                    id="obj-rot-y"
                    type="number"
                    step="1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #3b82f6">Z</span>
                  <input
                    id="obj-rot-z"
                    type="number"
                    step="1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                </div>
              </div>

              <!-- Scale Controls -->
              <div style="margin-bottom: 12px">
                <label
                  style="
                    display: block;
                    margin-bottom: 6px;
                    font-size: 13px;
                    font-weight: 600;
                  "
                  >Scale:</label
                >
                <div
                  style="
                    display: grid;
                    grid-template-columns: auto 1fr auto 1fr auto 1fr;
                    gap: 6px;
                    align-items: center;
                  "
                >
                  <span style="font-size: 12px; color: #ef4444">X</span>
                  <input
                    id="obj-scale-x"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #10b981">Y</span>
                  <input
                    id="obj-scale-y"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                  <span style="font-size: 12px; color: #3b82f6">Z</span>
                  <input
                    id="obj-scale-z"
                    type="number"
                    step="0.1"
                    style="
                      width: 100%;
                      padding: 6px;
                      font-size: 12px;
                      border-radius: 4px;
                      border: 1px solid #555;
                      background: #2a2a2a;
                      color: #fff;
                    "
                  />
                </div>
                <label
                  style="display: block; margin: 8px 0 6px 0; font-size: 12px"
                >
                  <input type="checkbox" id="uniform-scale-checkbox" checked />
                  Uniform Scale
                </label>
              </div>

              <!-- Quick Actions -->
              <div style="display: flex; gap: 6px; margin-top: 12px">
                <button
                  id="duplicate-object-btn"
                  style="
                    flex: 1;
                    background: #f59e0b;
                    color: #fff;
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-copy"></i> Duplicate
                </button>
                <button
                  id="delete-object-btn"
                  style="
                    flex: 1;
                    background: #ef4444;
                    color: #fff;
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-trash"></i> Delete
                </button>
              </div>
            </div>

            <!-- Add Object Panel -->
            <div
              style="
                background: rgba(255, 255, 255, 0.05);
                padding: 16px;
                border-radius: 8px;
                margin-bottom: 16px;
              "
            >
              <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
                <i class="fas fa-plus-circle"></i> Add Objects
              </h4>
              <div
                style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px"
              >
                <button
                  class="add-object-btn"
                  data-type="cube"
                  style="
                    background: #667eea;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-cube"></i> Cube
                </button>
                <button
                  class="add-object-btn"
                  data-type="sphere"
                  style="
                    background: #667eea;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-circle"></i> Sphere
                </button>
                <button
                  class="add-object-btn"
                  data-type="cylinder"
                  style="
                    background: #667eea;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-database"></i> Cylinder
                </button>
                <button
                  class="add-object-btn"
                  data-type="plane"
                  style="
                    background: #667eea;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-square"></i> Plane
                </button>
                <button
                  class="add-object-btn"
                  data-type="light"
                  style="
                    background: #f59e0b;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-lightbulb"></i> Light
                </button>
                <button
                  id="load-model-btn"
                  style="
                    background: #10b981;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  <i class="fas fa-file-import"></i> Load Model
                </button>
              </div>
              <input
                type="file"
                id="model-file-input"
                accept=".glb,.gltf"
                style="display: none"
              />

              <!-- GLB Library Section -->
              <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <h5 style="margin: 0; color: #a78bfa; font-size: 0.85rem">
                    <i class="fas fa-book"></i> GLB Library
                  </h5>
                  <div style="display: flex; gap: 4px;">
                    <button
                      id="sync-supabase-btn"
                      title="Sync from Supabase storage bucket"
                      style="
                        background: rgba(16, 185, 129, 0.2);
                        color: #10b981;
                        border: 1px solid #10b981;
                        padding: 4px 8px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 11px;
                      "
                    >
                      <i class="fas fa-sync"></i> Sync
                    </button>
                    <button
                      id="manage-library-btn"
                      style="
                        background: rgba(167, 139, 250, 0.2);
                        color: #a78bfa;
                        border: 1px solid #a78bfa;
                        padding: 4px 8px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 11px;
                      "
                    >
                      <i class="fas fa-cog"></i> Manage
                    </button>
                  </div>
                </div>
                <div
                  id="glb-library-container"
                  style="
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 6px;
                    max-height: 200px;
                    overflow-y: auto;
                  "
                >
                  <!-- GLB library items will be populated here -->
                </div>
                <p id="glb-library-empty" style="margin: 8px 0 0 0; font-size: 11px; color: #999; text-align: center;">
                  No models in library. Click "Manage" to add models.
                </p>
              </div>
            </div>

            <!-- Save/Load Configuration -->
            <div
              style="
                background: rgba(16, 185, 129, 0.1);
                border: 2px solid rgba(16, 185, 129, 0.3);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <h4
                style="margin: 0 0 12px 0; color: #10b981; font-size: 0.95rem"
              >
                <i class="fas fa-save"></i> Save & Load World
              </h4>
              <div style="display: flex; gap: 6px; margin-bottom: 8px">
                <button
                  id="save-world-btn"
                  style="
                    flex: 1;
                    background: #10b981;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 13px;
                    font-weight: 600;
                  "
                >
                  <i class="fas fa-download"></i> Save World
                </button>
                <button
                  id="load-world-btn"
                  style="
                    flex: 1;
                    background: #3b82f6;
                    color: #fff;
                    border: none;
                    padding: 10px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 13px;
                    font-weight: 600;
                  "
                >
                  <i class="fas fa-upload"></i> Load World
                </button>
              </div>
              <input
                type="file"
                id="world-file-input"
                accept=".js,.json"
                style="display: none"
              />
              <p style="margin: 8px 0 0 0; font-size: 11px; color: #ccc">
                Saves all object positions, rotations, and scales to a JSON file
                you can reload later.
              </p>
            </div>
          </div>
        </div>

        <!-- Tools Tab -->
        <div
          id="tab-tools"
          class="tab-content"
          style="display: none; padding: 20px; color: #fff"
        >
          <h3 style="margin: 0 0 16px 0; color: #667eea; font-size: 1.1rem">
            <i class="fas fa-toolbox"></i> Development Libraries & Tools
          </h3>

          <!-- Scene Inspector -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-search"></i> Scene Inspector
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              View your current scene hierarchy and object details.
            </p>
            <button
              id="inspect-scene-btn"
              style="
                background: #667eea;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-eye"></i> Inspect Scene (Console)
            </button>
          </div>

          <!-- Stats.js Performance Monitor -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-tachometer-alt"></i> Stats.js (Performance
              Monitor)
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Monitor FPS, frame time, and memory usage.
            </p>
            <button
              id="toggle-stats-btn"
              style="
                background: #10b981;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-chart-line"></i> Enable Stats
            </button>
            <div id="stats-container" style="margin-top: 12px"></div>
          </div>

          <!-- dat.GUI Controls -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-sliders-h"></i> dat.GUI (Runtime Controls)
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Add interactive controls for scene parameters.
            </p>
            <button
              id="toggle-datgui-btn"
              style="
                background: #f59e0b;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-toggle-on"></i> Toggle dat.GUI
            </button>
          </div>

          <!-- OrbitControls Helper -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-rotate"></i> OrbitControls Helper
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Temporarily enable OrbitControls for easier scene navigation.
            </p>
            <button
              id="toggle-orbit-btn"
              style="
                background: #8b5cf6;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-arrows-alt"></i> Enable OrbitControls
            </button>
          </div>

          <!-- Useful Libraries -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
            "
          >
            <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-book-open"></i> Useful Three.js Libraries
            </h4>
            <ul
              style="
                margin: 0;
                padding: 0 0 0 20px;
                font-size: 13px;
                color: #ccc;
                line-height: 2;
              "
            >
              <li>
                <strong>three-mesh-bvh</strong> - Already loaded! (Collision
                detection)
              </li>
              <li>
                <strong>GLTFLoader</strong> - Already loaded! (GLTF/GLB models)
              </li>
              <li><strong>Stats.js</strong> - Ready to enable above</li>
              <li><strong>dat.GUI</strong> - Ready to enable above</li>
              <li><strong>OrbitControls</strong> - Ready to enable above</li>
            </ul>
          </div>
        </div>

        <!-- Export Tab -->
        <div
          id="tab-export"
          class="tab-content"
          style="display: none; padding: 20px; color: #fff"
        >
          <h3 style="margin: 0 0 16px 0; color: #667eea; font-size: 1.1rem">
            <i class="fas fa-file-export"></i> Export & Import Scene
          </h3>

          <!-- Export Scene -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-download"></i> Export Current Scene
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Export your current Three.js scene as JSON.
            </p>
            <button
              id="export-scene-btn"
              style="
                background: #10b981;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
                margin-bottom: 8px;
              "
            >
              <i class="fas fa-file-download"></i> Download Scene JSON
            </button>
            <button
              id="copy-scene-btn"
              style="
                background: #3b82f6;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-copy"></i> Copy Scene JSON
            </button>
          </div>

          <!-- Import Scene -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-upload"></i> Import Scene JSON
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Load a Three.js scene from JSON file or text.
            </p>
            <input
              type="file"
              id="import-scene-file"
              accept=".json"
              style="
                display: block;
                margin-bottom: 8px;
                color: #fff;
                font-size: 13px;
                width: 100%;
              "
            />
            <button
              id="import-scene-btn"
              style="
                background: #f59e0b;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-file-upload"></i> Import from File
            </button>
          </div>

          <!-- Export GLTF -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
            "
          >
            <h4 style="margin: 0 0 8px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-cube"></i> Export as GLTF
            </h4>
            <p style="margin: 0 0 12px 0; font-size: 13px; color: #ccc">
              Export your scene as a GLTF file (requires GLTFExporter).
            </p>
            <button
              id="export-gltf-btn"
              style="
                background: #8b5cf6;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                width: 100%;
              "
            >
              <i class="fas fa-file-code"></i> Export GLTF
            </button>
            <p style="margin: 12px 0 0 0; font-size: 12px; color: #fbbf24">
              <i class="fas fa-info-circle"></i> Note: GLTFExporter will be
              loaded when you click this button.
            </p>
          </div>
        </div>

        <!-- Docs Tab -->
        <div
          id="tab-docs"
          class="tab-content"
          style="display: none; padding: 20px; color: #fff"
        >
          <h3 style="margin: 0 0 16px 0; color: #667eea; font-size: 1.1rem">
            <i class="fas fa-book"></i> Quick Reference & Documentation
          </h3>

          <!-- Development Workflow -->
          <div
            style="
              background: rgba(251, 191, 36, 0.1);
              border: 2px solid rgba(251, 191, 36, 0.3);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 12px 0; color: #fbbf24; font-size: 0.95rem">
              <i class="fas fa-info-circle"></i> How to Use These Tools
            </h4>
            <div style="font-size: 13px; color: #fff; line-height: 1.8">
              <p style="margin: 0 0 12px 0">
                <strong>The Three.js Editor is a separate tool:</strong>
              </p>
              <ul style="margin: 0 0 12px 0; padding-left: 20px">
                <li>It does NOT show your current game scene</li>
                <li>Use it to build NEW 3D objects/scenes from scratch</li>
                <li>Export from editor, then import into your game</li>
              </ul>
              <p style="margin: 0 0 12px 0">
                <strong
                  >To see YOUR current scene (grass, building, etc.):</strong
                >
              </p>
              <ul style="margin: 0 0 12px 0; padding-left: 20px">
                <li>
                  Use the <strong>Scene Inspector</strong> (Tools tab) - logs to
                  console
                </li>
                <li>
                  Use <strong>Export Scene</strong> (Export tab) - saves current
                  scene
                </li>
                <li>
                  Enable <strong>OrbitControls</strong> (Tools tab) - inspect
                  from all angles
                </li>
              </ul>
              <p style="margin: 0; color: #fbbf24">
                <strong>💡 Best Practice:</strong> Open Three.js Editor in a new
                browser tab (click "Fullscreen" button), build objects there,
                export them, then import into your game using the Export tab.
              </p>
            </div>
          </div>

          <!-- Keyboard Shortcuts -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-keyboard"></i> Keyboard Shortcuts
            </h4>
            <table
              style="
                width: 100%;
                font-size: 13px;
                color: #ccc;
                border-collapse: collapse;
              "
            >
              <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1)">
                <td style="padding: 8px 0"><strong>Shift+T</strong></td>
                <td style="padding: 8px 0">Toggle Dev Panel</td>
              </tr>
              <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1)">
                <td style="padding: 8px 0"><strong>G</strong></td>
                <td style="padding: 8px 0">Toggle Grid</td>
              </tr>
              <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1)">
                <td style="padding: 8px 0"><strong>C</strong></td>
                <td style="padding: 8px 0">Toggle Colliders</td>
              </tr>
              <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1)">
                <td style="padding: 8px 0"><strong>B</strong></td>
                <td style="padding: 8px 0">Toggle BVH Collision</td>
              </tr>
              <tr>
                <td style="padding: 8px 0"><strong>F</strong></td>
                <td style="padding: 8px 0">Toggle Fly Mode</td>
              </tr>
            </table>
          </div>

          <!-- Quick Links -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
              margin-bottom: 16px;
            "
          >
            <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-link"></i> Useful Links
            </h4>
            <ul
              style="margin: 0; padding: 0; list-style: none; font-size: 13px"
            >
              <li style="margin-bottom: 8px">
                <a
                  href="https://threejs.org/docs/"
                  target="_blank"
                  style="
                    color: #667eea;
                    text-decoration: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                  "
                >
                  <i class="fas fa-external-link-alt"></i> Three.js
                  Documentation
                </a>
              </li>
              <li style="margin-bottom: 8px">
                <a
                  href="https://threejs.org/examples/"
                  target="_blank"
                  style="
                    color: #667eea;
                    text-decoration: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                  "
                >
                  <i class="fas fa-external-link-alt"></i> Three.js Examples
                </a>
              </li>
              <li style="margin-bottom: 8px">
                <a
                  href="https://threejs.org/editor/"
                  target="_blank"
                  style="
                    color: #667eea;
                    text-decoration: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                  "
                >
                  <i class="fas fa-external-link-alt"></i> Three.js Editor
                  (Standalone)
                </a>
              </li>
              <li style="margin-bottom: 8px">
                <a
                  href="https://sketchfab.com/"
                  target="_blank"
                  style="
                    color: #667eea;
                    text-decoration: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                  "
                >
                  <i class="fas fa-external-link-alt"></i> Sketchfab (Free 3D
                  Models)
                </a>
              </li>
              <li>
                <a
                  href="https://github.com/mrdoob/three.js/wiki"
                  target="_blank"
                  style="
                    color: #667eea;
                    text-decoration: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                  "
                >
                  <i class="fas fa-external-link-alt"></i> Three.js Wiki
                </a>
              </li>
            </ul>
          </div>

          <!-- Scene Tips -->
          <div
            style="
              background: rgba(255, 255, 255, 0.05);
              padding: 16px;
              border-radius: 8px;
            "
          >
            <h4 style="margin: 0 0 12px 0; color: #fff; font-size: 0.95rem">
              <i class="fas fa-lightbulb"></i> Development Tips
            </h4>
            <ul
              style="
                margin: 0;
                padding: 0 0 0 20px;
                font-size: 13px;
                color: #ccc;
                line-height: 2;
              "
            >
              <li>Use the Editor tab to visually build scenes</li>
              <li>Export scenes from the editor and import them here</li>
              <li>Enable Stats to monitor performance</li>
              <li>Use dat.GUI to add runtime controls for testing</li>
              <li>OrbitControls helps inspect your scene from all angles</li>
              <li>BVH collision provides triangle-level precision</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Load three-mesh-bvh via unpkg with proper module resolution -->
    <script src="https://unpkg.com/three-mesh-bvh@0.5.23/build/index.umd.js"></script>

    <!-- Load world configuration (positions, rotations, scales of all objects) -->
    <script src="museum-world-config.js"></script>

    <script>
      // ==================== CONFIGURATION ====================
      // Supabase Storage Configuration
      const SUPABASE_CONFIG = {
        url: "https://flqsdjtfkgycvssdbegd.supabase.co",
        bucketName: "models",
        publicPath: "models", // path in the public URL
      };

      // Additional Models to Load from Supabase on Startup
      // Add any additional GLB models you want to permanently load here
      // The main museum model is loaded separately below
      //
      // HOW TO USE:
      // 1. Upload your GLB files to your Supabase storage bucket
      // 2. Get the public URL for each model
      // 3. Add entries to the array below with name, url, position, rotation, scale
      // 4. Models will automatically load every time the page loads
      //
      // EXAMPLE:
      const ADDITIONAL_MODELS_CONFIG = [
        // Uncomment and modify these examples:
        // {
        //   name: "old_desk",
        //   url: "https://flqsdjtfkgycvssdbegd.supabase.co/storage/v1/object/public/models/old_desk_scene.glb",
        //   position: { x: 10, y: 0, z: 20 },  // Where to place it in the scene
        //   rotation: { x: 0, y: 0, z: 0 },    // Rotation in radians
        //   scale: { x: 1, y: 1, z: 1 }        // Scale multiplier
        // },
      ];
      // ==================== END CONFIGURATION ====================

      // Enable pointer lock and hide instructions on Start Tour
      document
        .getElementById("start-tour-btn")
        .addEventListener("click", function () {
          document.getElementById("instructions").classList.add("hide");

          // Apply spawn point to camera
          if (camera && spawnPoint) {
            camera.position.set(
              spawnPoint.position.x,
              spawnPoint.position.y,
              spawnPoint.position.z
            );

            // Set camera rotation from spawn point
            if (typeof euler !== "undefined") {
              // Reset all euler angles to ensure clean rotation
              euler.x = 0; // No pitch (looking straight ahead)
              euler.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y); // Yaw rotation
              euler.z = 0; // No roll
              camera.quaternion.setFromEuler(euler);
            }

            console.log("🎯 Applied spawn point:", spawnPoint);
            console.log("   Camera rotation (degrees):", spawnPoint.rotation.y);
          }

          var canvas = document.getElementById("canvas");
          if (canvas.requestPointerLock) {
            canvas.requestPointerLock();
          } else if (canvas.mozRequestPointerLock) {
            canvas.mozRequestPointerLock();
          }
        });

      // Edit Tour Mode - Separate initialization without pointer lock
      let isEditorMode = false;
      let editorOrbitControls = null;

      // Spawn Point System
      let spawnPoint = {
        position: { x: -2, y: 1.6, z: 32 },
        rotation: { y: 0 } // Y-axis rotation in degrees
      };
      let spawnPointMarker = null; // Visual marker in the scene

      // Create spawn point visual marker
      function createSpawnPointMarker() {
        if (spawnPointMarker) {
          scene.remove(spawnPointMarker);
        }

        // Create a group for the spawn point marker
        const group = new THREE.Group();
        group.name = "SpawnPointMarker";

        // Create arrow pointing forward (direction player will face)
        const arrowLength = 2;
        const arrowDir = new THREE.Vector3(0, 0, -1); // Forward direction
        const arrowOrigin = new THREE.Vector3(
          spawnPoint.position.x,
          spawnPoint.position.y + 0.5,
          spawnPoint.position.z
        );
        const arrowColor = 0x10b981; // Green color
        const arrow = new THREE.ArrowHelper(arrowDir, new THREE.Vector3(0, 0.5, 0), arrowLength, arrowColor, 0.5, 0.3);

        // Rotate arrow to match spawn rotation
        arrow.rotation.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y);
        group.add(arrow);

        // Create a cylinder as a platform
        const platformGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32);
        const platformMaterial = new THREE.MeshStandardMaterial({
          color: 0x10b981,
          transparent: true,
          opacity: 0.6,
          emissive: 0x10b981,
          emissiveIntensity: 0.3
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = 0.05;
        group.add(platform);

        // Create pulsing ring effect
        const ringGeometry = new THREE.RingGeometry(0.9, 1.0, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x10b981,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.11;
        group.add(ring);

        // Position the group
        group.position.set(spawnPoint.position.x, spawnPoint.position.y, spawnPoint.position.z);

        spawnPointMarker = group;
        scene.add(spawnPointMarker);

        // Make marker only visible in editor mode
        spawnPointMarker.visible = isEditorMode;

        return spawnPointMarker;
      }

      // Update spawn point from UI inputs
      function updateSpawnPointFromInputs() {
        spawnPoint.position.x = parseFloat(document.getElementById("spawn-pos-x").value);
        spawnPoint.position.y = parseFloat(document.getElementById("spawn-pos-y").value);
        spawnPoint.position.z = parseFloat(document.getElementById("spawn-pos-z").value);
        spawnPoint.rotation.y = parseFloat(document.getElementById("spawn-rot-y").value);

        // Update visual marker
        if (spawnPointMarker) {
          spawnPointMarker.position.set(
            spawnPoint.position.x,
            spawnPoint.position.y,
            spawnPoint.position.z
          );

          // Update arrow rotation
          const arrow = spawnPointMarker.children.find(child => child.type === "ArrowHelper");
          if (arrow) {
            arrow.rotation.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y);
          }
        }

        showTemporaryMessage("Spawn Point Updated!");
        console.log("🎯 Spawn point updated:", spawnPoint);
      }

      // Teleport camera to spawn point (for testing in editor)
      function teleportToSpawnPoint() {
        if (!camera) return;

        camera.position.set(
          spawnPoint.position.x,
          spawnPoint.position.y,
          spawnPoint.position.z
        );

        // Set camera rotation
        if (typeof euler !== "undefined") {
          // Reset all euler angles to ensure clean rotation
          euler.x = 0; // No pitch (looking straight ahead)
          euler.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y); // Yaw rotation
          euler.z = 0; // No roll
          camera.quaternion.setFromEuler(euler);
        }

        showTemporaryMessage("Teleported to Spawn Point!\nFacing: " + spawnPoint.rotation.y + "°");
        console.log("🚀 Teleported to spawn point:", spawnPoint);
        console.log("   Camera rotation (degrees):", spawnPoint.rotation.y);
      }

      // Undo/Redo System for Editor
      let undoStack = []; // Stack of previous states
      let redoStack = []; // Stack of undone states
      const MAX_UNDO_HISTORY = 50; // Limit history to prevent memory issues

      function saveUndoState(object, actionType = "transform") {
        if (!object) return;

        const state = {
          object: object,
          objectId: object.uuid, // Use Three.js UUID for tracking
          name: object.name || object.type,
          actionType: actionType,
          position: object.position.clone(),
          rotation: new THREE.Euler().copy(object.rotation),
          scale: object.scale.clone(),
          timestamp: Date.now(),
        };

        undoStack.push(state);

        // Limit undo history
        if (undoStack.length > MAX_UNDO_HISTORY) {
          undoStack.shift(); // Remove oldest
        }

        // Clear redo stack when new action is performed
        redoStack = [];

        console.log("💾 Saved undo state:", actionType, "for", state.name);
        updateUndoRedoButtons();
      }

      function undo() {
        if (undoStack.length === 0) {
          console.log("⚠️ Nothing to undo");
          return;
        }

        const currentState = undoStack.pop();

        // Save current state to redo stack before undoing
        const redoState = {
          object: currentState.object,
          objectId: currentState.objectId,
          name: currentState.name,
          actionType: currentState.actionType,
          position: currentState.object.position.clone(),
          rotation: new THREE.Euler().copy(currentState.object.rotation),
          scale: currentState.object.scale.clone(),
          timestamp: Date.now(),
        };
        redoStack.push(redoState);

        // Restore previous state
        currentState.object.position.copy(currentState.position);
        currentState.object.rotation.copy(currentState.rotation);
        currentState.object.scale.copy(currentState.scale);

        console.log(
          "↩️ Undo:",
          currentState.actionType,
          "for",
          currentState.name
        );

        // Update UI if this object is selected
        if (selectedObject === currentState.object) {
          updateEditorObjectInputs();
        }

        updateUndoRedoButtons();
      }

      function redo() {
        if (redoStack.length === 0) {
          console.log("⚠️ Nothing to redo");
          return;
        }

        const redoState = redoStack.pop();

        // Save current state back to undo stack
        const undoState = {
          object: redoState.object,
          objectId: redoState.objectId,
          name: redoState.name,
          actionType: redoState.actionType,
          position: redoState.object.position.clone(),
          rotation: new THREE.Euler().copy(redoState.object.rotation),
          scale: redoState.object.scale.clone(),
          timestamp: Date.now(),
        };
        undoStack.push(undoState);

        // Restore redo state
        redoState.object.position.copy(redoState.position);
        redoState.object.rotation.copy(redoState.rotation);
        redoState.object.scale.copy(redoState.scale);

        console.log("↪️ Redo:", redoState.actionType, "for", redoState.name);

        // Update UI if this object is selected
        if (selectedObject === redoState.object) {
          updateEditorObjectInputs();
        }

        updateUndoRedoButtons();
      }

      function updateUndoRedoButtons() {
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");

        if (undoBtn) {
          undoBtn.disabled = undoStack.length === 0;
          undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
        }

        if (redoBtn) {
          redoBtn.disabled = redoStack.length === 0;
          redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
        }
      }

      // Undo/Redo button event listeners
      document.addEventListener("DOMContentLoaded", function () {
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");

        if (undoBtn) {
          undoBtn.addEventListener("click", undo);
        }

        if (redoBtn) {
          redoBtn.addEventListener("click", redo);
        }
      });

      // UI visibility toggle state
      let isUIHidden = false;

      // Keyboard shortcuts for editor
      document.addEventListener("keydown", function (e) {
        // H key = Toggle UI visibility (works in both game and editor mode)
        if (e.key === "h" || e.key === "H") {
          e.preventDefault();
          toggleUIVisibility();
          return;
        }

        // K key = Toggle Edit Mode (works in both game and editor mode)
        if (e.key === "k" || e.key === "K") {
          e.preventDefault();
          toggleEditMode();
          return;
        }

        if (!isEditorMode) return; // Only in editor mode below this point

        // G key = Move/Translate mode
        if (e.key === "g" || e.key === "G") {
          e.preventDefault();
          setTransformMode("translate");
          return;
        }

        // R key = Rotate mode
        if (e.key === "r" || e.key === "R") {
          e.preventDefault();
          setTransformMode("rotate");
          return;
        }

        // T key = Scale mode
        if (e.key === "t" || e.key === "T") {
          e.preventDefault();
          setTransformMode("scale");
          return;
        }

        // Ctrl+Z = Undo
        if (e.ctrlKey && e.key === "z") {
          e.preventDefault();
          undo();
        }

        // Ctrl+Y or Ctrl+Shift+Z = Redo
        if (
          (e.ctrlKey && e.key === "y") ||
          (e.ctrlKey && e.shiftKey && e.key === "z")
        ) {
          e.preventDefault();
          redo();
        }
      });

      // Toggle UI visibility (hide/show all UI elements)
      function toggleUIVisibility() {
        isUIHidden = !isUIHidden;

        const uiElements = [

          document.getElementById("toggle-colliders-btn"),
          document.getElementById("toggle-solid-colliders-btn"),
          document.getElementById("toggle-bvh-collision-btn"),
          document.getElementById("loader-status"),
          document.getElementById("explorer-back-btn"),
          document.getElementById("toggle-dev-panel-btn"),
          document.getElementById("dev-panel"),
          document.getElementById("edit-mode-indicator"),
        ];

        // Toggle visibility for each UI element
        uiElements.forEach((el) => {
          if (el) {
            el.style.display = isUIHidden ? "none" : "";
          }
        });

        // Update the toggle UI button text
        const toggleUIBtn = document.getElementById("toggle-ui-btn");
        if (toggleUIBtn) {
          toggleUIBtn.textContent = isUIHidden ? "Show UI (H)" : "Hide UI (H)";
          toggleUIBtn.setAttribute("aria-pressed", isUIHidden ? "true" : "false");
        }

        // Show a temporary message
        if (isUIHidden) {
          showTemporaryMessage("UI Hidden - Press H to show");
        } else {
          showTemporaryMessage("UI Visible - Press H to hide");
        }

        console.log(isUIHidden ? "🙈 UI hidden" : "👁️ UI visible");
      }

      // Wire up the toggle UI button click event
      document.getElementById("toggle-ui-btn").addEventListener("click", function () {
        toggleUIVisibility();
      });

      // Show temporary on-screen message
      function showTemporaryMessage(text) {
        // Remove existing message if any
        const existing = document.getElementById("temp-message");
        if (existing) existing.remove();

        const message = document.createElement("div");
        message.id = "temp-message";
        // Use innerHTML to support line breaks
        message.innerHTML = text.replace(/\n/g, '<br>');
        message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 200, 0, 0.95);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 24px;
                font-weight: bold;
                z-index: 10000;
                pointer-events: none;
                box-shadow: 0 8px 30px rgba(0, 200, 0, 0.4);
                border: 3px solid rgba(255, 255, 255, 0.3);
                text-align: center;
                white-space: pre-line;
            `;
        document.body.appendChild(message);

        // Fade out and remove after 3 seconds (longer duration)
        setTimeout(() => {
          message.style.transition = "opacity 0.5s";
          message.style.opacity = "0";
          setTimeout(() => message.remove(), 500);
        }, 3000);
      }

      // Enter Edit Mode function
      function enterEditMode() {
        console.log("🎨 Entering editor mode");
        isEditorMode = true;

        // Hide instructions
        document.getElementById("instructions").classList.add("hide");

        // CRITICAL: Exit pointer lock and keep cursor visible
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }

        // Force isLocked to false to prevent camera rotation
        if (typeof isLocked !== 'undefined') {
          isLocked = false;
        }

        // Reset mouse tracking states
        if (typeof isMouseDown !== 'undefined') {
          isMouseDown = false;
        }

        // Prevent pointer lock from being re-enabled in editor mode
        const canvas = document.getElementById("canvas");
        canvas.style.cursor = "auto"; // Show cursor (use auto instead of default for better visibility)

        // Show edit mode indicator
        const editIndicator = document.getElementById("edit-mode-indicator");
        if (editIndicator) {
          editIndicator.style.display = "block";
        }

        // Show Save World button in instructions panel
        const saveWorldBtn = document.getElementById("save-world-btn-main");
        if (saveWorldBtn) {
          saveWorldBtn.style.display = "inline-block";
        }

        // Toggle button visibility - hide Edit Tour, show Exit Edit Mode
        document.getElementById("edit-tour-btn").style.display = "none";
        document.getElementById("exit-edit-btn").style.display = "inline-block";

        // Update mode toggle hint
        const modeToggleText = document.getElementById("mode-toggle-text");
        if (modeToggleText) {
          modeToggleText.textContent = "Exit Edit Mode (K)";
        }

        // Auto-open developer panel
        const devPanel = document.getElementById("dev-panel");
        if (devPanel && devPanel.style.display === "none") {
          devPanel.style.display = "block";
        }

        // Load OrbitControls for editor camera movement (NOT pointer lock)
        if (!editorOrbitControls && typeof THREE !== "undefined") {
          loadEditorControls();
        }

        // Show spawn point marker
        if (spawnPointMarker) {
          spawnPointMarker.visible = true;
        }

        // Show message to user
        showTemporaryMessage("Edit Mode Active\nMouse cursor is now visible\nClick objects to select them");

        console.log("✅ Editor mode active - Cursor should be visible");
      }

      // Exit Edit Mode function
      function exitEditMode() {
        console.log("🚪 Exiting editor mode - returning to tour mode");
        isEditorMode = false;

        // Hide edit mode indicator
        const editIndicator = document.getElementById("edit-mode-indicator");
        if (editIndicator) {
          editIndicator.style.display = "none";
        }

        // Hide Save World button
        const saveWorldBtn = document.getElementById("save-world-btn-main");
        if (saveWorldBtn) {
          saveWorldBtn.style.display = "none";
        }

        // Toggle button visibility - show Edit Tour, hide Exit Edit Mode
        document.getElementById("edit-tour-btn").style.display = "inline-block";
        document.getElementById("exit-edit-btn").style.display = "none";

        // Update mode toggle hint
        const modeToggleText = document.getElementById("mode-toggle-text");
        if (modeToggleText) {
          modeToggleText.textContent = "Enter Edit Mode (K)";
        }

        // Disable OrbitControls if they exist
        if (editorOrbitControls) {
          editorOrbitControls.enabled = false;
        }

        // Show instructions again
        document.getElementById("instructions").classList.remove("hide");

        // Reset canvas cursor
        const canvas = document.getElementById("canvas");
        canvas.style.cursor = "default";

        // Hide spawn point marker
        if (spawnPointMarker) {
          spawnPointMarker.visible = false;
        }

        // Show temporary message
        showTemporaryMessage("Tour Mode Active\nPress Start Tour to begin");

        console.log("✅ Returned to tour mode");
      }

      // Toggle Edit Mode function (for keyboard shortcut)
      function toggleEditMode() {
        if (isEditorMode) {
          exitEditMode();
        } else {
          enterEditMode();
        }
      }

      // Set Transform Mode (for keyboard shortcuts and cycling)
      let currentTransformMode = "translate"; // Track current mode

      function setTransformMode(mode) {
        if (!isEditorMode) {
          console.log("⚠️ Cannot set transform mode outside of editor mode");
          return;
        }

        currentTransformMode = mode;

        // Update transform controls if they exist
        if (transformControls) {
          transformControls.setMode(mode);
        }

        // Update button styles
        document.querySelectorAll(".transform-mode-btn").forEach((btn) => {
          if (btn.dataset.mode === mode) {
            btn.style.background = "#667eea";
          } else {
            btn.style.background = "#555";
          }
        });

        // Show message to user
        const modeNames = {
          translate: "Move",
          rotate: "Rotate",
          scale: "Scale"
        };
        showTemporaryMessage(`Transform Mode: ${modeNames[mode]} (${mode === "translate" ? "G" : mode === "rotate" ? "R" : "T"})`);

        console.log(`🔧 Transform mode set to: ${mode}`);
      }

      // Cycle to next transform mode
      function cycleTransformMode() {
        const modes = ["translate", "rotate", "scale"];
        const currentIndex = modes.indexOf(currentTransformMode);
        const nextIndex = (currentIndex + 1) % modes.length;
        const nextMode = modes[nextIndex];

        setTransformMode(nextMode);
      }

      // Edit Tour button handler
      document
        .getElementById("edit-tour-btn")
        .addEventListener("click", function () {
          enterEditMode();
        });

      // Exit Edit Mode button handler
      document
        .getElementById("exit-edit-btn")
        .addEventListener("click", function () {
          exitEditMode();
        });

      // Spawn Point button handlers
      document
        .getElementById("update-spawn-btn")
        .addEventListener("click", function () {
          updateSpawnPointFromInputs();
        });

      document
        .getElementById("teleport-to-spawn-btn")
        .addEventListener("click", function () {
          teleportToSpawnPoint();
        });

      // Load OrbitControls and TransformControls for editor mode
      function loadEditorControls() {
        console.log("📦 Loading OrbitControls for editor mode...");

        // Load OrbitControls script
        const orbitScript = document.createElement("script");
        orbitScript.src =
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js";
        orbitScript.onload = () => {
          console.log("✅ OrbitControls loaded");

          // Wait for scene and camera to be initialized
          const checkSceneReady = setInterval(() => {
            if (
              typeof scene !== "undefined" &&
              typeof camera !== "undefined" &&
              typeof renderer !== "undefined"
            ) {
              clearInterval(checkSceneReady);

              // Create OrbitControls for editor camera with improved settings
              editorOrbitControls = new THREE.OrbitControls(
                camera,
                renderer.domElement
              );

              // Smooth, responsive camera movement
              editorOrbitControls.enableDamping = true;
              editorOrbitControls.dampingFactor = 0.15; // Increased from 0.05 for snappier response

              // Enable all movement types for flexibility
              editorOrbitControls.enableRotate = true;
              editorOrbitControls.enableZoom = true;
              editorOrbitControls.enablePan = true;

              // Better panning behavior
              editorOrbitControls.screenSpacePanning = true; // Changed to true for intuitive panning
              editorOrbitControls.panSpeed = 1.0;

              // Smooth rotation
              editorOrbitControls.rotateSpeed = 0.8;

              // Comfortable zoom settings
              editorOrbitControls.zoomSpeed = 1.2;
              editorOrbitControls.minDistance = 0.5; // Can get closer to objects
              editorOrbitControls.maxDistance = 1000; // Can zoom out further

              // No polar angle restriction for full 360° rotation
              editorOrbitControls.maxPolarAngle = Math.PI; // Can look up and down freely
              editorOrbitControls.minPolarAngle = 0;

              // Mouse button configuration
              editorOrbitControls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN,
              };

              // Ensure cursor stays visible
              renderer.domElement.style.cursor = "default";

              console.log(
                "✅ OrbitControls initialized with improved settings"
              );

              // Now load TransformControls
              loadEditorTransformControls();
            }
          }, 100);
        };
        document.head.appendChild(orbitScript);
      }

      // Load TransformControls for editor mode (fixed infinite loop issue)
      function loadEditorTransformControls() {
        console.log("📦 Loading TransformControls for editor mode...");

        const transformScript = document.createElement("script");
        transformScript.src =
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js";
        transformScript.onload = () => {
          console.log("✅ TransformControls script loaded");

          // Create TransformControls with improved settings
          const editorTransformControls = new THREE.TransformControls(
            camera,
            renderer.domElement
          );

          // Better transform control settings for smoother manipulation
          editorTransformControls.setMode("translate"); // Start in move mode
          editorTransformControls.setSize(1.2); // Slightly larger gizmo for easier grabbing
          editorTransformControls.setSpace("local"); // Local space to match object rotation

          // Smooth dragging behavior
          editorTransformControls.translationSnap = null; // No snapping by default (smoother)
          editorTransformControls.rotationSnap = null;
          editorTransformControls.scaleSnap = null;

          // FIX: Prevent infinite loop by removing the 'change' event listener
          // Instead, we'll update inputs only when dragging ends
          editorTransformControls.addEventListener(
            "dragging-changed",
            (event) => {
              // Disable OrbitControls while dragging (prevents control conflicts)
              if (editorOrbitControls) {
                editorOrbitControls.enabled = !event.value;
              }

              // Change cursor to indicate dragging state
              if (event.value) {
                // Dragging STARTED - save current state for undo
                if (selectedObject) {
                  saveUndoState(selectedObject, "transform");
                }
                renderer.domElement.style.cursor = "grabbing";
              } else {
                // Dragging ENDED
                renderer.domElement.style.cursor = "default";
                // Update inputs ONLY when dragging ends (prevents infinite loop)
                if (selectedObject) {
                  updateEditorObjectInputs();
                }
              }
            }
          );

          // Show pointer cursor when hovering over transform controls
          editorTransformControls.addEventListener("mouseEnter", () => {
            renderer.domElement.style.cursor = "grab";
          });

          editorTransformControls.addEventListener("mouseLeave", () => {
            renderer.domElement.style.cursor = "default";
          });

          scene.add(editorTransformControls);
          transformControls = editorTransformControls; // Store reference globally

          console.log(
            "✅ TransformControls initialized with improved settings"
          );
          console.log(
            "🎯 Editor ready! Click objects to select and manipulate them."
          );
        };
        document.head.appendChild(transformScript);
      }

      // Check if an object is valid for selection in editor
      function isSelectableObject(obj) {
        if (!obj) return false;

        // Exclude the scene itself
        if (obj.type === "Scene") {
          console.log("⚠️ Cannot select Scene");
          return false;
        }

        // Exclude cameras
        if (obj.type.includes("Camera")) {
          console.log("⚠️ Cannot select camera");
          return false;
        }

        // Exclude lights
        if (obj.type.includes("Light")) {
          console.log("⚠️ Cannot select light");
          return false;
        }

        // Exclude helpers (GridHelper, BoxHelper, etc.)
        if (obj.type.includes("Helper")) {
          console.log("⚠️ Cannot select helper");
          return false;
        }

        // Exclude the transform controls itself
        if (obj === transformControls || obj.type === "TransformControls") {
          console.log("⚠️ Cannot select TransformControls");
          return false;
        }

        // Exclude the highlight box
        if (obj === objectHighlight) {
          console.log("⚠️ Cannot select highlight box");
          return false;
        }

        // Only allow Mesh, Group, and Object3D that have actual geometry
        const validTypes = [
          "Mesh",
          "Group",
          "SkinnedMesh",
          "InstancedMesh",
          "LOD",
        ];
        if (validTypes.includes(obj.type)) {
          return true;
        }

        // For generic Object3D, check if it has children with geometry
        if (obj.type === "Object3D" && obj.children.length > 0) {
          // Check if any children are meshes
          const hasMeshChildren = obj.children.some(
            (child) =>
              child.type === "Mesh" ||
              child.type === "SkinnedMesh" ||
              child.type === "Group"
          );
          if (hasMeshChildren) {
            return true;
          }
        }

        console.log("⚠️ Object type not selectable:", obj.type);
        return false;
      }

      // Editor mode click detection for object selection
      function setupEditorClickDetection() {
        const editorRaycaster = new THREE.Raycaster();
        const editorMouse = new THREE.Vector2();

        renderer.domElement.addEventListener(
          "click",
          function onEditorClick(event) {
            // Only handle clicks in editor mode
            if (!isEditorMode) return;

            console.log("🖱️ Click detected in editor mode");

            const rect = renderer.domElement.getBoundingClientRect();
            editorMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            editorMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            editorRaycaster.setFromCamera(editorMouse, camera);
            const intersects = editorRaycaster.intersectObjects(
              scene.children,
              true
            );

            if (intersects.length > 0) {
              // Find the first valid selectable object
              let validObject = null;

              for (let i = 0; i < intersects.length; i++) {
                let candidate = intersects[i].object;

                // Walk up to find the root parent (but not the Scene itself)
                while (candidate.parent && candidate.parent.type !== "Scene") {
                  candidate = candidate.parent;
                }

                // Filter: Only allow selection of valid objects
                if (isSelectableObject(candidate)) {
                  validObject = candidate;
                  break;
                }
              }

              if (validObject) {
                console.log(
                  "🎯 Selected object:",
                  validObject.name || validObject.type
                );
                selectEditorObject(validObject);
              } else {
                console.log(
                  "🚫 No selectable object found (clicked on helper/light/camera)"
                );
              }
            } else {
              console.log("🚫 No object clicked");
            }
          },
          false
        );

        console.log("✅ Editor click detection set up");
      }

      // Select object in editor mode
      function selectEditorObject(obj) {
        // Double-check that object is valid
        if (!isSelectableObject(obj)) {
          console.error("❌ Attempted to select invalid object:", obj.type);
          return;
        }

        // If clicking on the already selected object, cycle through transform modes
        if (selectedObject === obj) {
          console.log("🔄 Clicking on already selected object - cycling transform mode");
          cycleTransformMode();
          return;
        }

        // Detach from previous object
        if (transformControls && selectedObject) {
          transformControls.detach();
        }

        selectedObject = obj;

        const panel = document.getElementById("selected-object-panel");
        if (panel) {
          panel.style.display = "block";
          const nameSpan = document.getElementById("selected-object-name");
          if (nameSpan) {
            nameSpan.textContent = obj.name || "Unnamed Object";
          }
        }

        // Attach TransformControls to object - with safety check
        if (transformControls) {
          try {
            // Ensure object is in the scene graph
            let isInScene = false;
            let parent = obj.parent;
            while (parent) {
              if (parent.type === "Scene") {
                isInScene = true;
                break;
              }
              parent = parent.parent;
            }

            if (isInScene) {
              // Calculate object's bounding box to find visual center
              const boundingBox = new THREE.Box3().setFromObject(obj);
              const center = new THREE.Vector3();
              boundingBox.getCenter(center);

              console.log("✅ Object selected:", obj.name || obj.type);
              console.log(
                "   Object position:",
                obj.position.x.toFixed(2),
                obj.position.y.toFixed(2),
                obj.position.z.toFixed(2)
              );
              console.log(
                "   Visual center:",
                center.x.toFixed(2),
                center.y.toFixed(2),
                center.z.toFixed(2)
              );

              // Get object's world position
              const worldPos = new THREE.Vector3();
              obj.getWorldPosition(worldPos);
              console.log(
                "   World position:",
                worldPos.x.toFixed(2),
                worldPos.y.toFixed(2),
                worldPos.z.toFixed(2)
              );

              // Attach TransformControls
              // The gizmo will appear at the object's pivot point
              // For GLB models, this is usually at the bottom-center or origin of the model
              transformControls.attach(obj);

              // Adjust gizmo size based on object dimensions
              const size = boundingBox.getSize(new THREE.Vector3());
              const maxDimension = Math.max(size.x, size.y, size.z);
              const gizmoSize = Math.max(0.8, Math.min(2.5, maxDimension / 8));
              transformControls.setSize(gizmoSize);

              console.log(
                "   Object size:",
                size.x.toFixed(2),
                "x",
                size.y.toFixed(2),
                "x",
                size.z.toFixed(2)
              );
              console.log("   Gizmo size:", gizmoSize.toFixed(2));
              console.log(
                "   💡 Gizmo appears at object's pivot point (usually bottom-center for GLB models)"
              );
            } else {
              console.error(
                "❌ Object not in scene graph:",
                obj.name || obj.type
              );
            }
          } catch (error) {
            console.error("❌ Failed to attach TransformControls:", error);
          }
        }

        // Create visual highlight
        createEditorHighlight(obj);

        // Update input fields
        updateEditorObjectInputs();
      }

      // Wrapper function for updateObjectInputs (called from editor mode)
      function updateEditorObjectInputs() {
        if (typeof updateObjectInputs === "function") {
          updateObjectInputs();
        } else {
          console.warn("⚠️ updateObjectInputs function not yet defined");
        }
      }

      // Create visual highlight for selected object
      function createEditorHighlight(obj) {
        // Remove old highlight
        if (objectHighlight) {
          scene.remove(objectHighlight);
          objectHighlight = null;
        }

        // Create new highlight with bright cyan color (more visible than yellow)
        const box = new THREE.BoxHelper(obj, 0x00ffff); // Cyan/aqua color
        box.material.linewidth = 2; // Thicker lines (may not work in all browsers)

        // Make the wireframe more visible
        box.material.transparent = false;
        box.material.opacity = 1.0;
        box.material.depthTest = false; // Always visible, even behind objects

        scene.add(box);
        objectHighlight = box;

        console.log("✅ Bright highlight created for:", obj.name || obj.type);
      }

      // Editor camera movement with WASD/Arrow keys
      let editorCameraVelocity = { forward: 0, right: 0, up: 0 };
      const EDITOR_CAMERA_SPEED = 30; // Units per second

      function handleEditorCameraMovement(keyCode, isPressed) {
        const speed = EDITOR_CAMERA_SPEED;

        switch (keyCode) {
          case "ArrowUp":
          case "KeyW":
            editorCameraVelocity.forward = isPressed ? speed : 0;
            break;
          case "ArrowDown":
          case "KeyS":
            editorCameraVelocity.forward = isPressed ? -speed : 0;
            break;
          case "ArrowLeft":
          case "KeyA":
            editorCameraVelocity.right = isPressed ? -speed : 0;
            break;
          case "ArrowRight":
          case "KeyD":
            editorCameraVelocity.right = isPressed ? speed : 0;
            break;
          case "KeyE":
            editorCameraVelocity.up = isPressed ? speed : 0;
            break;
          case "KeyQ":
            editorCameraVelocity.up = isPressed ? -speed : 0;
            break;
        }
      }

      // Update editor camera position based on key input
      function updateEditorCameraPosition(delta) {
        if (!isEditorMode || !camera) return;

        // Move camera in its local space
        const moveVector = new THREE.Vector3();

        // Forward/backward (along camera's look direction)
        if (editorCameraVelocity.forward !== 0) {
          const forward = new THREE.Vector3(0, 0, -1);
          forward.applyQuaternion(camera.quaternion);
          forward.multiplyScalar(editorCameraVelocity.forward * delta);
          moveVector.add(forward);
        }

        // Left/right (perpendicular to camera's look direction)
        if (editorCameraVelocity.right !== 0) {
          const right = new THREE.Vector3(1, 0, 0);
          right.applyQuaternion(camera.quaternion);
          right.multiplyScalar(editorCameraVelocity.right * delta);
          moveVector.add(right);
        }

        // Up/down (world up/down with Q/E keys)
        if (editorCameraVelocity.up !== 0) {
          moveVector.y += editorCameraVelocity.up * delta;
        }

        camera.position.add(moveVector);

        // Update OrbitControls target to follow camera
        if (editorOrbitControls) {
          editorOrbitControls.target.copy(camera.position);
          const forward = new THREE.Vector3(0, 0, -1);
          forward.applyQuaternion(camera.quaternion);
          forward.multiplyScalar(10);
          editorOrbitControls.target.add(forward);
        }
      }

      // Wait for scene to be ready, then set up editor click detection
      const waitForScene = setInterval(() => {
        if (typeof scene !== "undefined") {
          clearInterval(waitForScene);
          setupEditorClickDetection();
        }
      }, 100);

      // Diagnostic: Check if BVH library loaded
      console.log("🔍 BVH Library Check:");
      console.log(
        "  THREE.MeshBVH:",
        typeof THREE !== "undefined" ? typeof THREE.MeshBVH : "THREE not loaded"
      );
      console.log("  window.MeshBVH:", typeof window.MeshBVH);
      console.log("  global MeshBVH:", typeof MeshBVH);
      console.log("  window.MeshBVHLib:", typeof window.MeshBVHLib);
      console.log(
        "  THREE.MESH_BVH:",
        typeof THREE !== "undefined" ? typeof THREE.MESH_BVH : "N/A"
      );
      // Check what's actually on THREE
      if (typeof THREE !== "undefined") {
        const bvhKeys = Object.keys(THREE).filter((k) =>
          k.toLowerCase().includes("bvh")
        );
        console.log(
          "  BVH-related keys on THREE:",
          bvhKeys.length > 0 ? bvhKeys : "none"
        );
      }

      let scene, camera, renderer;
      let controls = {};
      let modelLightGroup = null;
      // 3D sign group reference
      let signGroup = null;
      // currently loaded GLB model (for UI manipulation)
      let loadedModel = null;
      // collision system (store {obj, box} entries so moving colliders can be updated)
      let collidersBoxes = [];
      // Debug helpers for colliders
      let colliderHelpers = [];
      let showColliders = false; // Simple on/off toggle for showing collision box visuals
      let colliderGroundMarker = null; // single ground highlight plane for nearest collider
      let colliderGroundMarkers = []; // array of ground markers for all colliders
      let colliderSolidMeshes = [];
      let showSolidColliders = false;
      // Door state (populated by createDoor)
      let doorLeftPivot = null,
        doorRightPivot = null;
      let doorColliderEntries = [];
      let doorOpen = false;
      let doorOpening = false;
      let doorOpenProgress = 0;
      const DOOR_OPEN_SPEED = 0.9; // seconds to fully open
      const DOOR_TRIGGER_DISTANCE = 3.5; // meters to start opening
      const PLAYER_RADIUS = 0.5; // reduced from 0.8 to fit through tighter doorways
      const PLAYER_HEIGHT = 1.6; // approximate player height
      const CAPSULE_HALF_HEIGHT = PLAYER_HEIGHT * 0.5;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      let moveUp = false,
        moveDown = false;
      let velocity = new THREE.Vector3(0, 0, 0);
      let direction = new THREE.Vector3();
      let prevTime = performance.now();
      let isLocked = false;
      let canJump = true;
      let isJumping = false;
      const gravity = 30;
      // Increased jump height per user request
      const jumpHeight = 16;
      let isFlying = false;

      // The official GLTFLoader from three.js examples is included via a script tag above.
      // We intentionally avoid using an inline/naive parser here because .glb (binary) files
      // must be loaded as arraybuffers and parsed by the real loader. The loader is available
      // as `THREE.GLTFLoader` (or a global `GLTFLoader` depending on how the examples script
      // registers it). See `loadCapitolModel()` for a safe instantiation.

      // Camera movement
      let euler = new THREE.Euler(0, 0, 0, "YXZ");
      const PI_2 = Math.PI / 2;
      // fallback mouselook when pointer lock is not available (drag-to-look)
      let isMouseDown = false;
      let lastClientX = 0,
        lastClientY = 0;
      // grass instancing + sway data (populated by createGrassPatch)
      let grassInstancedMeshes = null;
      let grassBladesInfo = [];
      let grassUpdateIndex = [];
      const GRASS_UPDATE_BATCH = 120; // how many blades to update per frame per mesh

      // Museum interior offset - move the white building to the left of the Capitol
      const MUSEUM_OFFSET_X = -68; // position a bit further from the Capitol building
      const MUSEUM_OFFSET_Z = 35; // align with Capitol building depth
      const MUSEUM_ROTATION_Y = -Math.PI / 2; // rotate building -90 degrees so door faces player

      // Helper function to rotate a point around the museum center
      function rotatePointAroundMuseum(x, z) {
        // Rotate point (x, z) around museum center by MUSEUM_ROTATION_Y
        const relX = x;
        const relZ = z;
        const cos = Math.cos(MUSEUM_ROTATION_Y);
        const sin = Math.sin(MUSEUM_ROTATION_Y);
        return {
          x: MUSEUM_OFFSET_X + (relX * cos - relZ * sin),
          z: MUSEUM_OFFSET_Z + (relX * sin + relZ * cos),
        };
      }

      function addColliderFromObject(obj) {
        try {
          const box = new THREE.Box3().setFromObject(obj);
          const entry = { obj: obj, box: box };
          collidersBoxes.push(entry);
          return entry;
        } catch (e) {
          console.warn("addColliderFromObject failed", e);
          return null;
        }
      }

      // Remove collider entries whose obj is the given object or a descendant of it.
      // This lets us selectively disable collisions for a loaded model so the player
      // can enter through arches/openings. This is not exposed as a user toggle.
      function removeCollidersForObject(obj) {
        try {
          for (let i = collidersBoxes.length - 1; i >= 0; i--) {
            const entry = collidersBoxes[i];
            if (!entry || !entry.obj) continue;
            // walk up the parent chain to see if entry.obj is a descendant of obj
            let p = entry.obj;
            while (p) {
              if (p === obj) {
                // remove this collider entry
                collidersBoxes.splice(i, 1);
                break;
              }
              p = p.parent;
            }
          }
        } catch (e) {
          console.warn("removeCollidersForObject failed", e);
        }
      }

      // Return true if `child` is a descendant of `parent`
      function isDescendant(child, parent) {
        try {
          let p = child;
          while (p) {
            if (p === parent) return true;
            p = p.parent;
          }
        } catch (e) {}
        return false;
      }

      // DISABLED: Box collider system - using triangle BVH collision only
      // This function is now a stub that does nothing - triangle collision handles everything
      function addCollidersForModel(root) {
        // Box colliders disabled - your default triangle collision system is active
        console.log(`✓ Using default triangle collision for: ${root.name || 'model'}`);
      }

      // --- Simplified Triangle-level collision system (no external library needed) ---
      // Build collision data for each mesh in the model using Three.js built-in raycaster
      function buildBVHForModel(root) {
        console.log("━━━ Building Triangle Collision System ━━━");
        console.log("Root object:", root);

        try {
          // Clear existing collision data
          bvhColliders = [];

          console.log(
            "Using Three.js Raycaster for triangle-precise collision..."
          );
          let meshCount = 0;

          root.traverse((child) => {
            if (child && child.isMesh && child.geometry) {
              try {
                console.log(
                  `  Adding mesh: ${child.name || "unnamed"} (${
                    child.geometry.attributes.position.count
                  } vertices)`
                );

                // Store mesh for raycasting collision
                bvhColliders.push({
                  mesh: child,
                  raycaster: new THREE.Raycaster(), // each mesh gets its own raycaster
                });
                meshCount++;
                console.log(`    ✓ Added to collision system`);
              } catch (e) {
                console.warn(
                  `    ✗ Failed to add mesh ${child.name || "unnamed"}:`,
                  e.message
                );
              }
            }
          });

          console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
          console.log(`✓ Triangle Collision Ready`);
          console.log(`  Meshes: ${meshCount}`);
          console.log(`  Total colliders: ${bvhColliders.length}`);
          console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

          if (meshCount > 0) {
            useBVHCollision = true;
          } else {
            console.warn("⚠️ No collision meshes found - falling back to AABB");
            useBVHCollision = false;
          }
        } catch (e) {
          console.error("❌ buildBVHForModel FAILED:", e);
          console.error("Stack:", e.stack);
          useBVHCollision = false;
        }
      }

      // HEAVILY OPTIMIZED: Triangle-precise collision with spatial culling
      // Only checks meshes near the player, drastically reducing raycast overhead
      let _bvhCollisionLoggedOnce = false;
      let _raycastFrameCounter = 0; // throttle raycasting
      let _lastRaycastResult = false;

      function isCapsuleCollidingBVH(pos) {
        if (!useBVHCollision || bvhColliders.length === 0) {
          if (!_bvhCollisionLoggedOnce) {
            console.log(
              "⚠️ Triangle collision skipped: useBVHCollision =",
              useBVHCollision,
              ", bvhColliders.length =",
              bvhColliders.length
            );
            _bvhCollisionLoggedOnce = true;
          }
          return false;
        }

        if (!_bvhCollisionLoggedOnce) {
          console.log(
            "✓ Triangle collision system ACTIVE - testing",
            bvhColliders.length,
            "meshes"
          );
          _bvhCollisionLoggedOnce = true;
        }

        // OPTIMIZATION: Only do full raycast check every 3 frames to reduce lag further
        _raycastFrameCounter++;
        if (_raycastFrameCounter % 3 !== 0) {
          return _lastRaycastResult; // return cached result
        }

        try {
          const radius = PLAYER_RADIUS;
          const checkRadius = radius * 3; // spatial culling distance

          // SPATIAL CULLING: Only check meshes within reasonable distance
          const nearbyMeshes = [];
          for (const collider of bvhColliders) {
            if (!collider.mesh.visible) continue;

            // Quick distance check using bounding sphere
            const meshPos = new THREE.Vector3();
            collider.mesh.getWorldPosition(meshPos);
            const distance = pos.distanceTo(meshPos);

            if (distance < checkRadius) {
              nearbyMeshes.push(collider);
            }
          }

          // If no nearby meshes, no collision possible
          if (nearbyMeshes.length === 0) {
            _lastRaycastResult = false;
            return false;
          }

          // Test only 2 heights (center and bottom) for performance
          const testPoints = [
            new THREE.Vector3(pos.x, pos.y, pos.z), // center
            new THREE.Vector3(pos.x, pos.y - CAPSULE_HALF_HEIGHT * 0.5, pos.z), // mid-bottom
          ];

          // Test rays in 4 primary directions only
          const directions = [
            new THREE.Vector3(1, 0, 0), // right
            new THREE.Vector3(-1, 0, 0), // left
            new THREE.Vector3(0, 0, 1), // forward
            new THREE.Vector3(0, 0, -1), // back
          ];

          // Check only NEARBY meshes (huge performance gain!)
          for (const { mesh, raycaster } of nearbyMeshes) {
            // Test from each point in each direction
            for (const point of testPoints) {
              for (const dir of directions) {
                raycaster.set(point, dir);
                raycaster.far = radius;

                const intersects = raycaster.intersectObject(mesh, false);
                if (intersects.length > 0 && intersects[0].distance <= radius) {
                  _lastRaycastResult = true;
                  return true;
                }
              }
            }
          }

          _lastRaycastResult = false;
        } catch (e) {
          console.warn("Triangle collision check failed:", e);
          _lastRaycastResult = false;
        }
        return _lastRaycastResult;
      }

      // Check capsule against BVH triangles
      // --- Collider debug helpers and ground highlight ---
      function rebuildColliderHelpers() {
        // remove old helpers
        try {
          for (const h of colliderHelpers) {
            try {
              scene.remove(h);
            } catch (e) {}
          }
          // remove old solid meshes too
          for (const m of colliderSolidMeshes) {
            try {
              scene.remove(m);
            } catch (e) {}
          }
          // remove old ground markers
          for (const g of colliderGroundMarkers) {
            try {
              scene.remove(g);
            } catch (e) {}
          }
        } catch (e) {}
        colliderHelpers = [];
        colliderSolidMeshes = [];
        colliderGroundMarkers = [];

        try {
          // Visualize Triangle-based BVH collision meshes
          // Green wireframe shows the actual mesh geometry used for collision detection
          for (let i = 0; i < bvhColliders.length; i++) {
            const entry = bvhColliders[i];
            if (!entry || !entry.mesh) continue;

            const mesh = entry.mesh;

            // Create wireframe helper to show the mesh geometry
            const wireframe = new THREE.WireframeGeometry(mesh.geometry);
            const lineMaterial = new THREE.LineBasicMaterial({
              color: 0x00ff00, // Green for triangle collision meshes
              linewidth: 1,
              transparent: true,
              opacity: 0.6
            });
            const wireframeHelper = new THREE.LineSegments(wireframe, lineMaterial);

            // Match the mesh's world transform
            wireframeHelper.position.copy(mesh.position);
            wireframeHelper.rotation.copy(mesh.rotation);
            wireframeHelper.scale.copy(mesh.scale);
            wireframeHelper.visible = showColliders;

            colliderHelpers.push(wireframeHelper);
            scene.add(wireframeHelper);

            // Ground footprint marker for each collider mesh
            const bbox = new THREE.Box3().setFromObject(mesh);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const center = new THREE.Vector3();
            bbox.getCenter(center);

            const geom = new THREE.PlaneGeometry(size.x, size.z);
            const colors = [
              0x00ff00, 0x00ffff, 0xffff00, 0x00ff88, 0xff8800, 0x8800ff,
            ];
            const markerColor = colors[i % colors.length];
            const mat = new THREE.MeshBasicMaterial({
              color: markerColor,
              transparent: true,
              opacity: 0.25,
              depthWrite: false,
              side: THREE.DoubleSide,
            });
            const groundMarker = new THREE.Mesh(geom, mat);
            groundMarker.rotation.x = -Math.PI / 2;
            groundMarker.position.set(center.x, bbox.min.y + 0.01, center.z);
            groundMarker.renderOrder = 999;
            groundMarker.visible = false;
            groundMarker.userData.colliderIndex = i;
            scene.add(groundMarker);
            colliderGroundMarkers.push(groundMarker);
          }

          console.log(`🔺 Visualizing ${bvhColliders.length} triangle collision meshes`);
        } catch (e) {
          console.warn("rebuildColliderHelpers failed", e);
        }

        // Keep legacy single ground marker for backwards compatibility
        if (!colliderGroundMarker) {
          const geom = new THREE.PlaneGeometry(1, 1);
          const mat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.22,
            depthWrite: false,
          });
          colliderGroundMarker = new THREE.Mesh(geom, mat);
          colliderGroundMarker.rotation.x = -Math.PI / 2;
          colliderGroundMarker.renderOrder = 999;
          colliderGroundMarker.visible = false;
          scene.add(colliderGroundMarker);
        }

        // create solid/transparent mesh visualization if requested
        try {
          if (showSolidColliders) {
            for (const entry of bvhColliders) {
              if (!entry || !entry.mesh) continue;

              const mesh = entry.mesh;

              // Create a semi-transparent clone of the collision mesh
              const geom = mesh.geometry.clone();
              const mat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.15,
                depthWrite: false,
                side: THREE.DoubleSide
              });
              const solidMesh = new THREE.Mesh(geom, mat);

              // Match the original mesh's transform
              solidMesh.position.copy(mesh.position);
              solidMesh.rotation.copy(mesh.rotation);
              solidMesh.scale.copy(mesh.scale);
              solidMesh.renderOrder = 998;
              solidMesh.visible = !!showSolidColliders;

              colliderSolidMeshes.push(solidMesh);
              scene.add(solidMesh);
            }
          }
        } catch (e) {
          console.warn("create solid collider meshes failed", e);
        }
      }

      // Call inside the render loop to keep helpers in sync and position the ground highlight
      function updateColliderHelpersAndGround() {
        try {
          // refresh boxes from their objects
          for (const e of collidersBoxes) {
            if (e && e.obj && e.box) e.box.setFromObject(e.obj);
          }

          // rebuild helpers/solids/ground markers when counts diverge
          if (
            colliderHelpers.length !== collidersBoxes.length ||
            colliderSolidMeshes.length !== collidersBoxes.length ||
            colliderGroundMarkers.length !== collidersBoxes.length
          ) {
            rebuildColliderHelpers();
          }

          // Update wireframe helpers
          for (let i = 0; i < colliderHelpers.length; i++) {
            const h = colliderHelpers[i];
            const e = collidersBoxes[i];
            if (!h || !e) continue;
            if (e.box && h.box) h.box.copy(e.box);
            h.visible = !!showColliders;
          }

          // Update solid collider meshes if present
          if (
            colliderSolidMeshes &&
            colliderSolidMeshes.length === collidersBoxes.length
          ) {
            for (let i = 0; i < colliderSolidMeshes.length; i++) {
              const mesh = colliderSolidMeshes[i];
              const e = collidersBoxes[i];
              if (!mesh || !e || !e.box) continue;
              const min = e.box.min;
              const max = e.box.max;
              const width = Math.max(0.001, max.x - min.x);
              const height = Math.max(0.001, max.y - min.y);
              const depth = Math.max(0.001, max.z - min.z);
              mesh.position.set(
                (min.x + max.x) / 2,
                (min.y + max.y) / 2,
                (min.z + max.z) / 2
              );
              mesh.scale.set(width, height, depth);
              mesh.visible = !!showSolidColliders;
            }
          }

          // Update ground footprint markers for ALL colliders
          if (
            colliderGroundMarkers &&
            colliderGroundMarkers.length === collidersBoxes.length
          ) {
            for (let i = 0; i < colliderGroundMarkers.length; i++) {
              const marker = colliderGroundMarkers[i];
              const e = collidersBoxes[i];
              if (!marker || !e || !e.box) continue;

              const min = e.box.min;
              const max = e.box.max;
              const width = Math.max(0.01, max.x - min.x);
              const depth = Math.max(0.01, max.z - min.z);
              const cx = (min.x + max.x) / 2;
              const cz = (min.z + max.z) / 2;
              const cy = min.y + 0.02; // slightly above ground

              marker.position.set(cx, cy, cz);
              marker.scale.set(width, depth, 1);
              marker.visible = showColliders || showSolidColliders;
            }
          }

          // Legacy: Update nearest collider marker (can be disabled if using individual markers)
          if (colliderGroundMarker && camera) {
            let best = null;
            let bestDist = Infinity;
            const camXZ = new THREE.Vector2(
              camera.position.x,
              camera.position.z
            );
            const tmpCenter = new THREE.Vector3();
            for (const e of collidersBoxes) {
              if (!e || !e.box) continue;
              e.box.getCenter(tmpCenter);
              const d = camXZ.distanceTo(
                new THREE.Vector2(tmpCenter.x, tmpCenter.z)
              );
              if (d < bestDist) {
                bestDist = d;
                best = e;
              }
            }
            if (best && best.box && bestDist < 40) {
              const min = best.box.min;
              const max = best.box.max;
              const width = Math.max(0.01, max.x - min.x);
              const depth = Math.max(0.01, max.z - min.z);
              const cx = (min.x + max.x) / 2;
              const cz = (min.z + max.z) / 2;
              const cy = min.y + 0.01;
              colliderGroundMarker.position.set(cx, cy, cz);
              colliderGroundMarker.scale.set(width, depth, 1);
              // Hide legacy marker since we now show all individual markers
              colliderGroundMarker.visible = false;
            } else {
              colliderGroundMarker.visible = false;
            }
          }
        } catch (e) {
          /* non-fatal */
        }
      }

      function pointToAABBSqDistance(point, box) {
        let dx = 0;
        if (point.x < box.min.x)
          dx += (box.min.x - point.x) * (box.min.x - point.x);
        else if (point.x > box.max.x)
          dx += (point.x - box.max.x) * (point.x - box.max.x);
        if (point.y < box.min.y)
          dx += (box.min.y - point.y) * (box.min.y - point.y);
        else if (point.y > box.max.y)
          dx += (point.y - box.max.y) * (point.y - box.max.y);
        if (point.z < box.min.z)
          dx += (box.min.z - point.z) * (box.min.z - point.z);
        else if (point.z > box.max.z)
          dx += (point.z - box.max.z) * (point.z - box.max.z);
        return dx;
      }

      // distance^2 between segment a->b and AABB using ternary search over segment parameter
      function distanceSqSegmentAABB(a, b, box) {
        const maxIter = 20;
        let lo = 0,
          hi = 1;
        const ab = new THREE.Vector3().subVectors(b, a);
        function sample(t) {
          const p = new THREE.Vector3(
            a.x + ab.x * t,
            a.y + ab.y * t,
            a.z + ab.z * t
          );
          return pointToAABBSqDistance(p, box);
        }
        for (let i = 0; i < maxIter; i++) {
          const t1 = lo + (hi - lo) / 3;
          const t2 = hi - (hi - lo) / 3;
          const s1 = sample(t1);
          const s2 = sample(t2);
          if (s1 < s2) hi = t2;
          else lo = t1;
        }
        const t = (lo + hi) / 2;
        return sample(t);
      }

      function isCapsuleColliding(pos) {
        try {
          // Use BVH triangle collision if available and enabled
          if (useBVHCollision && bvhColliders.length > 0) {
            return isCapsuleCollidingBVH(pos);
          }

          // Fallback to AABB collision
          const start = new THREE.Vector3(
            pos.x,
            pos.y - CAPSULE_HALF_HEIGHT,
            pos.z
          );
          const end = new THREE.Vector3(
            pos.x,
            pos.y + CAPSULE_HALF_HEIGHT,
            pos.z
          );
          const radiusSq = PLAYER_RADIUS * PLAYER_RADIUS;
          for (const entry of collidersBoxes) {
            // support older plain Box3 entries if present
            const box = entry && entry.box ? entry.box : entry;
            const d2 = distanceSqSegmentAABB(start, end, box);
            if (d2 <= radiusSq) return true;
          }
        } catch (e) {
          console.warn("capsule collision check failed", e);
        }
        return false;
      }

      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

        // Remove any leftover lights from a previous run (Live Server / hot reload can re-run scripts)
        // This ensures we don't accidentally accumulate lights across page reloads.
        try {
          const toRemove = [];
          scene.children.forEach((c) => {
            if (c && c.isLight) toRemove.push(c);
          });
          for (const c of toRemove) scene.remove(c);
        } catch (e) {
          /* ignore */
        }

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        // Spawn player on the grass in front of the museum building
        // Player at (-2, 1.6, 32)
        camera.position.set(-2, 1.6, 32);
        // Rotate to face the museum building (toward negative Z)
        // Reset all euler angles to ensure clean rotation
        euler.x = 0; // No pitch (looking straight ahead)
        euler.y = 0; // 0 radians = facing toward museum (negative Z direction)
        euler.z = 0; // No roll
        camera.quaternion.setFromEuler(euler);

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // enable shadows and basic, predictable color handling
        renderer.shadowMap.enabled = true;
        // use sRGB encoding so colors and textures appear correct on most displays
        try {
          renderer.outputEncoding = THREE.sRGBEncoding;
        } catch (e) {}
        // Keep tone mapping simple (no filmic mapping) for predictable results across browsers
        try {
          renderer.toneMapping = THREE.NoToneMapping;
          renderer.toneMappingExposure = 1.0;
        } catch (e) {}
        try {
          renderer.physicallyCorrectLights = false;
        } catch (e) {}

        // Lighting
        // Basic, pleasant scene lighting: ambient + directional (default simple three.js lighting)
        // Keep intensities modest so the scene isn't overly bright when embedded.
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        // Directional 'sun' for main shadows and highlights
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(30, 40, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Floor - interior museum floor
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0xcccccc,
          roughness: 0.8,
          metalness: 0.2,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(MUSEUM_OFFSET_X, 0, MUSEUM_OFFSET_Z);
        floor.receiveShadow = true;
        scene.add(floor);

        // Grass outside - improved visual using a tiled canvas texture + instanced blades
        (function createGrassPatch() {
          // Canvas texture for broad grass color/variation
          const cvs = document.createElement("canvas");
          cvs.width = 1024;
          cvs.height = 1024;
          const ctx = cvs.getContext("2d");
          // base gradient
          const g = ctx.createLinearGradient(0, 0, 0, cvs.height);
          // darker, more natural grass tones
          g.addColorStop(0, "#2e5f2a");
          g.addColorStop(0.6, "#274f22");
          g.addColorStop(1, "#1f451b");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          // add random blade strokes for micro-variation
          ctx.strokeStyle = "rgba(30,70,30,0.16)";
          for (let i = 0; i < 1400; i++) {
            const x = Math.random() * cvs.width;
            const y = Math.random() * cvs.height;
            const h = 6 + Math.random() * 30;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(
              x + (Math.random() - 0.5) * 8,
              y - h / 2,
              x + (Math.random() - 0.5) * 6,
              y - h
            );
            ctx.stroke();
          }

          const grassTex = new THREE.CanvasTexture(cvs);
          grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
          grassTex.repeat.set(8, 4);
          try {
            grassTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
          } catch (e) {}

          const grassPlaneGeom = new THREE.PlaneGeometry(100, 50);
          const grassPlaneMat = new THREE.MeshStandardMaterial({
            map: grassTex,
            roughness: 0.9,
            metalness: 0.05,
          });
          const grassPlane = new THREE.Mesh(grassPlaneGeom, grassPlaneMat);
          grassPlane.rotation.x = -Math.PI / 2;
          grassPlane.position.z = 50;
          grassPlane.receiveShadow = true;
          scene.add(grassPlane);

          // Add instanced thin blades (simple boxes) for local depth and parallax
          try {
            // Create an alpha-textured blade image (tapered triangular blade) to use as material map
            const bladeCanvas = document.createElement("canvas");
            bladeCanvas.width = 64;
            bladeCanvas.height = 256;
            const bctx = bladeCanvas.getContext("2d");
            // base gradient for blade color
            const g2 = bctx.createLinearGradient(0, 0, 0, bladeCanvas.height);
            g2.addColorStop(0, "#66b86a");
            g2.addColorStop(1, "#2f7a2f");
            bctx.fillStyle = g2;
            bctx.fillRect(0, 0, bladeCanvas.width, bladeCanvas.height);
            // alpha mask: draw triangular taper
            bctx.globalCompositeOperation = "destination-in";
            bctx.beginPath();
            bctx.moveTo(bladeCanvas.width / 2, 0);
            bctx.lineTo(bladeCanvas.width, bladeCanvas.height);
            bctx.lineTo(0, bladeCanvas.height);
            bctx.closePath();
            bctx.fillStyle = "rgba(0,0,0,1)";
            bctx.fill();
            // add subtle vein lines on the blade for realism
            bctx.globalCompositeOperation = "source-over";
            bctx.strokeStyle = "rgba(20,60,20,0.12)";
            bctx.lineWidth = 1.2;
            for (let v = 0; v < 6; v++) {
              const sx = bladeCanvas.width / 2 + (Math.random() - 0.5) * 6;
              const sy = Math.random() * bladeCanvas.height * 0.1;
              const ex = bladeCanvas.width / 2 + (Math.random() - 0.5) * 10;
              const ey =
                bladeCanvas.height - Math.random() * bladeCanvas.height * 0.05;
              bctx.beginPath();
              bctx.moveTo(sx, sy);
              bctx.quadraticCurveTo(
                bladeCanvas.width / 2 + (Math.random() - 0.5) * 12,
                bladeCanvas.height * 0.5,
                ex,
                ey
              );
              bctx.stroke();
            }
            const bladeTex = new THREE.CanvasTexture(bladeCanvas);
            try {
              bladeTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            } catch (e) {}
            bladeTex.wrapS = bladeTex.wrapT = THREE.ClampToEdgeWrapping;

            const perMeshCount = 800; // two crossed planes (A+B) total 1600 blades
            const planeGeom = new THREE.PlaneGeometry(0.06, 1.0);
            const bladeMat = new THREE.MeshStandardMaterial({
              map: bladeTex,
              transparent: true,
              side: THREE.DoubleSide,
              alphaTest: 0.4,
              roughness: 0.95,
            });

            // Create two crossed instanced meshes for fuller silhouettes
            const bladesA = new THREE.InstancedMesh(
              planeGeom,
              bladeMat,
              perMeshCount
            );
            const bladesB = new THREE.InstancedMesh(
              planeGeom,
              bladeMat,
              perMeshCount
            );
            bladesA.castShadow = false;
            bladesA.receiveShadow = true;
            bladesB.castShadow = false;
            bladesB.receiveShadow = true;

            const dummy = new THREE.Object3D();
            const bladesDataA = [];
            const bladesDataB = [];
            for (let i = 0; i < perMeshCount; i++) {
              // shared distribution for both meshes
              let x, z;
              do {
                x = (Math.random() - 0.5) * 100; // -50..50
                z = 25 + Math.random() * 50; // 25..75
              } while (
                x >= MUSEUM_OFFSET_X - 30 &&
                x <= MUSEUM_OFFSET_X + 30 &&
                z >= MUSEUM_OFFSET_Z - 30 &&
                z <= MUSEUM_OFFSET_Z + 30
              );
              // shorter blades
              const h = 0.15 + Math.random() * 0.45; // 0.15 .. 0.6
              const rotY = (Math.random() - 0.5) * 1.2;

              // bladesA
              dummy.position.set(x, h / 2, z);
              dummy.rotation.set(0, rotY, 0);
              dummy.scale.set(1, h, 1);
              dummy.updateMatrix();
              bladesA.setMatrixAt(i, dummy.matrix);
              bladesDataA.push({
                x,
                z,
                h,
                rotY,
                phase: Math.random() * Math.PI * 2,
                amp: 0.02 + Math.random() * 0.04,
                speed: 0.8 + Math.random() * 1.2,
              });

              // bladesB: same position but rotated 90deg to form an X cross
              dummy.rotation.set(0, rotY + Math.PI / 2, 0);
              dummy.updateMatrix();
              bladesB.setMatrixAt(i, dummy.matrix);
              bladesDataB.push({
                x,
                z,
                h,
                rotY: rotY + Math.PI / 2,
                phase: Math.random() * Math.PI * 2,
                amp: 0.02 + Math.random() * 0.04,
                speed: 0.8 + Math.random() * 1.2,
              });
            }

            bladesA.instanceMatrix.needsUpdate = true;
            bladesB.instanceMatrix.needsUpdate = true;
            scene.add(bladesA);
            scene.add(bladesB);

            // Expose arrays for animation update and initialize update indexes
            grassInstancedMeshes = [bladesA, bladesB];
            grassBladesInfo = [bladesDataA, bladesDataB];
            grassUpdateIndex = [0, 0];
          } catch (e) {
            console.warn("instanced grass blades failed", e);
          }
        })();

        // Wire up debug UI controls ( colliders, etc.)
        (function () {
          // wire collider debug toggle button (created in HTML near grid toggle)
          // Now cycles through 3 states: Off → Box → Triangle
          try {
            const collBtn = document.getElementById("toggle-colliders-btn");
            if (collBtn) {
              collBtn.addEventListener("click", () => {
                // Simple on/off toggle for collision visualization
                showColliders = !showColliders;

                // Update button text and state
                collBtn.textContent = showColliders
                  ? "Colliders Visual: ON (C)"
                  : "Colliders Visual: OFF (C)";
                collBtn.setAttribute(
                  "aria-pressed",
                  showColliders ? "true" : "false"
                );

                console.log(`🔲 Collision visualization: ${showColliders ? 'ON' : 'OFF'}`);

                // rebuild helpers to show/hide boxes
                rebuildColliderHelpers();
              });
            }
            // wire solid colliders toggle
            try {
              const solidBtn = document.getElementById(
                "toggle-solid-colliders-btn"
              );
              if (solidBtn) {
                solidBtn.addEventListener("click", () => {
                  showSolidColliders = !showSolidColliders;
                  solidBtn.setAttribute(
                    "aria-pressed",
                    showSolidColliders ? "true" : "false"
                  );
                  solidBtn.textContent = showSolidColliders
                    ? "Solid: ON (Shift+C)"
                    : "Solid: OFF (Shift+C)";
                  // rebuild to create or remove solid meshes
                  rebuildColliderHelpers();
                });
              }
              // keyboard shortcut Shift+C toggles solid colliders
              window.addEventListener("keydown", (ev) => {
                if (ev && ev.code === "KeyC" && ev.shiftKey) {
                  ev.preventDefault();
                  if (
                    document.activeElement &&
                    (document.activeElement.tagName === "INPUT" ||
                      document.activeElement.tagName === "TEXTAREA")
                  )
                    return;
                  const b = document.getElementById(
                    "toggle-solid-colliders-btn"
                  );
                  if (b) b.click();
                }
              });
            } catch (e) {
              /* non-fatal */
            }
            // wire BVH collision toggle
            try {
              const bvhBtn = document.getElementById(
                "toggle-bvh-collision-btn"
              );
              if (bvhBtn) {
                bvhBtn.addEventListener("click", () => {
                  useBVHCollision = !useBVHCollision;
                  bvhBtn.setAttribute(
                    "aria-pressed",
                    useBVHCollision ? "true" : "false"
                  );
                  bvhBtn.textContent = useBVHCollision
                    ? "Collision: Triangle (B)"
                    : "Collision: Box (B)";
                  console.log("━━━ Collision Mode Switched ━━━");
                  console.log(
                    "Mode:",
                    useBVHCollision
                      ? "Triangle (precise geometry)"
                      : "Box (fast AABB)"
                  );
                  console.log(
                    "Triangle Colliders:",
                    bvhColliders.length,
                    "meshes"
                  );
                  console.log(
                    "AABB Colliders:",
                    collidersBoxes.length,
                    "boxes"
                  );
                  console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
                  // Rebuild visualization to show appropriate collision type
                  rebuildColliderHelpers();
                });
              }
              // keyboard shortcut B toggles triangle collision
              window.addEventListener("keydown", (ev) => {
                if (ev && ev.code === "KeyB" && !ev.shiftKey) {
                  ev.preventDefault();
                  if (
                    document.activeElement &&
                    (document.activeElement.tagName === "INPUT" ||
                      document.activeElement.tagName === "TEXTAREA")
                  )
                    return;
                  const b = document.getElementById("toggle-bvh-collision-btn");
                  if (b) b.click();
                }
              });
            } catch (e) {
              /* non-fatal */
            }
            // keyboard shortcut 'C' toggles wireframe colliders (without Shift)
            window.addEventListener("keydown", (ev) => {
              if (ev && ev.code === "KeyC" && !ev.shiftKey) {
                ev.preventDefault();
                if (
                  document.activeElement &&
                  (document.activeElement.tagName === "INPUT" ||
                    document.activeElement.tagName === "TEXTAREA")
                )
                  return;
                const b = document.getElementById("toggle-colliders-btn");
                if (b) b.click();
              }
            });
          } catch (e) {
            /* non-fatal */
          }

    
        })();

        // (removed entrance steps — door provides the exit)

        // Walls
        createWalls();

        // Art pieces
        createArtPieces();

        // Pedestals
        createPedestals();

        // Wooden sign near the entrance
        createWoodSign();

        // Load Capitol Model
        loadCapitolModel();

        // Wire the on-screen Test URL button so you can paste the Netlify URL and re-run the loader
        (function () {
          const btn = document.getElementById("model-test-btn");
          const input = document.getElementById("model-test-url");
          if (!btn || !input) return;
          btn.addEventListener("click", () => {
            const v = (input.value || "").trim();
            if (!v) return alert("Paste a model URL into the input first");
            try {
              loadCapitolModel([v]);
            } catch (e) {
              console.error("test load failed", e);
            }
          });
          // pre-fill input with a convenient path
          try {
            input.value =
              "https://flqsdjtfkgycvssdbegd.supabase.co/storage/v1/object/public/models/ArizonaStateCapitolModelV1.glb";
          } catch (e) {}
          // Wire the Back to Explorer button to navigate to the Explorer page
          try {
            const backBtn = document.getElementById("explorer-back-btn");
            if (backBtn) {
              backBtn.addEventListener("click", () => {
                window.location.href = "./Arizona-Legislative-Explorer.html";
              });
            }
          } catch (e) {
            console.warn("Back to Explorer wiring failed", e);
          }
        })();

        // Pointer lock setup - request pointer lock on the canvas element itself.
        const canvasEl = document.getElementById("canvas");
        try {
          canvasEl.tabIndex = 0;
          canvasEl.style.outline = "none";
        } catch (e) {}
        canvasEl.addEventListener("click", (ev) => {
          // ONLY request pointer lock in game mode, NOT in editor mode
          if (isEditorMode) {
            console.log("🎨 Editor mode active - pointer lock disabled");
            return; // Don't request pointer lock in editor mode
          }
          // Only request pointer lock if not already locked to the canvas
          try {
            if (document.pointerLockElement !== canvasEl)
              canvasEl.requestPointerLock();
          } catch (e) {
            console.warn("requestPointerLock failed", e);
          }
        });
        // Drag-to-look fallback: allow click+drag to look when pointer lock is unavailable (ONLY in game mode)
        canvasEl.addEventListener("mousedown", (e) => {
          if (!isEditorMode) {
            // Only enable drag-to-look in game mode
            isMouseDown = true;
            lastClientX = e.clientX;
            lastClientY = e.clientY;
            canvasEl.style.cursor = "grabbing";
          }
        });
        window.addEventListener("mouseup", (e) => {
          if (!isEditorMode) {
            // Only in game mode
            isMouseDown = false;
            canvasEl.style.cursor = "default";
          }
        });

        document.addEventListener("pointerlockchange", onPointerLockChange);
        document.addEventListener("pointerlockerror", onPointerLockError);

        // Keyboard controls
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        // Mouse movement
        document.addEventListener("mousemove", onMouseMove);

        // Window resize
        window.addEventListener("resize", onWindowResize);
      }

      function createWalls() {
        const wallMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
        });

        // Back wall
        const wall1 = new THREE.Mesh(
          new THREE.BoxGeometry(50, 10, 0.5),
          wallMaterial
        );
        const wall1Pos = rotatePointAroundMuseum(0, -25);
        wall1.position.set(wall1Pos.x, 5, wall1Pos.z);
        wall1.rotation.y = MUSEUM_ROTATION_Y;
        wall1.receiveShadow = true;
        wall1.castShadow = true;
        scene.add(wall1);
        addColliderFromObject(wall1);

        // Left wall
        const wall2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 10, 50),
          wallMaterial
        );
        const wall2Pos = rotatePointAroundMuseum(-25, 0);
        wall2.position.set(wall2Pos.x, 5, wall2Pos.z);
        wall2.rotation.y = MUSEUM_ROTATION_Y;
        wall2.receiveShadow = true;
        wall2.castShadow = true;
        scene.add(wall2);
        addColliderFromObject(wall2);

        // Right wall
        const wall3 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 10, 50),
          wallMaterial
        );
        const wall3Pos = rotatePointAroundMuseum(25, 0);
        wall3.position.set(wall3Pos.x, 5, wall3Pos.z);
        wall3.rotation.y = MUSEUM_ROTATION_Y;
        wall3.receiveShadow = true;
        wall3.castShadow = true;
        scene.add(wall3);
        addColliderFromObject(wall3);

        // Front wall (with opening)
        const wall4a = new THREE.Mesh(
          new THREE.BoxGeometry(15, 10, 0.5),
          wallMaterial
        );
        const wall4aPos = rotatePointAroundMuseum(-17.5, 25);
        wall4a.position.set(wall4aPos.x, 5, wall4aPos.z);
        wall4a.rotation.y = MUSEUM_ROTATION_Y;
        wall4a.receiveShadow = true;
        scene.add(wall4a);
        addColliderFromObject(wall4a);

        const wall4b = new THREE.Mesh(
          new THREE.BoxGeometry(15, 10, 0.5),
          wallMaterial
        );
        const wall4bPos = rotatePointAroundMuseum(17.5, 25);
        wall4b.position.set(wall4bPos.x, 5, wall4bPos.z);
        wall4b.rotation.y = MUSEUM_ROTATION_Y;
        wall4b.receiveShadow = true;
        scene.add(wall4b);
        addColliderFromObject(wall4b);

        // create a door that fills the opening between wall4a and wall4b
        try {
          createDoor();
        } catch (e) {
          console.warn("createDoor failed", e);
        }

        // Add a header piece above the door to fully enclose the front wall opening
        try {
          // The opening between wall4a and wall4b spans roughly x=-10..10 at z=25
          // Compute header height dynamically from the actual door height (if available)
          const wallTopY = 10; // wall top
          let doorH = 5.0; // fallback door height
          try {
            if (
              doorLeftPivot &&
              doorLeftPivot.children &&
              doorLeftPivot.children.length > 0
            ) {
              const doorMesh = doorLeftPivot.children[0];
              if (
                doorMesh &&
                doorMesh.geometry &&
                doorMesh.geometry.parameters &&
                isFinite(doorMesh.geometry.parameters.height)
              ) {
                doorH = doorMesh.geometry.parameters.height;
              }
            }
          } catch (e) {
            /* ignore */
          }

          const headerHeight = Math.max(0.1, wallTopY - doorH); // ensure non-zero
          const headerGeom = new THREE.BoxGeometry(20, headerHeight, 0.5);
          const header = new THREE.Mesh(headerGeom, wallMaterial);
          // Center header vertically between door top and wall top
          const headerCenterY = (doorH + wallTopY) / 2;
          const headerPos = rotatePointAroundMuseum(0, 25);
          header.position.set(headerPos.x, headerCenterY, headerPos.z);
          header.rotation.y = MUSEUM_ROTATION_Y;
          header.receiveShadow = true;
          header.castShadow = true;
          scene.add(header);
          addColliderFromObject(header);
        } catch (e) {
          console.warn("create front header failed", e);
        }
      }

      function createArtPieces() {
        const paintings = [
          { localPos: [0, 3, -24.5], color: 0xff6b6b, size: [4, 3, 0.1] },
          { localPos: [-10, 3, -24.5], color: 0x4ecdc4, size: [3, 4, 0.1] },
          { localPos: [10, 3, -24.5], color: 0xffe66d, size: [3, 4, 0.1] },
          {
            localPos: [-24.5, 3, -10],
            color: 0x95e1d3,
            size: [4, 3, 0.1],
            rotY: Math.PI / 2,
          },
          {
            localPos: [-24.5, 3, 10],
            color: 0xf38181,
            size: [3, 4, 0.1],
            rotY: Math.PI / 2,
          },
          {
            localPos: [24.5, 3, -10],
            color: 0xaa96da,
            size: [4, 3, 0.1],
            rotY: -Math.PI / 2,
          },
          {
            localPos: [24.5, 3, 10],
            color: 0xfcbad3,
            size: [3, 4, 0.1],
            rotY: -Math.PI / 2,
          },
        ];

        paintings.forEach((p) => {
          const painting = new THREE.Mesh(
            new THREE.BoxGeometry(p.size[0], p.size[1], p.size[2]),
            new THREE.MeshStandardMaterial({ color: p.color })
          );
          const pos = rotatePointAroundMuseum(p.localPos[0], p.localPos[2]);
          painting.position.set(pos.x, p.localPos[1], pos.z);
          painting.rotation.y = MUSEUM_ROTATION_Y + (p.rotY || 0);
          painting.castShadow = true;
          scene.add(painting);
          addColliderFromObject(painting);

          // Frame
          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
          });
          const frameThickness = 0.15;

          const frame = new THREE.Group();
          const top = new THREE.Mesh(
            new THREE.BoxGeometry(
              p.size[0] + 0.4,
              frameThickness,
              frameThickness
            ),
            frameMaterial
          );
          top.position.y = p.size[1] / 2 + frameThickness / 2;
          frame.add(top);

          const bottom = new THREE.Mesh(
            new THREE.BoxGeometry(
              p.size[0] + 0.4,
              frameThickness,
              frameThickness
            ),
            frameMaterial
          );
          bottom.position.y = -p.size[1] / 2 - frameThickness / 2;
          frame.add(bottom);

          const left = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, p.size[1], frameThickness),
            frameMaterial
          );
          left.position.x = -p.size[0] / 2 - frameThickness / 2;
          frame.add(left);

          const right = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, p.size[1], frameThickness),
            frameMaterial
          );
          right.position.x = p.size[0] / 2 + frameThickness / 2;
          frame.add(right);

          frame.position.copy(painting.position);
          frame.rotation.y = MUSEUM_ROTATION_Y + (p.rotY || 0);
          scene.add(frame);
          addColliderFromObject(frame);
        });
      }

      function createPedestals() {
        const pedestalMaterial = new THREE.MeshStandardMaterial({
          color: 0x808080,
        });
        const localPositions = [
          [0, 0, 0],
          [-8, 0, 8],
          [8, 0, 8],
          [0, 0, -10],
        ];

        localPositions.forEach((localPos) => {
          const pos = rotatePointAroundMuseum(localPos[0], localPos[2]);
          // If this is the center position, skip creating a pedestal and place the seal on the floor.
          if (localPos[0] === 0 && localPos[2] === 0) {
            try {
              // Canvas texture for the floor seal
              const sealCanvas = document.createElement("canvas");
              sealCanvas.width = 1024;
              sealCanvas.height = 1024;
              const sctx = sealCanvas.getContext("2d");

              // Background circle (red)
              sctx.fillStyle = "#b22222";
              sctx.beginPath();
              sctx.arc(512, 512, 460, 0, Math.PI * 2);
              sctx.fill();

              // Outer ring (gold)
              sctx.lineWidth = 40;
              sctx.strokeStyle = "#d4af37";
              sctx.beginPath();
              sctx.arc(512, 512, 420, 0, Math.PI * 2);
              sctx.stroke();

              // Inner decorative star
              sctx.fillStyle = "#fff8e1";
              sctx.beginPath();
              const cx = 512,
                cy = 512,
                R = 180,
                r = 70;
              for (let i = 0; i < 16; i++) {
                const ang = (i / 16) * Math.PI * 2;
                const rad = i % 2 === 0 ? R : r;
                const x = cx + Math.cos(ang) * rad;
                const y = cy + Math.sin(ang) * rad;
                if (i === 0) sctx.moveTo(x, y);
                else sctx.lineTo(x, y);
              }
              sctx.closePath();
              sctx.fill();

              // Text label — use two lines so the longer name fits nicely on the seal
              sctx.fillStyle = "#fdebd3";
              sctx.textAlign = "center";
              sctx.font = "bold 64px sans-serif";
              sctx.fillText("Arizona State", cx, 700);
              sctx.fillText("Capitol Museum", cx, 780);

              const sealTex = new THREE.CanvasTexture(sealCanvas);
              sealTex.anisotropy = 4;
              sealTex.needsUpdate = true;

              // Use a flat circle so it acts visually like the floor (no thickness)
              const sealMat = new THREE.MeshStandardMaterial({
                map: sealTex,
                side: THREE.DoubleSide,
              });
              const seal = new THREE.Mesh(
                new THREE.CircleGeometry(1.5, 128),
                sealMat
              );
              // rotate so the circle faces upward (XZ plane)
              seal.rotation.x = -Math.PI / 2;
              seal.rotation.z = MUSEUM_ROTATION_Y; // rotate the texture design with the building
              // place slightly above floor to avoid z-fighting, but do NOT add a collider
              // so players will walk smoothly over the seal like the floor
              seal.position.set(pos.x, 0.01, pos.z);
              seal.receiveShadow = true;
              scene.add(seal);

              // Spike removed per user request — previously we added a small cone here.
              // If you want a subtle decorative element later, recreate it here.
            } catch (e) {
              console.warn("create center floor seal failed", e);
            }
          } else {
            // Regular pedestal + sculpture
            const pedestal = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 1.2, 2, 8),
              pedestalMaterial
            );
            pedestal.position.set(pos.x, 1, pos.z);
            pedestal.castShadow = true;
            pedestal.receiveShadow = true;
            scene.add(pedestal);
            addColliderFromObject(pedestal);

            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            const sculpture = new THREE.Mesh(
              new THREE.SphereGeometry(0.5, 16, 16),
              new THREE.MeshStandardMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                metalness: 0.7,
                roughness: 0.3,
              })
            );
            sculpture.position.set(pos.x, 2.5, pos.z);
            sculpture.castShadow = true;
            scene.add(sculpture);
            addColliderFromObject(sculpture);
          }
        });
      }

      // Create a pair of double doors in the front opening. Doors are initially closed and
      // added as colliders; when opening they animate and their colliders are removed so
      // the player can pass outside.
      function createDoor() {
        // single smaller swinging door centered in the opening
        // reduced slightly to be less dominant but still passable by the player
        const doorWidth = 2.2; // reduced width (must remain > player diameter ~1.6)
        const doorHeight = 3.8; // reduced height but taller than player height
        const doorThickness = 0.12;

        const doorMaterial = new THREE.MeshStandardMaterial({
          color: 0x6b3f1c,
          metalness: 0.15,
          roughness: 0.55,
        });

        // Single door pivot: hinge on the left edge of the door so door is centered at x=0
        const pivot = new THREE.Group();
        const pivotPos = rotatePointAroundMuseum(-doorWidth / 2, 25);
        pivot.position.set(pivotPos.x, doorHeight / 2, pivotPos.z);
        pivot.rotation.y = MUSEUM_ROTATION_Y;
        const doorGeom = new THREE.BoxGeometry(
          doorWidth,
          doorHeight,
          doorThickness
        );
        const doorMesh = new THREE.Mesh(doorGeom, doorMaterial);
        // position door so its center sits at x=0 (pivot + doorWidth/2)
        doorMesh.position.set(doorWidth / 2, 0, 0);
        doorMesh.castShadow = true;
        doorMesh.receiveShadow = true;
        pivot.add(doorMesh);
        scene.add(pivot);

        // modest frame pieces for visuals (left/right of opening)
        // create solid side walls that connect the front wall segments to the door sides
        // so the building fully encloses the doorway on the sides (prevents bypassing around the door)
        const sideMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
        // opening extents (based on front wall pieces): opening spans x = -10 .. 10
        const openingLeft = -10;
        const openingRight = 10;
        // left side spans from openingLeft to left door edge (-doorWidth/2)
        const leftWidth = -doorWidth / 2 - openingLeft; // e.g. 10 - doorWidth/2
        const leftCenterX = (openingLeft + -doorWidth / 2) / 2;
        const leftSide = new THREE.Mesh(
          new THREE.BoxGeometry(leftWidth, 10, 0.5),
          sideMat
        );
        const leftSidePos = rotatePointAroundMuseum(leftCenterX, 25);
        leftSide.position.set(leftSidePos.x, 5, leftSidePos.z);
        leftSide.rotation.y = MUSEUM_ROTATION_Y;
        leftSide.receiveShadow = true;
        leftSide.castShadow = true;
        scene.add(leftSide);
        addColliderFromObject(leftSide);

        // right side: symmetric (spans from right door edge to openingRight)
        const rightWidth = openingRight - doorWidth / 2;
        const rightCenterX = (doorWidth / 2 + openingRight) / 2;
        const rightSide = new THREE.Mesh(
          new THREE.BoxGeometry(rightWidth, 10, 0.5),
          sideMat
        );
        const rightSidePos = rotatePointAroundMuseum(rightCenterX, 25);
        rightSide.position.set(rightSidePos.x, 5, rightSidePos.z);
        rightSide.rotation.y = MUSEUM_ROTATION_Y;
        rightSide.receiveShadow = true;
        rightSide.castShadow = true;
        scene.add(rightSide);
        addColliderFromObject(rightSide);

        // register single door pivot collider entry so we can update/remove it
        const entry = addColliderFromObject(pivot);
        doorColliderEntries = [entry];

        // set globals for single-door usage
        doorLeftPivot = pivot; // use leftPivot variable to hold the single pivot
        doorRightPivot = null;
        doorOpen = false;
        doorOpening = false;
        doorOpenProgress = 0;
      }

      // Wooden sign with canvas texture for instructions
      function createWoodSign() {
        try {
          const canvas = document.createElement("canvas");
          canvas.width = 1024;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");

          // Wood background gradient
          const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
          g.addColorStop(0, "#8b5a2b");
          g.addColorStop(0.5, "#a76a33");
          g.addColorStop(1, "#6b3f1c");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Simple plank lines
          ctx.fillStyle = "rgba(0,0,0,0.06)";
          for (let i = 1; i < 5; i++) {
            const y = i * (canvas.height / 5);
            ctx.fillRect(0, y - 2, canvas.width, 4);
          }

          // Draw frame
          ctx.fillStyle = "#4e2f18";
          const pad = 18;
          ctx.fillRect(0, 0, canvas.width, pad);
          ctx.fillRect(0, canvas.height - pad, canvas.width, pad);
          ctx.fillRect(0, 0, pad, canvas.height);
          ctx.fillRect(canvas.width - pad, 0, pad, canvas.height);

          // Text - title and instructions (multi-line)
          ctx.fillStyle = "#fdebd3";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.font = "64px serif";
          ctx.shadowColor = "rgba(0,0,0,0.6)";
          ctx.shadowBlur = 8;
          ctx.fillText("Museum Virtual Tour", canvas.width / 2, 36);

          ctx.shadowBlur = 2;
          ctx.font = "28px sans-serif";
          const lines = [
            "Click to start",
            "WASD or Arrow Keys - Move",
            "Space - Jump",
            "F - Toggle Fly Mode",
            "E - Fly Up / Q - Fly Down (while flying)",
            "Mouse - Look around",
            "ESC - Exit",
          ];
          let y = 130;
          for (const ln of lines) {
            ctx.fillText(ln, canvas.width / 2, y);
            y += 40;
          }

          const texture = new THREE.CanvasTexture(canvas);
          texture.anisotropy = 4;
          texture.needsUpdate = true;

          const mat = new THREE.MeshStandardMaterial({
            map: texture,
            side: THREE.DoubleSide,
          });
          // slightly smaller sign so it doesn't dominate the view
          const geom = new THREE.PlaneGeometry(6, 3);
          const signMesh = new THREE.Mesh(geom, mat);
          signMesh.castShadow = true;
          signMesh.receiveShadow = true;

          // Smaller sign and posts so the sign appears less dominant and posts touch the floor
          // New sign size
          const SIGN_WIDTH = 4.0;
          const SIGN_HEIGHT = 1.6; // plane height
          signMesh.geometry = new THREE.PlaneGeometry(SIGN_WIDTH, SIGN_HEIGHT);

          // Posts sized so their bottoms touch the floor when the group Y is set
          const postMat = new THREE.MeshStandardMaterial({ color: 0x4e2f18 });
          // slightly shorter posts so sign sits closer to the ground
          const POST_HEIGHT = 2.2;
          const postGeo = new THREE.BoxGeometry(0.22, POST_HEIGHT, 0.22);
          const leftPost = new THREE.Mesh(postGeo, postMat);
          const rightPost = leftPost.clone();
          leftPost.castShadow = true;
          rightPost.castShadow = true;

          // Compute local post Y so their top aligns with bottom of sign plane
          const postLocalY = -(SIGN_HEIGHT / 2) - POST_HEIGHT / 2; // e.g. -0.8 -1.4 = -2.2
          const postXOffset = SIGN_WIDTH / 2 - 0.4; // place posts slightly inside sign edges

          // Group and position near player's starting view
          signGroup = new THREE.Group();
          signGroup.add(signMesh);
          signGroup.add(leftPost);
          signGroup.add(rightPost);

          // place the sign so posts touch floor: groupY = SIGN_HEIGHT/2 + POST_HEIGHT
          const groupY = SIGN_HEIGHT / 2 + POST_HEIGHT; // compute group Y so posts touch floor
          // move sign to a position slightly in front of the wall but not too far from the player
          const signPos = rotatePointAroundMuseum(0, -6);
          signGroup.position.set(signPos.x, groupY, signPos.z);

          // position posts relative to sign (below the sign plane)
          leftPost.position.set(-postXOffset, postLocalY, 0.06);
          rightPost.position.set(postXOffset, postLocalY, 0.06);

          // rotate sign to face outward from the rotated building
          signMesh.rotation.x = 0;
          signMesh.rotation.z = 0;
          signGroup.rotation.y = MUSEUM_ROTATION_Y;

          scene.add(signGroup);
          // add wooden sign to colliders so player cannot walk through it
          addColliderFromObject(signGroup);
        } catch (e) {
          console.warn("createWoodSign error", e);
        }
      }

      function loadCapitolModel(testUrls) {
        // Helper that updates the on-screen loader status (if present)
        const updateLoaderStatus = (msg) => {
          try {
            const el = document.getElementById("loader-status");
            if (el) el.textContent = "Model: " + msg;
          } catch (e) {}
        };

        // Load additional models from configuration
        function loadAdditionalModels() {
          if (!ADDITIONAL_MODELS_CONFIG || ADDITIONAL_MODELS_CONFIG.length === 0) {
            console.log('📦 No additional models configured to load');
            return;
          }

          console.log(`📦 Loading ${ADDITIONAL_MODELS_CONFIG.length} additional models from configuration...`);

          ADDITIONAL_MODELS_CONFIG.forEach((modelConfig, index) => {
            if (!modelConfig.url || !modelConfig.name) {
              console.warn(`⚠️ Skipping model ${index}: missing name or url`, modelConfig);
              return;
            }

            console.log(`📦 Loading additional model: ${modelConfig.name} from ${modelConfig.url}`);

            const loader = new THREE.GLTFLoader();
            loader.load(
              modelConfig.url,
              (gltf) => {
                const model = gltf.scene;
                model.name = modelConfig.name;

                // Apply position, rotation, scale from config
                if (modelConfig.position) {
                  model.position.set(
                    modelConfig.position.x || 0,
                    modelConfig.position.y || 0,
                    modelConfig.position.z || 0
                  );
                }
                if (modelConfig.rotation) {
                  model.rotation.set(
                    modelConfig.rotation.x || 0,
                    modelConfig.rotation.y || 0,
                    modelConfig.rotation.z || 0
                  );
                }
                if (modelConfig.scale) {
                  model.scale.set(
                    modelConfig.scale.x || 1,
                    modelConfig.scale.y || 1,
                    modelConfig.scale.z || 1
                  );
                }

                // Mark as GLB model with source URL
                model.userData.isGLBModel = true;
                model.userData.glbSourceURL = modelConfig.url;

                // Enable shadows
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });

                scene.add(model);

                // Add collisions automatically for the loaded model
                console.log(`🔲 Adding collisions for: ${modelConfig.name}`);
                addCollidersForModel(model);
                if (useBVHCollision) {
                  // Add to triangle collision system
                  model.traverse((child) => {
                    if (child && child.isMesh && child.geometry) {
                      bvhColliders.push({
                        mesh: child,
                        raycaster: new THREE.Raycaster()
                      });
                    }
                  });
                }

                console.log(`✅ Additional model loaded: ${modelConfig.name}`);
              },
              (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                console.log(`Loading ${modelConfig.name}... ${percent}%`);
              },
              (error) => {
                console.error(`❌ Error loading additional model ${modelConfig.name}:`, error);
                console.error(`   URL: ${modelConfig.url}`);
              }
            );
          });
        }

        // Try local path first, then fall back to remote URL(s)
        function loadGLBWithFallback(urls, onLoad, onProgress, onAllFailed) {
          let idx = 0;
          function tryNext() {
            if (idx >= urls.length) {
              updateLoaderStatus("all URLs failed");
              if (onAllFailed) onAllFailed(new Error("All GLB URLs failed"));
              return;
            }
            const url = urls[idx++];
            updateLoaderStatus("loading " + url);
            let loader = null;
            if (typeof THREE !== "undefined" && THREE.GLTFLoader)
              loader = new THREE.GLTFLoader();
            else if (typeof GLTFLoader !== "undefined")
              loader = new GLTFLoader();
            else {
              updateLoaderStatus("GLTFLoader not available");
              console.error("GLTFLoader not available");
              createPlaceholderBuilding();
              if (onAllFailed)
                onAllFailed(new Error("GLTFLoader not available"));
              return;
            }

            // Primary attempt: use GLTFLoader.load (standard XHR). If it fails, try a fetch+blob fallback
            let triedFallback = false;
            loader.load(
              url,
              (gltf) => {
                updateLoaderStatus("loaded " + url);
                if (onLoad) onLoad(gltf);
              },
              (p) => {
                if (p && p.total)
                  updateLoaderStatus(
                    "loading " +
                      Math.round((p.loaded / p.total) * 100) +
                      "% (" +
                      url +
                      ")"
                  );
                if (onProgress) onProgress(p);
              },
              async (err) => {
                console.warn("failed to load via loader.load", url, err);
                updateLoaderStatus(
                  "loader.load failed: " + url + " — attempting fetch fallback"
                );

                // Try fetch -> blob -> loader.load(blobUrl)
                try {
                  // perform a fetch to get more diagnostics
                  const resp = await fetch(url, {
                    method: "GET",
                    credentials: "include",
                  });
                  updateLoaderStatus(
                    "fetch status " + resp.status + " for " + url
                  );
                  if (!resp.ok) {
                    updateLoaderStatus(
                      "fetch failed: " + resp.status + " " + resp.statusText
                    );
                    console.warn("fetch failed", resp.status, resp.statusText);
                    // move to next url
                    tryNext();
                    return;
                  }

                  // log content-type for diagnosis
                  try {
                    const ct = resp.headers.get("content-type");
                    console.log("GLB content-type:", ct);
                    updateLoaderStatus("content-type: " + (ct || "unknown"));
                  } catch (e) {}

                  const blob = await resp.blob();
                  // create a blob URL and try loader.load again
                  const blobUrl = URL.createObjectURL(blob);
                  triedFallback = true;
                  updateLoaderStatus("loading blob URL");
                  loader.load(
                    blobUrl,
                    (gltf) => {
                      updateLoaderStatus("loaded via blob " + url);
                      // revoke object URL after loaded
                      try {
                        URL.revokeObjectURL(blobUrl);
                      } catch (e) {}
                      if (onLoad) onLoad(gltf);
                    },
                    (p) => {
                      if (p && p.total)
                        updateLoaderStatus(
                          "loading " +
                            Math.round((p.loaded / p.total) * 100) +
                            "% (blob)"
                        );
                      if (onProgress) onProgress(p);
                    },
                    (err2) => {
                      console.warn("blob loader failed for", url, err2);
                      try {
                        URL.revokeObjectURL(blobUrl);
                      } catch (e) {}
                      // if blob attempt failed, fall through to try next URL
                      tryNext();
                    }
                  );
                } catch (fetchErr) {
                  console.warn("fetch fallback failed for", url, fetchErr);
                  updateLoaderStatus("fetch fallback failed");
                  // try next URL
                  tryNext();
                }
              }
            );
          }
          tryNext();
        }

        // Try Supabase first, then fall back to other URLs
        const urlsToTry = testUrls || [
          // Supabase Storage (primary)
          "https://flqsdjtfkgycvssdbegd.supabase.co/storage/v1/object/public/models/ArizonaStateCapitolModelV1.glb",

          // Fallback URLs
          "https://www.azleg.gov/azlegwp/wp-content/uploads/2025/10/ArizonaStateCapitolModelV1.glb",
        ];

        console.log("🔍 Attempting to load museum model from URLs:", urlsToTry);

        loadGLBWithFallback(
          urlsToTry,
          (gltf) => {
            const loadedModel = gltf.scene;

            // FIX: The Blender model has its origin offset from visual center
            // Wrap in a container group and offset the model to center it visually
            const modelContainer = new THREE.Group();
            modelContainer.name = "museum";

            console.log(`🏛️ Fixing model origin offset:`);
            console.log(`   Loaded model original position: ${loadedModel.position.toArray()}`);

            // The model's origin in Blender is at (-50, -3.7, 35) relative to its visual center
            // Offset it back so the visual center is at the group's origin
            loadedModel.position.set(50, 3.7, -35);

            try {
              loadedModel.rotation.y += Math.PI;
            } catch (e) {}

            // Add the offset model to the container
            modelContainer.add(loadedModel);

            console.log(`   Model offset inside container: ${loadedModel.position.toArray()}`);

            // Now position the CONTAINER at the desired world position
            modelContainer.position.set(0, 1, 65);
            modelContainer.scale.set(1, 1, 1);

            console.log(`   Container (museum) position: ${modelContainer.position.toArray()}`);
            console.log(`   ✅ Transform controls will now appear at visual center!`);

            // Use the container as "model" for the rest of the code
            const model = modelContainer;

            // Enable shadows on all meshes
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            // Note: model.name is already set to "museum" when container was created
            // Note: model.position is already set to (0, 1, 65) when container was created

            // Log the FINAL default position before adding to scene
            console.log(`🏛️ Museum DEFAULT position (before saved config):`, {
              position: model.position.toArray(),
              rotation: model.rotation.toArray(),
              scale: model.scale.toArray()
            });

            scene.add(model);

            // Apply saved positions from config file if available
            // This will override the default position if a saved config exists
            try {
              applySavedWorldConfig();
            } catch (e) {
              console.warn("Failed to apply saved world config", e);
            }

            // Load additional models from configuration
            loadAdditionalModels();

            // Log position AFTER loading config
            console.log(`🏛️ Museum position AFTER loading config:`, {
              position: model.position.toArray(),
              rotation: model.rotation.toArray(),
              scale: model.scale.toArray()
            });

            try {
              // Remove previous model lights if present
              if (modelLightGroup) {
                try {
                  scene.remove(modelLightGroup);
                } catch (e) {}
                modelLightGroup = null;
              }
              modelLightGroup = new THREE.Group();

              const key = new THREE.DirectionalLight(0xffffff, 0.6);
              key.position.set(
                model.position.x + 20,
                model.position.y + 40,
                model.position.z + 20
              );
              key.castShadow = true;
              key.shadow.mapSize.width = 2048;
              key.shadow.mapSize.height = 2048;
              const cam = key.shadow.camera;
              cam.left = -50;
              cam.right = 50;
              cam.top = 50;
              cam.bottom = -50;
              cam.near = 0.5;
              cam.far = 200;
              modelLightGroup.add(key);
              try {
                key.target =
                  model; /* don't add key.target to scene separately */
              } catch (e) {}

              // subtle hemisphere fill for a touch of sky/ground bounce at low intensity
              const fill = new THREE.HemisphereLight(0xffffff, 0x404040, 0.2);
              fill.position.set(
                model.position.x,
                model.position.y + 10,
                model.position.z
              );
              modelLightGroup.add(fill);

              // low-intensity rim light to gently separate the model from the background
              const rim = new THREE.PointLight(0xffe6cc, 0.2, 100);
              rim.position.set(
                model.position.x - 20,
                model.position.y + 10,
                model.position.z - 10
              );
              rim.castShadow = false;
              modelLightGroup.add(rim);

              scene.add(modelLightGroup);
            } catch (e) {
              console.warn("add model lights failed", e);
            }
            // previously we added a single model-level collider; instead create per-mesh colliders
            // to better match the model's shape. (addColliderFromObject omitted)
            // Create per-mesh colliders for the model so collisions better match the object's
            // visible geometry (finer-grained than a single big box)
            try {
              addCollidersForModel(model);
            } catch (e) {}
            // expose the loaded model for UI manipulation
            try {
              loadedModel = model;
            } catch (e) {}
            // Apply default 6x scale automatically so newly exported models appear at expected size
            try {
              const defaultFactor = 8;
              if (loadedModel && isFinite(defaultFactor) && defaultFactor > 0) {
                loadedModel.scale.multiplyScalar(defaultFactor);
                // set default position per user request (x, y, z)
                try {
                  const defaultPos = { x: -50, y: -3.7, z: 35 };
                  loadedModel.position.set(
                    defaultPos.x,
                    defaultPos.y,
                    defaultPos.z
                  );
                  // update any UI inputs if available
                  try {
                    const px = document.getElementById("pos-x");
                    const py = document.getElementById("pos-y");
                    const pz = document.getElementById("pos-z");
                    if (px) px.value = defaultPos.x;
                    if (py) py.value = defaultPos.y;
                    if (pz) pz.value = defaultPos.z;
                  } catch (e) {}
                } catch (e) {
                  console.warn("setting default position failed", e);
                }
                // update collider for moved/scaled model (update descendant meshes)
                try {
                  for (const e of collidersBoxes) {
                    if (e && e.obj && isDescendant(e.obj, loadedModel) && e.box)
                      e.box.setFromObject(e.obj);
                  }
                } catch (e) {}
              }
            } catch (e) {
              console.warn("applying default scale failed", e);
            }
            try {
              rebuildColliderHelpers();
            } catch (e) {}
            // Build BVH for precise triangle-level collision
            try {
              buildBVHForModel(model);
            } catch (e) {
              console.warn("BVH build failed:", e);
            }
            console.log("Capitol model loaded successfully!");
          },
          (progress) => {
            // progress handled via updateLoaderStatus already
            if (progress && progress.total)
              console.log(
                "Loading model...",
                Math.round((progress.loaded / progress.total) * 100) + "%"
              );
          },
          (err) => {
            console.error("All model URLs failed to load:", err);
            createPlaceholderBuilding();
          }
        );
      }

      function createPlaceholderBuilding() {
        // Fallback building if model doesn't load
        const buildingMaterial = new THREE.MeshStandardMaterial({
          color: 0xd4a574,
        });
        const building = new THREE.Mesh(
          new THREE.BoxGeometry(15, 12, 15),
          buildingMaterial
        );
        building.position.set(0, 6, 50);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
        addColliderFromObject(building);

        // Dome on top
        const domeMaterial = new THREE.MeshStandardMaterial({
          color: 0x8b7355,
          metalness: 0.4,
          roughness: 0.6,
        });
        const dome = new THREE.Mesh(
          new THREE.SphereGeometry(4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
          domeMaterial
        );
        dome.position.set(0, 12, 50);
        dome.castShadow = true;
        scene.add(dome);
        addColliderFromObject(dome);

        console.log("Placeholder building created");
      }

      function onPointerLockChange() {
        // Don't process pointer lock changes in editor mode
        if (isEditorMode) {
          // Force unlock if somehow locked in editor mode
          if (document.pointerLockElement) {
            document.exitPointerLock();
          }
          return;
        }

        // consider the canvas element as the pointer-lock owner (safer when embedded)
        const canvasEl = document.getElementById("canvas");
        isLocked = document.pointerLockElement === canvasEl;
        document
          .getElementById("instructions")
          .classList.toggle("hide", isLocked);
      }

      function onPointerLockError() {
        console.error("Pointer lock error");
      }

      function onMouseMove(event) {
        // Don't rotate camera in editor mode - OrbitControls handles camera movement
        if (isEditorMode) {
          return;
        }

        // If pointer lock is active use movementX/movementY; otherwise if the user is
        // holding the mouse button we emulate pointer lock using clientX/clientY deltas.
        let movementX = 0,
          movementY = 0;
        if (isLocked) {
          movementX = event.movementX || 0;
          movementY = event.movementY || 0;
        } else {
          if (!isMouseDown) return;
          movementX =
            event.movementX !== undefined
              ? event.movementX
              : event.clientX - lastClientX;
          movementY =
            event.movementY !== undefined
              ? event.movementY
              : event.clientY - lastClientY;
          lastClientX = event.clientX;
          lastClientY = event.clientY;
        }

        euler.setFromQuaternion(camera.quaternion);
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
        camera.quaternion.setFromEuler(euler);
      }

      function onKeyDown(event) {
        // In editor mode, WASD/arrows move the camera, not the character
        if (isEditorMode) {
          handleEditorCameraMovement(event.code, true);
          return; // Don't process character movement in editor mode
        }

        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            if (!isFlying && canJump) {
              velocity.y = jumpHeight;
              canJump = false;
              isJumping = true;
            }
            break;
          case "KeyF":
            // Toggle fly mode
            isFlying = !isFlying;
            if (!isFlying) {
              // When turning off fly mode, start falling
              isJumping = true;
              moveUp = false;
              moveDown = false;
            } else {
              // When turning on fly mode, reset vertical velocity
              velocity.y = 0;
              isJumping = false;
            }
            console.log("Fly mode:", isFlying ? "ON" : "OFF");
            break;
          case "KeyE":
            if (isFlying) moveUp = true;
            break;
          case "KeyQ":
            if (isFlying) moveDown = true;
            break;
        }
      }

      function onKeyUp(event) {
        // In editor mode, handle camera movement key release
        if (isEditorMode) {
          handleEditorCameraMovement(event.code, false);
          return; // Don't process character movement in editor mode
        }

        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "KeyE":
            moveUp = false;
            break;
          case "KeyQ":
            moveDown = false;
            break;
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        // ONLY run character physics in game mode, NOT in editor mode
        if (!isEditorMode) {
          // walking speed and flying speed (flying is twice walking)
          const walkSpeed = 60.0; // base walking speed
          const flightSpeed = walkSpeed * 2; // flying is twice walking speed

          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;

          // Apply gravity only if not flying
          if (isJumping && !isFlying) {
            velocity.y -= gravity * delta;
          }

          // Flying controls
          if (isFlying) {
            velocity.y -= velocity.y * 10.0 * delta;

            // Vertical movement with Q and E uses flight speed
            if (moveUp) velocity.y += flightSpeed * delta;
            if (moveDown) velocity.y -= flightSpeed * delta;
          }

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();

          // Movement works the same in both modes, but flying moves faster.
          // Choose speed depending on whether we're flying.
          const speed = isFlying ? flightSpeed : walkSpeed;
          // NOTE: forward/back were reversed — use += so a positive direction.z (moveForward)
          // moves the player along the camera's forward vector.
          if (moveForward || moveBackward)
            velocity.z += direction.z * speed * delta;
          if (moveLeft || moveRight) velocity.x += direction.x * speed * delta;

          // Move per-axis with safe binary-search stepping to avoid getting stuck inside geometry.
          const oldPos = camera.position.clone();

          // If we somehow start inside a collider, try to nudge out upwards a bit first
          if (isCapsuleColliding(camera.position)) {
            let freed = false;
            for (let i = 0; i < 8; i++) {
              camera.position.y += 0.12; // nudge up
              if (!isCapsuleColliding(camera.position)) {
                freed = true;
                break;
              }
            }
            if (!freed) {
              // try backing away along -forward a little
              const fw = new THREE.Vector3();
              camera.getWorldDirection(fw);
              fw.y = 0;
              fw.normalize();
              for (let i = 0; i < 8; i++) {
                camera.position.addScaledVector(fw, -0.15);
                if (!isCapsuleColliding(camera.position)) {
                  freed = true;
                  break;
                }
              }
            }
            if (!freed) {
              // as a last resort, reset to oldPos (before frame)
              camera.position.copy(oldPos);
              velocity.x = velocity.z = 0;
            }
          }

          // Door trigger: if player approaches the door from inside, start opening
          try {
            // Door trigger: if player approaches the door from inside, start opening
            if (
              !doorOpen &&
              !doorOpening &&
              (doorLeftPivot || doorRightPivot)
            ) {
              const doorWorldPos = rotatePointAroundMuseum(0, 25);
              const triggerPoint = new THREE.Vector3(
                doorWorldPos.x,
                camera.position.y,
                doorWorldPos.z
              );
              const dist = camera.position.distanceTo(triggerPoint);

              // Calculate if player is inside the building (relative to rotated door)
              // Transform player position to building's local coordinate system
              const dx = camera.position.x - MUSEUM_OFFSET_X;
              const dz = camera.position.z - MUSEUM_OFFSET_Z;
              const cos = Math.cos(-MUSEUM_ROTATION_Y);
              const sin = Math.sin(-MUSEUM_ROTATION_Y);
              const localZ = dx * sin + dz * cos;

              // only trigger if player is inside (local z < 25) and near the opening
              if (localZ < 25 && dist <= DOOR_TRIGGER_DISTANCE) {
                doorOpening = true;
              }
            }

            // Update door animation and colliders for either single or double-door setups
            if (doorOpening) {
              doorOpenProgress = Math.min(
                1,
                doorOpenProgress + delta / DOOR_OPEN_SPEED
              );
              const angle = doorOpenProgress * (Math.PI / 2); // 90 degrees

              if (doorLeftPivot && doorRightPivot) {
                // double doors
                doorLeftPivot.rotation.y = MUSEUM_ROTATION_Y + -angle;
                doorRightPivot.rotation.y = MUSEUM_ROTATION_Y + angle;
              } else if (doorLeftPivot) {
                // single door stored in doorLeftPivot, rotation is relative to building
                doorLeftPivot.rotation.y = MUSEUM_ROTATION_Y + -angle;
              }

              // update their collider boxes while moving
              for (const e of doorColliderEntries) {
                if (e && e.box && e.obj) e.box.setFromObject(e.obj);
              }

              if (doorOpenProgress >= 1) {
                doorOpen = true;
                doorOpening = false;
                // remove door collider entries so player can pass
                for (const e of doorColliderEntries) {
                  const idx = collidersBoxes.indexOf(e);
                  if (idx !== -1) collidersBoxes.splice(idx, 1);
                }
                doorColliderEntries = [];
              }
            }
          } catch (e) {
            console.warn("door animation update failed", e);
          }

          // helper: compute world-space deltas for local X and Z translations
          const forward = new THREE.Vector3();
          camera.getWorldDirection(forward);
          forward.y = 0;
          forward.normalize();
          const right = new THREE.Vector3()
            .crossVectors(forward, camera.up)
            .normalize();

          function safeMoveAlong(deltaVec, attemptedAmount) {
            // binary search max t in [0,1] such that oldPos + deltaVec * t is not colliding
            const EPS = 1e-3;
            let lo = 0,
              hi = 1;
            let best = 0;
            for (let i = 0; i < 16; i++) {
              const mid = (lo + hi) / 2;
              const testPos = new THREE.Vector3()
                .copy(oldPos)
                .addScaledVector(deltaVec, mid);
              if (!isCapsuleColliding(testPos)) {
                best = mid;
                lo = mid;
              } else {
                hi = mid;
              }
            }
            // apply best translation
            camera.position.copy(oldPos).addScaledVector(deltaVec, best);
            // return whether full move succeeded
            return best >= 1 - 1e-2;
          }

          // attempt X (right/left)
          const attemptedX = velocity.x * delta;
          if (Math.abs(attemptedX) > 1e-5) {
            const deltaX = new THREE.Vector3()
              .copy(right)
              .multiplyScalar(attemptedX);
            const fullX = safeMoveAlong(deltaX, attemptedX);
            if (!fullX) velocity.x = 0; // stop movement into obstacle
          }

          // update oldPos for Z movement (we base Z check on current camera.position so sliding is natural)
          oldPos.copy(camera.position);

          // attempt Z (forward/back)
          const attemptedZ = velocity.z * delta;
          if (Math.abs(attemptedZ) > 1e-5) {
            const deltaZ = new THREE.Vector3()
              .copy(forward)
              .multiplyScalar(attemptedZ);
            const fullZ = safeMoveAlong(deltaZ, attemptedZ);
            if (!fullZ) velocity.z = 0;
          }

          // Vertical movement
          if (isFlying) {
            camera.position.y += velocity.y * delta;
          } else {
            camera.position.y += velocity.y * delta;
          }

          // Ground collision only when not flying
          if (!isFlying && camera.position.y <= 1.6) {
            camera.position.y = 1.6;
            velocity.y = 0;
            canJump = true;
            isJumping = false;
          }

          // When exiting fly mode, fall to ground
          if (!isFlying && camera.position.y > 1.6) {
            velocity.y -= gravity * delta;
          }

          // remove sign sway — keep sign static
          if (signGroup) {
            signGroup.rotation.z = 0;
          }

          // Update instanced grass sway (simple per-instance rotation around Z)
          try {
            if (
              grassInstancedMeshes &&
              grassBladesInfo &&
              grassBladesInfo.length
            ) {
              const t = performance.now() / 1000;
              const dummy = new THREE.Object3D();
              // iterate per mesh, but update in batches to spread CPU work across frames
              for (let m = 0; m < grassInstancedMeshes.length; m++) {
                const mesh = grassInstancedMeshes[m];
                const data = grassBladesInfo[m];
                const cnt = data.length;
                if (cnt === 0) continue;
                let start = grassUpdateIndex[m] || 0;
                const batch = GRASS_UPDATE_BATCH;
                for (let k = 0; k < batch; k++) {
                  const i = (start + k) % cnt;
                  const info = data[i];
                  const sway = Math.sin(t * info.speed + info.phase) * info.amp;
                  dummy.position.set(info.x, info.h / 2, info.z);
                  // rotate around Z slightly to simulate bending, keep base Y rotation
                  dummy.rotation.set(0, info.rotY, sway);
                  dummy.scale.set(1, info.h, 1);
                  dummy.updateMatrix();
                  mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
                grassUpdateIndex[m] = (start + batch) % cnt;
              }
            }
          } catch (e) {
            /* non-fatal */
          }
        } // End of if (!isEditorMode) - character physics block

        prevTime = time;
        // Update debug grid labels to follow the camera when visible
        try {
          updateDebugGridCenterIfNeeded();
        } catch (e) {}
        // Update collider helpers and highlight the nearest collider's ground footprint
        try {
          updateColliderHelpersAndGround();
        } catch (e) {}

        // Update model position display if present
        try {
          const posDisplay = document.getElementById("model-pos-display");
          if (posDisplay && loadedModel) {
            posDisplay.textContent = `Pos: ${loadedModel.position.x.toFixed(
              2
            )}, ${loadedModel.position.y.toFixed(
              2
            )}, ${loadedModel.position.z.toFixed(2)}`;
          }
        } catch (e) {}

        // Update editor camera movement with WASD/Arrow keys
        if (isEditorMode) {
          updateEditorCameraPosition(delta);
        }

        // Update OrbitControls in editor mode
        if (isEditorMode && editorOrbitControls) {
          editorOrbitControls.update();
        }

        // Update object highlight if selected
        if (isEditorMode && objectHighlight && selectedObject) {
          objectHighlight.update();
        }

        renderer.render(scene, camera);
      }

      init();

      // Create spawn point marker after scene is initialized
      setTimeout(() => {
        if (scene && typeof THREE !== "undefined") {
          createSpawnPointMarker();
          console.log("🎯 Spawn point marker created");
        }
      }, 100);

      animate();

      // =================================================================
      // THREE.JS DEVELOPER TOOLS PANEL - JavaScript Functionality
      // =================================================================

      // Panel toggle functionality
      const devPanel = document.getElementById("dev-panel");
      const toggleDevPanelBtn = document.getElementById("toggle-dev-panel-btn");
      const closeDevPanelBtn = document.getElementById("close-dev-panel-btn");
      let devPanelOpen = false;

      function toggleDevPanel() {
        devPanelOpen = !devPanelOpen;
        devPanel.style.right = devPanelOpen ? "0" : "-600px";
      }

      toggleDevPanelBtn.addEventListener("click", toggleDevPanel);
      closeDevPanelBtn.addEventListener("click", toggleDevPanel);

      // Keyboard shortcut - Press 'Shift+T' to toggle dev panel (avoids conflict with WASD movement)
      document.addEventListener("keydown", (e) => {
        if ((e.key === "t" || e.key === "T") && e.shiftKey) {
          e.preventDefault();
          toggleDevPanel();
        }
      });

      // Tab switching functionality
      const devTabs = document.querySelectorAll(".dev-tab");
      const tabContents = document.querySelectorAll(".tab-content");

      devTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const targetTab = tab.dataset.tab;

          // Update tab styles
          devTabs.forEach((t) => {
            t.classList.remove("active");
            t.style.color = "#aaa";
            t.style.borderBottomColor = "transparent";
          });
          tab.classList.add("active");
          tab.style.color = "#fff";
          tab.style.borderBottomColor = "#667eea";

          // Show corresponding content
          tabContents.forEach((content) => {
            content.style.display = "none";
          });
          document.getElementById(`tab-${targetTab}`).style.display = "block";
        });
      });

      // Note: Old editor iframe buttons removed - now using in-game editor

      // Scene Inspector
      document
        .getElementById("inspect-scene-btn")
        .addEventListener("click", () => {
          console.log("=== SCENE INSPECTOR ===");
          console.log("Scene:", scene);
          console.log("Children count:", scene.children.length);
          console.log("Camera:", camera);
          console.log("Renderer:", renderer);
          if (loadedModel) {
            console.log("Loaded Model:", loadedModel);
            console.log("Model Position:", loadedModel.position);
            console.log("Model Scale:", loadedModel.scale);
          }
          console.log("Colliders:", collidersBoxes);
          console.log("BVH Colliders:", bvhColliders);
          alert("Scene details logged to console. Press F12 to view.");
        });

      // Stats.js integration
      let stats = null;
      let statsEnabled = false;
      document
        .getElementById("toggle-stats-btn")
        .addEventListener("click", function () {
          if (!statsEnabled) {
            // Load Stats.js dynamically
            const script = document.createElement("script");
            script.src =
              "https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js";
            script.onload = () => {
              stats = new Stats();
              stats.showPanel(0); // 0: fps, 1: ms, 2: mb
              stats.dom.style.position = "absolute";
              stats.dom.style.left = "auto";
              stats.dom.style.right = "20px";
              stats.dom.style.top = "260px";
              document.body.appendChild(stats.dom);
              statsEnabled = true;
              this.textContent = "Disable Stats";
              this.style.background = "#ef4444";

              // Add stats.begin() and stats.end() to animation loop
              const originalAnimate = window.animate;
              window.animate = function () {
                if (stats) stats.begin();
                originalAnimate();
                if (stats) stats.end();
              };
            };
            document.head.appendChild(script);
          } else {
            if (stats && stats.dom) {
              stats.dom.remove();
              stats = null;
              statsEnabled = false;
              this.textContent = "Enable Stats";
              this.style.background = "#10b981";
            }
          }
        });

      // dat.GUI integration
      let gui = null;
      let guiEnabled = false;
      document
        .getElementById("toggle-datgui-btn")
        .addEventListener("click", function () {
          if (!guiEnabled) {
            // Load dat.GUI dynamically
            const script = document.createElement("script");
            script.src =
              "https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js";
            script.onload = () => {
              gui = new dat.GUI();
              gui.domElement.style.position = "absolute";
              gui.domElement.style.top = "300px";
              gui.domElement.style.right = "20px";

              // Add some example controls
              const controls = {
                flyMode: false,
                showGrid: true,
                showColliders: showColliders,
              };

              gui
                .add(controls, "flyMode")
                .name("Fly Mode")
                .onChange((value) => {
                  console.log("Fly mode:", value);
                });

              if (loadedModel) {
                const modelFolder = gui.addFolder("Model");
                modelFolder
                  .add(loadedModel.position, "x", -50, 50)
                  .name("Position X");
                modelFolder
                  .add(loadedModel.position, "y", -50, 50)
                  .name("Position Y");
                modelFolder
                  .add(loadedModel.position, "z", -50, 50)
                  .name("Position Z");
                modelFolder.add(loadedModel.scale, "x", 0.1, 5).name("Scale X");
                modelFolder.add(loadedModel.scale, "y", 0.1, 5).name("Scale Y");
                modelFolder.add(loadedModel.scale, "z", 0.1, 5).name("Scale Z");
                modelFolder.open();
              }

              guiEnabled = true;
              this.textContent = "Hide dat.GUI";
              this.style.background = "#ef4444";
            };
            document.head.appendChild(script);
          } else {
            if (gui) {
              gui.destroy();
              gui = null;
              guiEnabled = false;
              this.textContent = "Show dat.GUI";
              this.style.background = "#f59e0b";
            }
          }
        });

      // OrbitControls integration
      let orbitControls = null;
      let orbitEnabled = false;
      let pointerLockActive = false;
      document
        .getElementById("toggle-orbit-btn")
        .addEventListener("click", function () {
          if (!orbitEnabled) {
            // Load OrbitControls dynamically
            const script = document.createElement("script");
            script.src =
              "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js";
            script.onload = () => {
              // Disable pointer lock
              document.exitPointerLock();
              pointerLockActive = false;

              orbitControls = new THREE.OrbitControls(
                camera,
                renderer.domElement
              );
              orbitControls.enableDamping = true;
              orbitControls.dampingFactor = 0.05;
              orbitControls.target.set(0, 2, 0);

              orbitEnabled = true;
              this.textContent = "Disable OrbitControls";
              this.style.background = "#ef4444";

              console.log("OrbitControls enabled. Use mouse to rotate view.");
              alert(
                "OrbitControls enabled! Use mouse to rotate, scroll to zoom, right-click to pan."
              );
            };
            document.head.appendChild(script);
          } else {
            if (orbitControls) {
              orbitControls.dispose();
              orbitControls = null;
              orbitEnabled = false;
              this.textContent = "Enable OrbitControls";
              this.style.background = "#8b5cf6";
            }
          }
        });

      // Export Scene as JSON
      document
        .getElementById("export-scene-btn")
        .addEventListener("click", () => {
          try {
            const sceneJSON = scene.toJSON();
            const dataStr = JSON.stringify(sceneJSON, null, 2);
            const dataBlob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "museum-scene-" + Date.now() + ".json";
            link.click();
            URL.revokeObjectURL(url);
            alert("Scene exported successfully!");
          } catch (e) {
            alert("Error exporting scene: " + e.message);
            console.error(e);
          }
        });

      // Copy Scene JSON to clipboard
      document
        .getElementById("copy-scene-btn")
        .addEventListener("click", async () => {
          try {
            const sceneJSON = scene.toJSON();
            const dataStr = JSON.stringify(sceneJSON, null, 2);
            await navigator.clipboard.writeText(dataStr);
            alert("Scene JSON copied to clipboard!");
          } catch (e) {
            alert("Error copying scene: " + e.message);
            console.error(e);
          }
        });

      // Import Scene from JSON file
      document
        .getElementById("import-scene-btn")
        .addEventListener("click", () => {
          const fileInput = document.getElementById("import-scene-file");
          if (fileInput.files.length === 0) {
            alert("Please select a JSON file first");
            return;
          }

          const file = fileInput.files[0];
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const sceneData = JSON.parse(e.target.result);
              const loader = new THREE.ObjectLoader();
              const loadedScene = loader.parse(sceneData);

              // Clear current scene and load new one
              while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
              }

              loadedScene.children.forEach((child) => {
                scene.add(child);
              });

              alert("Scene imported successfully!");
            } catch (err) {
              alert("Error importing scene: " + err.message);
              console.error(err);
            }
          };

          reader.readAsText(file);
        });

      // Export as GLTF
      document
        .getElementById("export-gltf-btn")
        .addEventListener("click", () => {
          // Check if GLTFExporter is loaded
          if (typeof THREE.GLTFExporter === "undefined") {
            // Load GLTFExporter dynamically
            const script = document.createElement("script");
            script.src =
              "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js";
            script.onload = () => {
              exportGLTF();
            };
            document.head.appendChild(script);
          } else {
            exportGLTF();
          }
        });

      function exportGLTF() {
        const exporter = new THREE.GLTFExporter();
        exporter.parse(
          scene,
          function (gltf) {
            const dataStr = JSON.stringify(gltf, null, 2);
            const dataBlob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "museum-scene-" + Date.now() + ".gltf";
            link.click();
            URL.revokeObjectURL(url);
            alert("Scene exported as GLTF successfully!");
          },
          function (error) {
            alert("Error exporting GLTF: " + error.message);
            console.error(error);
          },
          { binary: false }
        );
      }

      console.log(
        '🛠️ Three.js Developer Tools loaded! Press "Shift+T" to toggle panel.'
      );

      // =================================================================
      // IN-GAME WORLD EDITOR - Visual Object Manipulation
      // =================================================================
      // NOTE: Old toggle-based editor code removed.
      // Editor now uses separate "Edit Tour" button with dedicated initialization.
      // See lines 628-814 for new editor implementation.

      // These variables are still needed by the editor UI handlers below
      let editorMode = false;
      let selectedObject = null;
      let transformControls = null;
      let editableObjects = []; // Objects that can be edited
      let objectHighlight = null; // Visual highlight for selected object

      console.log('📝 Note: Editor uses "Edit Tour" button (not toggle mode).');

      // Helper function: Select object (called by new editor click handler)
      function selectObject(obj) {
        if (!obj) return;

        selectedObject = obj;

        // Show selected object panel
        selectedObjectPanel.style.display = "block";
        document.getElementById("selected-object-name").textContent =
          obj.name || "Unnamed Object";

        // Attach transform controls
        if (transformControls) {
          transformControls.attach(obj);
        }

        // Update input fields
        updateObjectInputs();

        // Add highlight
        createHighlight(obj);

        console.log("✅ Selected:", obj.name || "Unnamed", obj);
      }

      function deselectObject() {
        selectedObject = null;
        selectedObjectPanel.style.display = "none";

        if (transformControls) {
          transformControls.detach();
        }

        removeHighlight();
      }

      function createHighlight(obj) {
        removeHighlight();

        // Create a bounding box helper
        const box = new THREE.BoxHelper(obj, 0x00ff00);
        objectHighlight = box;
        scene.add(box);
      }

      function removeHighlight() {
        if (objectHighlight) {
          scene.remove(objectHighlight);
          objectHighlight.dispose();
          objectHighlight = null;
        }
      }

      function updateObjectInputs() {
        if (!selectedObject) return;

        // Position
        document.getElementById("obj-pos-x").value =
          selectedObject.position.x.toFixed(2);
        document.getElementById("obj-pos-y").value =
          selectedObject.position.y.toFixed(2);
        document.getElementById("obj-pos-z").value =
          selectedObject.position.z.toFixed(2);

        // Rotation (convert to degrees)
        document.getElementById("obj-rot-x").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.x
        ).toFixed(0);
        document.getElementById("obj-rot-y").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.y
        ).toFixed(0);
        document.getElementById("obj-rot-z").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.z
        ).toFixed(0);

        // Scale
        document.getElementById("obj-scale-x").value =
          selectedObject.scale.x.toFixed(2);
        document.getElementById("obj-scale-y").value =
          selectedObject.scale.y.toFixed(2);
        document.getElementById("obj-scale-z").value =
          selectedObject.scale.z.toFixed(2);

        // Update highlight
        if (objectHighlight) {
          objectHighlight.update();
        }
      }

      // Transform mode buttons
      document.querySelectorAll(".transform-mode-btn").forEach((btn) => {
        btn.addEventListener("click", function () {
          const mode = this.dataset.mode;
          setTransformMode(mode);
        });
      });

      // Input field changes
      ["obj-pos-x", "obj-pos-y", "obj-pos-z"].forEach((id, index) => {
        document.getElementById(id).addEventListener("input", function () {
          if (selectedObject) {
            const axis = ["x", "y", "z"][index];
            selectedObject.position[axis] = parseFloat(this.value) || 0;
            if (objectHighlight) objectHighlight.update();
          }
        });
      });

      ["obj-rot-x", "obj-rot-y", "obj-rot-z"].forEach((id, index) => {
        document.getElementById(id).addEventListener("input", function () {
          if (selectedObject) {
            const axis = ["x", "y", "z"][index];
            selectedObject.rotation[axis] = THREE.MathUtils.degToRad(
              parseFloat(this.value) || 0
            );
            if (objectHighlight) objectHighlight.update();
          }
        });
      });

      const uniformScaleCheckbox = document.getElementById(
        "uniform-scale-checkbox"
      );
      ["obj-scale-x", "obj-scale-y", "obj-scale-z"].forEach((id, index) => {
        document.getElementById(id).addEventListener("input", function () {
          if (selectedObject) {
            const value = parseFloat(this.value) || 1;
            const axis = ["x", "y", "z"][index];

            if (uniformScaleCheckbox.checked) {
              // Uniform scaling
              selectedObject.scale.set(value, value, value);
              document.getElementById("obj-scale-x").value = value.toFixed(2);
              document.getElementById("obj-scale-y").value = value.toFixed(2);
              document.getElementById("obj-scale-z").value = value.toFixed(2);
            } else {
              selectedObject.scale[axis] = value;
            }
            if (objectHighlight) objectHighlight.update();
          }
        });
      });

      // Duplicate object
      document
        .getElementById("duplicate-object-btn")
        .addEventListener("click", () => {
          if (!selectedObject) {
            alert("Please select an object first");
            return;
          }

          const clone = selectedObject.clone();
          clone.position.x += 2; // Offset slightly
          scene.add(clone);
          selectObject(clone);

          console.log("✅ Object duplicated");
        });

      // Delete object
      document
        .getElementById("delete-object-btn")
        .addEventListener("click", () => {
          if (!selectedObject) {
            alert("Please select an object first");
            return;
          }

          if (confirm("Delete this object?")) {
            scene.remove(selectedObject);
            deselectObject();
            console.log("🗑️ Object deleted");
          }
        });

      // Add objects
      document.querySelectorAll(".add-object-btn").forEach((btn) => {
        btn.addEventListener("click", function () {
          const type = this.dataset.type;
          let newObject;

          switch (type) {
            case "cube":
              newObject = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ color: 0x00ff00 })
              );
              newObject.name = "Cube";
              break;
            case "sphere":
              newObject = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({ color: 0x0000ff })
              );
              newObject.name = "Sphere";
              break;
            case "cylinder":
              newObject = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
              );
              newObject.name = "Cylinder";
              break;
            case "plane":
              newObject = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 5),
                new THREE.MeshStandardMaterial({
                  color: 0xcccccc,
                  side: THREE.DoubleSide,
                })
              );
              newObject.rotation.x = -Math.PI / 2;
              newObject.name = "Plane";
              break;
            case "light":
              newObject = new THREE.PointLight(0xffffff, 1, 100);
              newObject.name = "Point Light";
              break;
          }

          if (newObject) {
            // Place in front of camera
            newObject.position.copy(camera.position);
            newObject.position.add(
              camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5)
            );

            scene.add(newObject);
            selectObject(newObject);

            console.log(`✅ Added ${type}`);
          }
        });
      });

      // Load model button
      document
        .getElementById("load-model-btn")
        .addEventListener("click", () => {
          document.getElementById("model-file-input").click();
        });

      document
        .getElementById("model-file-input")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (event) {
            const loader = new THREE.GLTFLoader();
            loader.parse(
              event.target.result,
              "",
              (gltf) => {
                const model = gltf.scene;
                model.position.copy(camera.position);
                model.position.add(
                  camera
                    .getWorldDirection(new THREE.Vector3())
                    .multiplyScalar(5)
                );
                model.name = file.name.replace(".glb", "").replace(".gltf", "");

                // Mark as GLB model (loaded from file, no URL to save)
                model.userData.isGLBModel = true;
                model.userData.glbSourceFile = file.name;
                model.userData.glbSourceURL = null; // No URL for file uploads

                // Enable shadows
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });

                scene.add(model);

                // Add collisions automatically for the loaded model
                console.log("🔲 Adding collisions for:", file.name);
                addCollidersForModel(model);
                if (useBVHCollision) {
                  // Add to triangle collision system
                  model.traverse((child) => {
                    if (child && child.isMesh && child.geometry) {
                      bvhColliders.push({
                        mesh: child,
                        raycaster: new THREE.Raycaster()
                      });
                    }
                  });
                }

                selectObject(model);

                console.log("✅ Model loaded:", file.name);
              },
              (error) => {
                console.error("Error loading model:", error);
                alert("Error loading model: " + error.message);
              }
            );
          };
          reader.readAsArrayBuffer(file);
        });

      // ==================== GLB LIBRARY SYSTEM ====================

      // GLB Library Data Structure
      // Store library in localStorage for persistence
      let glbLibrary = [];

      // Load library from localStorage
      function loadGLBLibrary() {
        try {
          const saved = localStorage.getItem('glbLibrary');
          if (saved) {
            glbLibrary = JSON.parse(saved);
            console.log('📚 Loaded GLB library:', glbLibrary.length, 'models');
          }
        } catch (e) {
          console.error('Error loading GLB library:', e);
          glbLibrary = [];
        }
        updateLibraryUI();
      }

      // Save library to localStorage
      function saveGLBLibrary() {
        try {
          localStorage.setItem('glbLibrary', JSON.stringify(glbLibrary));
          console.log('💾 Saved GLB library');
        } catch (e) {
          console.error('Error saving GLB library:', e);
        }
      }

      // Add model to library
      function addToLibrary(name, path) {
        const existingIndex = glbLibrary.findIndex(item => item.name === name);
        if (existingIndex >= 0) {
          // Update existing entry
          glbLibrary[existingIndex].path = path;
        } else {
          // Add new entry
          glbLibrary.push({ name, path });
        }
        saveGLBLibrary();
        updateLibraryUI();
      }

      // Remove model from library
      function removeFromLibrary(name) {
        glbLibrary = glbLibrary.filter(item => item.name !== name);
        saveGLBLibrary();
        updateLibraryUI();
      }

      // Update the library UI
      function updateLibraryUI() {
        const container = document.getElementById('glb-library-container');
        const emptyMsg = document.getElementById('glb-library-empty');

        if (!container) return;

        container.innerHTML = '';

        if (glbLibrary.length === 0) {
          if (emptyMsg) emptyMsg.style.display = 'block';
          return;
        }

        if (emptyMsg) emptyMsg.style.display = 'none';

        glbLibrary.forEach(item => {
          const btn = document.createElement('button');
          btn.className = 'glb-library-item';
          btn.style.cssText = `
            background: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(167, 139, 250, 0.4);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          `;
          btn.textContent = item.name;
          btn.title = `Click to add: ${item.name}\nPath: ${item.path}`;

          // Hover effect
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'rgba(167, 139, 250, 0.3)';
            btn.style.transform = 'scale(1.05)';
          });
          btn.addEventListener('mouseleave', () => {
            btn.style.background = 'rgba(167, 139, 250, 0.2)';
            btn.style.transform = 'scale(1)';
          });

          // Click to load model
          btn.addEventListener('click', () => {
            loadGLBFromPath(item.path, item.name);
          });

          container.appendChild(btn);
        });
      }

      // Load GLB from path/URL
      function loadGLBFromPath(path, modelName) {
        console.log('📦 Loading GLB from path:', path);

        const loader = new THREE.GLTFLoader();

        // Show loading indicator
        const container = document.getElementById('glb-library-container');
        const loadingDiv = document.createElement('div');
        loadingDiv.style.cssText = 'grid-column: 1 / -1; text-align: center; color: #a78bfa; font-size: 11px; padding: 8px;';
        loadingDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading ' + modelName + '...';
        container.appendChild(loadingDiv);

        loader.load(
          path,
          (gltf) => {
            const model = gltf.scene;

            // Position model in front of camera
            if (camera) {
              model.position.copy(camera.position);
              model.position.add(
                camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5)
              );
            }

            model.name = modelName;

            // IMPORTANT: Store the source URL so we can save/load it later
            model.userData.glbSourceURL = path;
            model.userData.isGLBModel = true;

            // Enable shadows
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            scene.add(model);

            // Add collisions automatically for the loaded model
            console.log('🔲 Adding collisions for:', modelName);
            addCollidersForModel(model);
            if (useBVHCollision) {
              // Add to triangle collision system
              model.traverse((child) => {
                if (child && child.isMesh && child.geometry) {
                  bvhColliders.push({
                    mesh: child,
                    raycaster: new THREE.Raycaster()
                  });
                }
              });
            }

            selectObject(model);

            // Remove loading indicator
            if (loadingDiv.parentNode) {
              loadingDiv.parentNode.removeChild(loadingDiv);
            }

            console.log('✅ GLB loaded from library:', modelName);
          },
          (progress) => {
            // Optional: Update progress
            const percent = (progress.loaded / progress.total * 100).toFixed(0);
            loadingDiv.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Loading ${modelName}... ${percent}%`;
          },
          (error) => {
            console.error('❌ Error loading GLB:', error);
            alert('Error loading model "' + modelName + '": ' + error.message);

            // Remove loading indicator
            if (loadingDiv.parentNode) {
              loadingDiv.parentNode.removeChild(loadingDiv);
            }
          }
        );
      }

      // Sync from Supabase Storage - automatically populate library from bucket
      async function syncFromSupabase() {
        console.log('🔄 Syncing GLB library from Supabase...');

        // Known models in your Supabase bucket
        // Update this list when you add new models to Supabase
        const knownModels = [
          'old_desk_scene.glb',
          'ArizonaStateCapitolModelV1.glb'
          // Add more model filenames here as you upload them
        ];

        try {
          // Test which models actually exist in the bucket
          console.log(`🔍 Testing ${knownModels.length} known models...`);

          const results = await Promise.all(
            knownModels.map(async (filename) => {
              const testUrl = `${SUPABASE_CONFIG.url}/storage/v1/object/public/${SUPABASE_CONFIG.publicPath}/${filename}`;

              try {
                // Use HEAD request to check if file exists without downloading it
                const response = await fetch(testUrl, { method: 'HEAD' });

                if (response.ok) {
                  console.log(`✅ Found: ${filename}`);
                  return { name: filename, exists: true, url: testUrl };
                } else {
                  console.log(`❌ Not found: ${filename} (${response.status})`);
                  return { name: filename, exists: false, url: null };
                }
              } catch (error) {
                console.log(`❌ Error checking ${filename}:`, error.message);
                return { name: filename, exists: false, url: null };
              }
            })
          );

          // Filter to only existing models
          const existingModels = results.filter(r => r.exists);
          console.log(`📦 Found ${existingModels.length} existing models`);

          if (existingModels.length === 0) {
            alert('⚠️  No models found!\n\n' +
              'Models checked:\n' + knownModels.join('\n') + '\n\n' +
              'Make sure these files exist in your Supabase storage:\n' +
              `${SUPABASE_CONFIG.url}/storage/v1/object/public/${SUPABASE_CONFIG.publicPath}/`);
            return;
          }

          // Add each model to the library
          let addedCount = 0;
          let skippedCount = 0;

          existingModels.forEach(model => {
            // Extract clean model name from filename
            let modelName = model.name.replace('.glb', '').replace('.gltf', '');

            // Clean up the name (remove path, underscores, etc.)
            modelName = modelName.split('/').pop(); // Remove folder path
            modelName = modelName.replace(/_/g, ' '); // Replace underscores with spaces
            modelName = modelName.replace(/([A-Z])/g, ' $1').trim(); // Add spaces before capital letters
            modelName = modelName.charAt(0).toUpperCase() + modelName.slice(1); // Capitalize first letter

            // Check if already in library
            const existingIndex = glbLibrary.findIndex(item => item.path === model.url);

            if (existingIndex >= 0) {
              skippedCount++;
              console.log(`⏭️  Skipped (already in library): ${modelName}`);
            } else {
              addToLibrary(modelName, model.url);
              addedCount++;
              console.log(`✅ Added to library: ${modelName}`);
            }
          });

          const message = `🔄 Supabase Sync Complete!\n\n` +
            `✅ Added: ${addedCount} models\n` +
            `⏭️  Skipped: ${skippedCount} (already in library)\n` +
            `📚 Total in library: ${glbLibrary.length}\n\n` +
            `ℹ️  Models checked:\n${knownModels.join('\n')}\n\n` +
            `To add more models:\n` +
            `1. Open Museum-tour.html\n` +
            `2. Find line 6045 (knownModels array)\n` +
            `3. Add your model filenames`;

          alert(message);
          console.log(message);

        } catch (error) {
          console.error('❌ Error syncing from Supabase:', error);
          alert(`Error syncing from Supabase:\n\n${error.message}\n\nCheck console for details.`);
        }
      }

      // Sync button click handler with option to add custom models
      document.getElementById('sync-supabase-btn').addEventListener('click', () => {
        const choice = prompt(
          '🔄 Supabase Sync Options:\n\n' +
          '1. Quick sync known models (enter: sync)\n' +
          '2. Add custom models by URL (enter: custom)\n' +
          '3. Bulk add filenames (enter: bulk)\n' +
          '4. Cancel (leave blank)',
          'sync'
        );

        if (!choice) return;

        if (choice.toLowerCase() === 'sync') {
          syncFromSupabase();
        }
        else if (choice.toLowerCase() === 'custom') {
          const url = prompt('Enter full Supabase model URL:\n\nExample:\nhttps://flqsdjtfkgycvssdbegd.supabase.co/storage/v1/object/public/models/your_model.glb');
          if (!url) return;

          // Extract model name from URL
          const filename = url.split('/').pop();
          const modelName = filename.replace('.glb', '').replace('.gltf', '').replace(/_/g, ' ');
          const cleanName = modelName.charAt(0).toUpperCase() + modelName.slice(1);

          addToLibrary(cleanName, url);
          alert(`✅ Added to library: ${cleanName}`);
        }
        else if (choice.toLowerCase() === 'bulk') {
          const filenames = prompt(
            'Enter model filenames (one per line):\n\n' +
            'Example:\n' +
            'old_desk_scene.glb\n' +
            'model2.glb\n' +
            'model3.glb'
          );

          if (!filenames) return;

          const files = filenames.split('\n').map(f => f.trim()).filter(f => f.length > 0);
          let added = 0;

          files.forEach(filename => {
            const url = `${SUPABASE_CONFIG.url}/storage/v1/object/public/${SUPABASE_CONFIG.publicPath}/${filename}`;
            const modelName = filename.replace('.glb', '').replace('.gltf', '').replace(/_/g, ' ');
            const cleanName = modelName.charAt(0).toUpperCase() + modelName.slice(1);

            addToLibrary(cleanName, url);
            added++;
          });

          alert(`✅ Added ${added} models to library!`);
        }
      });

      // Manage Library button - opens a prompt dialog
      document.getElementById('manage-library-btn').addEventListener('click', () => {
        const action = prompt(
          '📚 GLB Library Manager\n\n' +
          'Current models: ' + glbLibrary.length + '\n\n' +
          'Choose action:\n' +
          '1. Add new model (enter: add)\n' +
          '2. Remove model (enter: remove)\n' +
          '3. List all models (enter: list)\n' +
          '4. Cancel (leave blank)',
          ''
        );

        if (!action) return;

        if (action.toLowerCase() === 'add') {
          const name = prompt('Enter model name (display name):');
          if (!name) return;

          const path = prompt(
            'Enter model path or URL:\n\n' +
            'Examples:\n' +
            '• Relative path: ./models/statue.glb\n' +
            '• Absolute path: C:/Users/You/models/vase.glb\n' +
            '• URL: https://example.com/model.glb'
          );
          if (!path) return;

          addToLibrary(name, path);
          alert('✅ Added "' + name + '" to library!');
        }
        else if (action.toLowerCase() === 'remove') {
          if (glbLibrary.length === 0) {
            alert('Library is empty!');
            return;
          }

          const list = glbLibrary.map((item, i) => `${i + 1}. ${item.name}`).join('\n');
          const name = prompt('Models in library:\n\n' + list + '\n\nEnter the exact name to remove:');
          if (!name) return;

          const exists = glbLibrary.find(item => item.name === name);
          if (!exists) {
            alert('Model "' + name + '" not found!');
            return;
          }

          if (confirm('Remove "' + name + '" from library?')) {
            removeFromLibrary(name);
            alert('✅ Removed "' + name + '" from library!');
          }
        }
        else if (action.toLowerCase() === 'list') {
          if (glbLibrary.length === 0) {
            alert('Library is empty!');
            return;
          }

          const list = glbLibrary.map((item, i) =>
            `${i + 1}. ${item.name}\n   Path: ${item.path}`
          ).join('\n\n');
          alert('📚 GLB Library:\n\n' + list);
        }
        else {
          alert('Invalid action. Enter "add", "remove", or "list".');
        }
      });

      // Initialize library on load
      loadGLBLibrary();

      // ==================== END GLB LIBRARY SYSTEM ====================

      // Save World Configuration
      // This exports all object positions, rotations, and scales to a JSON file
      // You can then use this file to restore object positions in your code
      function saveWorldConfiguration() {
        console.log("🔧 Save World Configuration called");

        // Add visual feedback to the button
        const saveBtn1 = document.getElementById("save-world-btn");
        const saveBtn2 = document.getElementById("save-world-btn-main");
        const originalText1 = saveBtn1 ? saveBtn1.innerHTML : '';
        const originalText2 = saveBtn2 ? saveBtn2.innerHTML : '';

        console.log("🔧 Buttons found:", {saveBtn1: !!saveBtn1, saveBtn2: !!saveBtn2});

        // Show saving state
        if (saveBtn1) {
          saveBtn1.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
          saveBtn1.disabled = true;
        }
        if (saveBtn2) {
          saveBtn2.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
          saveBtn2.disabled = true;
        }

        // Wrap everything in try-catch
        try {
          // Small delay to show the loading animation
          setTimeout(() => {
            try {
          const worldData = {
              version: "1.0",
              timestamp: Date.now(),
              dateString: new Date().toISOString(),
              description: "Museum Tour - Object Positions Configuration",
              objects: [],
              spawnPoint: {
                position: {
                  x: parseFloat(spawnPoint.position.x.toFixed(3)),
                  y: parseFloat(spawnPoint.position.y.toFixed(3)),
                  z: parseFloat(spawnPoint.position.z.toFixed(3)),
                },
                rotation: {
                  y: parseFloat(spawnPoint.rotation.y.toFixed(1))
                }
              }
            };

            // Scan through scene and save all movable objects
            scene.children.forEach((child) => {
              // Skip unnamed objects - these are typically static scene elements
              // (floors, walls, etc. that don't need to be saved)
              if (!child.name || child.name === "Unnamed") {
                return;
              }

              // Only save actual objects (skip camera, lights, helpers, controls)
              if (
                child.type === "Mesh" ||
                child.type === "Group" ||
                (child.type === "Object3D" && child.children.length > 0)
              ) {
                // Save LOCAL transforms (relative to parent, not world transforms)
                // This preserves the correct position for objects with parent transforms
                const objData = {
                  name: child.name || "Unnamed",
                  type: child.type,
                  position: {
                    x: parseFloat(child.position.x.toFixed(3)),
                    y: parseFloat(child.position.y.toFixed(3)),
                    z: parseFloat(child.position.z.toFixed(3)),
                  },
                  rotation: {
                    x: parseFloat(child.rotation.x.toFixed(3)),
                    y: parseFloat(child.rotation.y.toFixed(3)),
                    z: parseFloat(child.rotation.z.toFixed(3)),
                  },
                  scale: {
                    x: parseFloat(child.scale.x.toFixed(3)),
                    y: parseFloat(child.scale.y.toFixed(3)),
                    z: parseFloat(child.scale.z.toFixed(3)),
                  },
                };

                // If this is a GLB model, save its source URL
                if (child.userData.isGLBModel && child.userData.glbSourceURL) {
                  objData.glbSourceURL = child.userData.glbSourceURL;
                  objData.isGLBModel = true;
                  console.log(`📦 Saving GLB model: ${child.name} from ${child.userData.glbSourceURL}`);
                }

                // Log museum object for debugging
                if (child.name === "museum") {
                  console.log(`🏛️ Saving museum position:`, objData);
                  console.log(`🏛️ Museum actual transform:`, {
                    position: child.position.toArray(),
                    rotation: child.rotation.toArray(),
                    scale: child.scale.toArray(),
                    worldPosition: child.getWorldPosition(new THREE.Vector3()).toArray(),
                    parent: child.parent ? child.parent.type : 'none'
                  });

                  // Safety check - warn if museum position seems wrong
                  const expectedPos = {x: 0, y: 1, z: 65};
                  const expectedScale = {x: 1, y: 1, z: 1};
                  const posDiff = Math.sqrt(
                    Math.pow(child.position.x - expectedPos.x, 2) +
                    Math.pow(child.position.y - expectedPos.y, 2) +
                    Math.pow(child.position.z - expectedPos.z, 2)
                  );
                  const scaleDiff = Math.abs(child.scale.x - expectedScale.x) +
                                    Math.abs(child.scale.y - expectedScale.y) +
                                    Math.abs(child.scale.z - expectedScale.z);

                  if (posDiff > 30) {
                    console.error(`❌ ERROR: Museum position is ${posDiff.toFixed(1)} units away from expected (0, 1, 65)!`);
                    console.error(`   Current: (${child.position.x.toFixed(1)}, ${child.position.y.toFixed(1)}, ${child.position.z.toFixed(1)})`);
                    alert(`WARNING: Museum position seems wrong!\n\nExpected around (0, 1, 65)\nCurrent: (${child.position.x.toFixed(1)}, ${child.position.y.toFixed(1)}, ${child.position.z.toFixed(1)})\n\nThis will be saved. Are you sure this is correct?`);
                  }

                  if (scaleDiff > 1) {
                    console.error(`❌ ERROR: Museum scale is not (1, 1, 1)! Current: (${child.scale.x}, ${child.scale.y}, ${child.scale.z})`);
                    alert(`WARNING: Museum scale seems wrong!\n\nExpected: (1, 1, 1)\nCurrent: (${child.scale.x}, ${child.scale.y}, ${child.scale.z})\n\nThis will make the museum ${child.scale.x}x bigger! Are you sure this is correct?`);
                  }
                }

                worldData.objects.push(objData);
              }
            });

            // Generate JavaScript file content
            const glbModelCount = worldData.objects.filter(obj => obj.isGLBModel && obj.glbSourceURL).length;
            console.log(`💾 Saved ${worldData.objects.length} named objects (${glbModelCount} GLB models with URLs)`);

            const jsContent = `// Museum Tour - World Configuration
// This file stores the positions, rotations, and scales of NAMED objects in your museum world
// It also stores GLB model source URLs so models can be loaded automatically
// Unnamed objects (static scene elements) are not saved to keep the file small
//
// HOW TO USE:
// 1. Enter "Edit Tour" mode in your museum app
// 2. Add models from the GLB Library (they'll store their Supabase URLs)
// 3. Move, rotate, and scale objects to your desired positions
// 4. Click "Save World" button - a file will be downloaded
// 5. REPLACE this museum-world-config.js file with the downloaded version
// 6. Refresh the page - your GLB models will load automatically from Supabase!
//
// NEW: GLB models with URLs will be automatically loaded on page startup
//
// Objects saved: ${worldData.objects.length} (${glbModelCount} GLB models with URLs)
// Last updated: ${worldData.dateString}

// Configuration object that will be loaded by the museum tour HTML
const MUSEUM_WORLD_CONFIG = ${JSON.stringify(worldData, null, 2)};

// Make config available globally
if (typeof window !== 'undefined') {
  window.MUSEUM_WORLD_CONFIG = MUSEUM_WORLD_CONFIG;
}
`;

            // Try to copy to clipboard first
            try {
              navigator.clipboard.writeText(jsContent).then(() => {
                console.log("💾 World configuration copied to clipboard!");
                console.log("📋 Now paste it into museum-world-config.js file");

                // Show success message with instructions
                const glbCount = worldData.objects.filter(obj => obj.isGLBModel && obj.glbSourceURL).length;
                let message = `✅ Saved ${worldData.objects.length} objects (${glbCount} GLB models)!\n\n`;
                message += `📋 Config copied to clipboard!\n\n`;
                message += `To apply:\n`;
                message += `1. Open museum-world-config.js\n`;
                message += `2. Press Ctrl+A (select all)\n`;
                message += `3. Press Ctrl+V (paste)\n`;
                message += `4. Save and refresh page`;

                alert(message);
                showTemporaryMessage(`✅ Copied to clipboard! Paste into museum-world-config.js`);

                // Restore button state
                setTimeout(() => {
                  if (saveBtn1) {
                    saveBtn1.innerHTML = originalText1;
                    saveBtn1.disabled = false;
                  }
                  if (saveBtn2) {
                    saveBtn2.innerHTML = originalText2;
                    saveBtn2.disabled = false;
                  }
                }, 500);
              }).catch((clipboardError) => {
                // Clipboard failed, fall back to download
                console.warn("Clipboard failed, downloading file instead:", clipboardError);
                downloadConfigFile();
              });
            } catch (clipboardError) {
              // Clipboard not supported, fall back to download
              console.warn("Clipboard not supported, downloading file instead:", clipboardError);
              downloadConfigFile();
            }

            // Helper function to download file
            function downloadConfigFile() {
              const dataBlob = new Blob([jsContent], { type: "text/javascript" });
              const url = URL.createObjectURL(dataBlob);
              const link = document.createElement("a");
              link.href = url;
              link.download = "museum-world-config.js";
              link.click();
              URL.revokeObjectURL(url);

              console.log(
                "💾 World configuration saved!",
                worldData.objects.length,
                "objects"
              );
              console.log("📄 File saved as: museum-world-config.js");
              console.log(
                "💡 Replace the existing museum-world-config.js file and refresh"
              );

              // Restore button state
              setTimeout(() => {
                if (saveBtn1) {
                  saveBtn1.innerHTML = originalText1;
                  saveBtn1.disabled = false;
                }
                if (saveBtn2) {
                  saveBtn2.innerHTML = originalText2;
                  saveBtn2.disabled = false;
                }
              }, 500);

              showTemporaryMessage(
                `✅ Saved ${worldData.objects.length} objects!\n\nDownloaded: museum-world-config.js\n\nReplace existing file and refresh`
              );
            }
            } catch (innerError) {
              console.error("❌ Error during save:", innerError);
              alert("Error saving world: " + innerError.message);

              // Restore button state on error
              if (saveBtn1) {
                saveBtn1.innerHTML = originalText1;
                saveBtn1.disabled = false;
              }
              if (saveBtn2) {
                saveBtn2.innerHTML = originalText2;
                saveBtn2.disabled = false;
              }
            }
          }, 200);
        } catch (outerError) {
          console.error("❌ Critical error in save function:", outerError);
          alert("Critical error: " + outerError.message);

          // Restore button state on error
          if (saveBtn1) {
            saveBtn1.innerHTML = originalText1;
            saveBtn1.disabled = false;
          }
          if (saveBtn2) {
            saveBtn2.innerHTML = originalText2;
            saveBtn2.disabled = false;
          }
        }
      }

      // Wire up both Save World buttons to the same function
      document.getElementById("save-world-btn").addEventListener("click", saveWorldConfiguration);
      document.getElementById("save-world-btn-main").addEventListener("click", saveWorldConfiguration);

      // Apply Saved World Configuration
      // This function loads positions from the museum-world-config.js file and applies them to objects
      // NEW: Also loads GLB models from URLs if they're in the config
      function applySavedWorldConfig() {
        // Check if config is available
        if (typeof window.MUSEUM_WORLD_CONFIG === 'undefined' || !window.MUSEUM_WORLD_CONFIG) {
          console.log("📄 No saved world configuration found - using default positions");
          return;
        }

        const config = window.MUSEUM_WORLD_CONFIG;

        // Check if config has objects
        if (!config.objects || config.objects.length === 0) {
          console.log("📄 World configuration is empty - using default positions");
          return;
        }

        console.log(`📂 Loading world configuration from ${config.dateString || 'unknown date'}`);
        console.log(`   Found ${config.objects.length} saved object positions`);

        // Load spawn point if present in config
        if (config.spawnPoint) {
          console.log(`🎯 Found spawn point in config!`);
          spawnPoint.position.x = config.spawnPoint.position.x;
          spawnPoint.position.y = config.spawnPoint.position.y;
          spawnPoint.position.z = config.spawnPoint.position.z;
          spawnPoint.rotation.y = config.spawnPoint.rotation.y;

          // Update camera to spawn point position (for initial load)
          if (camera) {
            camera.position.set(
              spawnPoint.position.x,
              spawnPoint.position.y,
              spawnPoint.position.z
            );

            // Set camera rotation
            if (typeof euler !== "undefined") {
              // Reset all euler angles to ensure clean rotation
              euler.x = 0; // No pitch (looking straight ahead)
              euler.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y); // Yaw rotation
              euler.z = 0; // No roll
              camera.quaternion.setFromEuler(euler);
            }
          }

          // Update UI inputs
          document.getElementById("spawn-pos-x").value = spawnPoint.position.x;
          document.getElementById("spawn-pos-y").value = spawnPoint.position.y;
          document.getElementById("spawn-pos-z").value = spawnPoint.position.z;
          document.getElementById("spawn-rot-y").value = spawnPoint.rotation.y;

          // Update spawn marker if it exists
          if (spawnPointMarker) {
            spawnPointMarker.position.set(
              spawnPoint.position.x,
              spawnPoint.position.y,
              spawnPoint.position.z
            );
            const arrow = spawnPointMarker.children.find(child => child.type === "ArrowHelper");
            if (arrow) {
              arrow.rotation.y = THREE.MathUtils.degToRad(spawnPoint.rotation.y);
            }
          }

          console.log(`🎯 Loaded spawn point from config:`, spawnPoint);
          console.log(`📷 Camera positioned at spawn point`);
        } else {
          console.log(`⚠️ No spawn point in config - using default spawn point`);
          console.log(`   To save spawn point: Enter edit mode, adjust spawn point, and click "Save World"`);
        }

        let appliedCount = 0;
        let notFoundCount = 0;
        let glbModelsToLoad = 0;

        // Apply positions to each object
        config.objects.forEach((objData) => {
          // Check if this is a GLB model that needs to be loaded
          if (objData.isGLBModel && objData.glbSourceURL) {
            glbModelsToLoad++;
            console.log(`   📦 Loading GLB model from config: ${objData.name}`);
            console.log(`      URL: ${objData.glbSourceURL}`);

            // Load the GLB model
            const loader = new THREE.GLTFLoader();
            loader.load(
              objData.glbSourceURL,
              (gltf) => {
                const model = gltf.scene;
                model.name = objData.name;

                // Apply saved transforms
                model.position.set(
                  objData.position.x,
                  objData.position.y,
                  objData.position.z
                );
                model.rotation.set(
                  objData.rotation.x,
                  objData.rotation.y,
                  objData.rotation.z
                );
                model.scale.set(
                  objData.scale.x,
                  objData.scale.y,
                  objData.scale.z
                );

                // Store metadata
                model.userData.isGLBModel = true;
                model.userData.glbSourceURL = objData.glbSourceURL;

                // Enable shadows
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });

                scene.add(model);

                // Add collisions automatically for the loaded model
                console.log(`   🔲 Adding collisions for: ${objData.name}`);
                addCollidersForModel(model);
                if (useBVHCollision) {
                  // Add to triangle collision system
                  model.traverse((child) => {
                    if (child && child.isMesh && child.geometry) {
                      bvhColliders.push({
                        mesh: child,
                        raycaster: new THREE.Raycaster()
                      });
                    }
                  });
                }

                console.log(`   ✅ GLB model loaded from config: ${objData.name}`);
              },
              (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                console.log(`      Loading ${objData.name}... ${percent}%`);
              },
              (error) => {
                console.error(`   ❌ Error loading GLB model ${objData.name}:`, error);
                console.error(`      URL: ${objData.glbSourceURL}`);
              }
            );
          } else {
            // This is an existing object in the scene, just update its transform
            const obj = scene.getObjectByName(objData.name);

            if (obj) {
              // Apply saved position, rotation, and scale
              obj.position.set(
                objData.position.x,
                objData.position.y,
                objData.position.z
              );
              obj.rotation.set(
                objData.rotation.x,
                objData.rotation.y,
                objData.rotation.z
              );
              obj.scale.set(
                objData.scale.x,
                objData.scale.y,
                objData.scale.z
              );

              appliedCount++;
              console.log(`   ✅ Applied saved position to: ${objData.name}`);
            } else {
              notFoundCount++;
              console.log(`   ⚠️  Object not found in scene: ${objData.name}`);
            }
          }
        });

        console.log(`📂 World configuration loaded:`);
        console.log(`   - ${appliedCount} existing objects updated`);
        if (glbModelsToLoad > 0) {
          console.log(`   - ${glbModelsToLoad} GLB models loading from URLs...`);
        }
        if (notFoundCount > 0) {
          console.log(`   - ${notFoundCount} objects not found`);
        }

        if (appliedCount > 0 || glbModelsToLoad > 0) {
          let msg = `✅ Config loaded: ${appliedCount} updated`;
          if (glbModelsToLoad > 0) {
            msg += `, ${glbModelsToLoad} models loading`;
          }
          showTemporaryMessage(msg);
        }
      }

      // Load World Configuration
      document
        .getElementById("load-world-btn")
        .addEventListener("click", () => {
          document.getElementById("world-file-input").click();
        });

      document
        .getElementById("world-file-input")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              let worldData;
              const fileContent = event.target.result;

              // Try to parse as JavaScript file first (the format we save)
              if (file.name.endsWith('.js')) {
                // Extract the JSON object from the JavaScript file
                const jsonMatch = fileContent.match(/const MUSEUM_WORLD_CONFIG = ({[\s\S]*?});/);
                if (jsonMatch) {
                  worldData = JSON.parse(jsonMatch[1]);
                } else {
                  throw new Error("Could not find MUSEUM_WORLD_CONFIG in .js file");
                }
              } else {
                // Parse as plain JSON
                worldData = JSON.parse(fileContent);
              }

              if (!worldData || !worldData.objects) {
                throw new Error("Invalid world configuration format");
              }

              // Count how many GLB models need to be loaded
              const glbModelsToLoad = worldData.objects.filter(obj => obj.isGLBModel && obj.glbSourceURL).length;
              const existingObjects = worldData.objects.filter(obj => !obj.isGLBModel || !obj.glbSourceURL).length;

              let confirmMsg = `Load world configuration with ${worldData.objects.length} objects?\n\n`;
              if (glbModelsToLoad > 0) {
                confirmMsg += `- ${glbModelsToLoad} GLB models will be loaded from URLs\n`;
              }
              if (existingObjects > 0) {
                confirmMsg += `- ${existingObjects} existing objects will be repositioned\n`;
              }
              confirmMsg += `\nLast saved: ${worldData.dateString || 'Unknown'}`;

              if (confirm(confirmMsg)) {
                let updatedCount = 0;
                let notFoundCount = 0;
                let loadedGLBCount = 0;

                // Process each object in the config
                worldData.objects.forEach((objData) => {
                  // Check if this is a GLB model that needs to be loaded
                  if (objData.isGLBModel && objData.glbSourceURL) {
                    console.log(`📦 Loading GLB model from config: ${objData.name}`);

                    // Load the GLB model
                    const loader = new THREE.GLTFLoader();
                    loader.load(
                      objData.glbSourceURL,
                      (gltf) => {
                        const model = gltf.scene;
                        model.name = objData.name;

                        // Apply saved transforms
                        model.position.set(
                          objData.position.x,
                          objData.position.y,
                          objData.position.z
                        );
                        model.rotation.set(
                          objData.rotation.x,
                          objData.rotation.y,
                          objData.rotation.z
                        );
                        model.scale.set(
                          objData.scale.x,
                          objData.scale.y,
                          objData.scale.z
                        );

                        // Store metadata
                        model.userData.isGLBModel = true;
                        model.userData.glbSourceURL = objData.glbSourceURL;

                        // Enable shadows
                        model.traverse((child) => {
                          if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                          }
                        });

                        scene.add(model);

                        // Add collisions automatically for the loaded model
                        console.log(`🔲 Adding collisions for: ${objData.name}`);
                        addCollidersForModel(model);
                        if (useBVHCollision) {
                          // Add to triangle collision system
                          model.traverse((child) => {
                            if (child && child.isMesh && child.geometry) {
                              bvhColliders.push({
                                mesh: child,
                                raycaster: new THREE.Raycaster()
                              });
                            }
                          });
                        }

                        loadedGLBCount++;

                        console.log(`✅ GLB model loaded and positioned: ${objData.name}`);
                        showTemporaryMessage(`✅ Loaded ${objData.name}`);
                      },
                      (progress) => {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        console.log(`Loading ${objData.name}... ${percent}%`);
                      },
                      (error) => {
                        console.error(`❌ Error loading GLB model ${objData.name}:`, error);
                        alert(`Error loading model "${objData.name}" from:\n${objData.glbSourceURL}\n\nError: ${error.message}`);
                      }
                    );
                  } else {
                    // This is an existing object in the scene, just update its transform
                    const existingObj = scene.getObjectByName(objData.name);

                    if (existingObj) {
                      // Log before update for debugging
                      if (objData.name === "museum") {
                        console.log(`🏛️ Museum BEFORE load:`, {
                          position: existingObj.position.toArray(),
                          rotation: existingObj.rotation.toArray(),
                          scale: existingObj.scale.toArray()
                        });
                        console.log(`🏛️ Museum saved data:`, objData);
                      }

                      // Update existing object
                      existingObj.position.set(
                        objData.position.x,
                        objData.position.y,
                        objData.position.z
                      );
                      existingObj.rotation.set(
                        objData.rotation.x,
                        objData.rotation.y,
                        objData.rotation.z
                      );
                      existingObj.scale.set(
                        objData.scale.x,
                        objData.scale.y,
                        objData.scale.z
                      );

                      // Log after update for debugging
                      if (objData.name === "museum") {
                        console.log(`🏛️ Museum AFTER load:`, {
                          position: existingObj.position.toArray(),
                          rotation: existingObj.rotation.toArray(),
                          scale: existingObj.scale.toArray()
                        });
                      }

                      updatedCount++;
                    } else {
                      notFoundCount++;
                      console.warn(`⚠️ Object not found in scene: ${objData.name}`);
                    }
                  }
                });

                console.log(`📂 World configuration loaded!`);
                console.log(`   Updated: ${updatedCount} existing objects`);
                if (glbModelsToLoad > 0) {
                  console.log(`   Loading: ${glbModelsToLoad} GLB models...`);
                }
                if (notFoundCount > 0) {
                  console.warn(`   Not found: ${notFoundCount} objects`);
                }

                showTemporaryMessage(
                  `✅ Loading world config...\n${updatedCount} updated, ${glbModelsToLoad} models loading`
                );
              }
            } catch (error) {
              console.error("Error loading world:", error);
              alert("Error loading world configuration: " + error.message);
            }
          };
          reader.readAsText(file);
        });

      console.log("🎨 In-Game World Editor initialized!");
    </script>
  </body>
</html>
