<!-- htmlhint no-inline-style:false -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Professional World Builder</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        overflow: hidden;
        background: #1a1a1a;
        color: #e0e0e0;
      }

      #canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      /* Top Toolbar */
      .top-toolbar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 50px;
        background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
        border-bottom: 1px solid #404040;
        display: flex;
        align-items: center;
        padding: 0 15px;
        gap: 20px;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .toolbar-section {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .toolbar-divider {
        width: 1px;
        height: 30px;
        background: #404040;
      }

      .toolbar-btn {
        padding: 8px 16px;
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 4px;
        color: #e0e0e0;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .toolbar-btn:hover {
        background: #454545;
        border-color: #606060;
      }

      .toolbar-btn.active {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .toolbar-btn i {
        font-size: 14px;
      }

      .toolbar-title {
        font-size: 16px;
        font-weight: 600;
        color: #fbbf24;
        margin-right: 10px;
      }

      /* Left Sidebar - Asset Library */
      .left-sidebar {
        position: absolute;
        left: 0;
        top: 50px;
        bottom: 0;
        width: 280px;
        background: rgba(30, 30, 30, 0.98);
        border-right: 1px solid #404040;
        z-index: 100;
        display: flex;
        flex-direction: column;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
      }

      .sidebar-tabs {
        display: flex;
        background: #252525;
        border-bottom: 1px solid #404040;
      }

      .sidebar-tab {
        flex: 1;
        padding: 12px 8px;
        text-align: center;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: all 0.2s;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        color: #999;
      }

      .sidebar-tab:hover {
        background: #2d2d2d;
        color: #e0e0e0;
      }

      .sidebar-tab.active {
        border-bottom-color: #0066cc;
        color: #0066cc;
        background: #2a2a2a;
      }

      .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
      }

      .sidebar-panel {
        display: none;
      }

      .sidebar-panel.active {
        display: block;
      }

      .section-title {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        color: #888;
        margin: 15px 0 10px 0;
        letter-spacing: 0.5px;
      }

      .section-title:first-child {
        margin-top: 0;
      }

      .asset-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .asset-item {
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 12px;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
      }

      .asset-item:hover {
        background: #333;
        border-color: #0066cc;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
      }

      .asset-item i {
        font-size: 24px;
        color: #0066cc;
        margin-bottom: 8px;
        display: block;
      }

      .asset-item-name {
        font-size: 11px;
        color: #ccc;
        font-weight: 500;
      }

      /* Right Sidebar - Properties & Tools */
      .right-sidebar {
        position: absolute;
        right: 0;
        top: 50px;
        bottom: 0;
        width: 320px;
        background: rgba(30, 30, 30, 0.98);
        border-left: 1px solid #404040;
        z-index: 100;
        display: flex;
        flex-direction: column;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
      }

      .panel-header {
        padding: 12px 15px;
        background: #252525;
        border-bottom: 1px solid #404040;
        font-size: 13px;
        font-weight: 600;
        color: #e0e0e0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .panel-header i {
        color: #0066cc;
        font-size: 14px;
      }

      .property-group {
        padding: 15px;
        border-bottom: 1px solid #2a2a2a;
      }

      .property-label {
        font-size: 11px;
        color: #999;
        margin-bottom: 6px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.3px;
      }

      .property-input {
        width: 100%;
        padding: 8px 10px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 13px;
        transition: border-color 0.2s;
      }

      .property-input:focus {
        outline: none;
        border-color: #0066cc;
      }

      .vector-inputs {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
      }

      .vector-input {
        padding: 8px 6px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 12px;
        text-align: center;
      }

      .vector-input:focus {
        outline: none;
        border-color: #0066cc;
      }

      .vector-labels {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        margin-bottom: 4px;
      }

      .vector-label {
        font-size: 10px;
        color: #666;
        text-align: center;
        font-weight: 600;
      }

      .btn {
        width: 100%;
        padding: 10px;
        background: #0066cc;
        border: none;
        border-radius: 4px;
        color: white;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        margin-top: 8px;
      }

      .btn:hover {
        background: #0052a3;
      }

      .btn.btn-danger {
        background: #dc2626;
      }

      .btn.btn-danger:hover {
        background: #b91c1c;
      }

      .btn.btn-secondary {
        background: #3a3a3a;
        border: 1px solid #505050;
      }

      .btn.btn-secondary:hover {
        background: #454545;
      }

      .transform-mode-group {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        margin-bottom: 15px;
      }

      .mode-btn {
        padding: 10px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #999;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .mode-btn:hover {
        background: #333;
        border-color: #0066cc;
        color: #e0e0e0;
      }

      .mode-btn.active {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .hierarchy-item {
        padding: 8px 10px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        margin-bottom: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .hierarchy-item:hover {
        background: #333;
        border-color: #505050;
      }

      .hierarchy-item.selected {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .hierarchy-item i {
        font-size: 12px;
        color: #0066cc;
        width: 16px;
      }

      .hierarchy-item.selected i {
        color: white;
      }

      .color-picker-wrapper {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .color-preview {
        width: 40px;
        height: 32px;
        border-radius: 4px;
        border: 1px solid #404040;
        cursor: pointer;
      }

      input[type="color"] {
        opacity: 0;
        position: absolute;
        pointer-events: none;
      }

      .no-selection {
        padding: 20px;
        text-align: center;
        color: #666;
        font-size: 13px;
      }

      /* Collision Items */
      .collision-item {
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 6px;
        font-size: 12px;
      }

      .collision-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .collision-toggle {
        padding: 4px 8px;
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 3px;
        color: #999;
        font-size: 11px;
        cursor: pointer;
      }

      .collision-toggle.enabled {
        background: #16a34a;
        border-color: #16a34a;
        color: white;
      }

      /* File input styling */
      .file-input-wrapper {
        position: relative;
        overflow: hidden;
        display: inline-block;
        width: 100%;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        left: -9999px;
      }

      .file-input-label {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 10px;
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 4px;
        color: #e0e0e0;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 13px;
      }

      .file-input-label:hover {
        background: #454545;
        border-color: #0066cc;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: #1a1a1a;
      }

      ::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #505050;
      }

      /* Scene Settings */
      .scene-setting {
        margin-bottom: 15px;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
      }

      .checkbox-wrapper input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
      }

      .checkbox-wrapper label {
        font-size: 12px;
        color: #ccc;
        cursor: pointer;
      }

      /* Play Mode Overlay */
      .play-mode-overlay {
        position: absolute;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 102, 204, 0.95);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        z-index: 2000;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      }

      .play-mode-overlay.active {
        display: block;
      }

      /* Spawn Point Visual */
      .spawn-point-info {
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        padding: 10px;
        margin-top: 10px;
        font-size: 11px;
        color: #999;
      }

      /* ============================================ */
      /* MOBILE-FIRST RESPONSIVE SYSTEM */
      /* ============================================ */

      /* Mobile Bottom Navigation Bar */
      .mobile-bottom-nav {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
        border-top: 1px solid #404040;
        z-index: 2000;
        padding: 0;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
      }

      .mobile-nav-items {
        display: flex;
        height: 100%;
        justify-content: space-around;
        align-items: center;
      }

      .mobile-nav-item {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        color: #999;
        cursor: pointer;
        transition: all 0.2s;
        padding: 8px;
        min-height: 44px;
        min-width: 44px;
      }

      .mobile-nav-item:active {
        background: rgba(255, 255, 255, 0.1);
      }

      .mobile-nav-item.active {
        color: #0066cc;
      }

      .mobile-nav-item i {
        font-size: 20px;
      }

      .mobile-nav-item span {
        font-size: 10px;
        font-weight: 500;
      }

      /* Hamburger Menu */
      .hamburger-btn {
        display: none;
        position: fixed;
        top: 10px;
        left: 10px;
        width: 44px;
        height: 44px;
        background: #2d2d2d;
        border: 1px solid #404040;
        border-radius: 6px;
        cursor: pointer;
        z-index: 1500;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
      }

      .hamburger-btn span {
        width: 20px;
        height: 2px;
        background: #e0e0e0;
        transition: all 0.3s;
      }

      .hamburger-btn.active span:nth-child(1) {
        transform: rotate(45deg) translate(5px, 5px);
      }

      .hamburger-btn.active span:nth-child(2) {
        opacity: 0;
      }

      .hamburger-btn.active span:nth-child(3) {
        transform: rotate(-45deg) translate(5px, -5px);
      }

      /* Panel Overlay for Mobile */
      .panel-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        z-index: 500;
      }

      .panel-overlay.active {
        display: block;
      }

      /* Tooltip System */
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.95);
        color: #fff;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.4;
        max-width: 250px;
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      }

      .tooltip.show {
        opacity: 1;
      }

      .tooltip::before {
        content: "";
        position: absolute;
        border: 6px solid transparent;
      }

      .tooltip.top::before {
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        border-top-color: rgba(0, 0, 0, 0.95);
      }

      .tooltip.bottom::before {
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        border-bottom-color: rgba(0, 0, 0, 0.95);
      }

      .tooltip.left::before {
        right: -12px;
        top: 50%;
        transform: translateY(-50%);
        border-left-color: rgba(0, 0, 0, 0.95);
      }

      .tooltip.right::before {
        left: -12px;
        top: 50%;
        transform: translateY(-50%);
        border-right-color: rgba(0, 0, 0, 0.95);
      }

      /* Touch-optimized controls */
      .touch-optimized {
        min-height: 44px;
        min-width: 44px;
      }

      /* ============================================ */
      /* PHASE 4: BLUEPRINT SYSTEM */
      /* ============================================ */

      /* Blueprint Node Palette */
      .node-palette-btn {
        display: block;
        width: 100%;
        padding: 8px 12px;
        margin: 4px 0;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 12px;
        text-align: left;
        cursor: pointer;
        transition: all 0.2s;
      }

      .node-palette-btn:hover {
        background: #353535;
        border-color: #505050;
        transform: translateX(4px);
      }

      .node-palette-btn:active {
        background: #404040;
      }

      /* Blueprint Node */
      .blueprint-node {
        position: absolute;
        min-width: 220px;
        background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
        border: 2px solid #505050;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7), 0 0 0 1px rgba(255, 255, 255, 0.05);
        cursor: move;
        user-select: none;
        transition: all 0.3s ease;
      }

      .blueprint-node:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.1);
      }

      .blueprint-node.selected {
        border-color: #00aaff;
        box-shadow: 0 0 20px rgba(0, 170, 255, 0.6), 0 0 0 3px rgba(0, 170, 255, 0.3);
        transform: translateY(-3px);
      }

      .blueprint-node.executing {
        border-color: #fbbf24;
        animation: pulse-node 0.5s ease-in-out;
      }

      @keyframes pulse-node {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(251, 191, 36, 0);
        }
      }

      .blueprint-node-header {
        padding: 12px 14px;
        font-weight: 700;
        font-size: 13px;
        color: white;
        background: linear-gradient(135deg, #2a5a2a 0%, #1f4a1f 100%);
        border-bottom: 2px solid rgba(0, 0, 0, 0.4);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        letter-spacing: 0.3px;
      }

      .blueprint-node-header.event {
        background: linear-gradient(135deg, #2a5a2a 0%, #1f4a1f 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .blueprint-node-header.action {
        background: linear-gradient(135deg, #2a3a5a 0%, #1f2f4a 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .blueprint-node-header.flow {
        background: linear-gradient(135deg, #5a4a2a 0%, #4a3a1f 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .blueprint-node-header.gameplay {
        background: linear-gradient(135deg, #5a2a5a 0%, #4a1f4a 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .blueprint-node-body {
        padding: 10px 12px;
      }

      .blueprint-node-pin {
        display: flex;
        align-items: center;
        margin: 6px 0;
        font-size: 11px;
        color: #aaa;
      }

      .blueprint-node-pin.input {
        justify-content: flex-start;
      }

      .blueprint-node-pin.output {
        justify-content: flex-end;
      }

      .blueprint-pin {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #555;
        border: 2px solid #888;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
      }

      .blueprint-pin.exec {
        background: white;
        border-color: white;
      }

      .blueprint-pin.data {
        background: #4a9eff;
        border-color: #4a9eff;
      }

      .blueprint-pin:hover {
        transform: scale(1.3);
        box-shadow: 0 0 8px currentColor;
      }

      .blueprint-node-pin.input .blueprint-pin {
        margin-right: 8px;
      }

      .blueprint-node-pin.output .blueprint-pin {
        margin-left: 8px;
      }

      .blueprint-node-param {
        margin: 8px 0;
        font-size: 11px;
      }

      .blueprint-node-param label {
        display: block;
        margin-bottom: 4px;
        color: #999;
      }

      .blueprint-node-param input,
      .blueprint-node-param select {
        width: 100%;
        padding: 6px 8px;
        background: #1a1a1a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 11px;
      }

      .blueprint-node-param input[type="color"] {
        height: 30px;
        padding: 2px;
      }

      /* Blueprint Connections */
      .blueprint-connection {
        stroke: rgba(255, 255, 255, 0.5);
        stroke-width: 3;
        fill: none;
        pointer-events: stroke;
        cursor: pointer;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        transition: all 0.2s ease;
      }

      .blueprint-connection.exec {
        stroke: rgba(255, 255, 255, 0.6);
      }

      .blueprint-connection.data {
        stroke: rgba(74, 158, 255, 0.6);
      }

      .blueprint-connection:hover {
        stroke-width: 3;
        filter: brightness(1.5);
      }

      .blueprint-connection.temp {
        stroke-dasharray: 5, 5;
        stroke: #fbbf24;
      }

      /* ============================================ */
      /* BLUEPRINT QUESTIONNAIRE SYSTEM */
      /* ============================================ */

      /* AI Assistant Group */
      .ai-assistant-group {
        margin-bottom: 15px;
      }

      /* AI Assistant Button */
      .btn-ai-assistant {
        width: 100%;
        padding: 16px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        position: relative;
        overflow: hidden;
      }

      .btn-ai-assistant::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn-ai-assistant:hover::before {
        left: 100%;
      }

      .btn-ai-assistant:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      .btn-ai-assistant:active {
        transform: translateY(0);
      }

      .ai-icon {
        font-size: 32px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .ai-text {
        flex: 1;
        text-align: left;
      }

      .ai-title {
        font-size: 14px;
        font-weight: 700;
        color: white;
        margin-bottom: 2px;
      }

      .ai-subtitle {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.85);
      }

      /* Questionnaire Modal */
      .questionnaire-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
      }

      .questionnaire-modal.active {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .questionnaire-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(4px);
      }

      .questionnaire-container {
        position: relative;
        width: 90%;
        max-width: 800px;
        max-height: 85vh;
        background: #1e1e1e;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        animation: slideUp 0.4s ease;
        border: 1px solid #404040;
      }

      @keyframes slideUp {
        from {
          transform: translateY(50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* Header */
      .questionnaire-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 24px 32px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px 20px 0 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .questionnaire-title {
        font-size: 24px;
        font-weight: 700;
        color: white;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .questionnaire-icon {
        font-size: 32px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .questionnaire-close {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        color: white;
        font-size: 28px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        line-height: 1;
      }

      .questionnaire-close:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: rotate(90deg);
      }

      /* Progress Bar */
      .questionnaire-progress-container {
        padding: 20px 32px;
        background: #252525;
        border-bottom: 1px solid #404040;
      }

      .questionnaire-progress-bar {
        height: 6px;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 3px;
        transition: width 0.4s ease;
        box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      }

      .questionnaire-progress-text {
        margin-top: 8px;
        font-size: 12px;
        color: #999;
        text-align: center;
      }

      /* Content Area */
      .questionnaire-content {
        flex: 1;
        padding: 32px;
        overflow-y: auto;
        min-height: 300px;
      }

      .questionnaire-question {
        margin-bottom: 32px;
      }

      .question-title {
        font-size: 22px;
        font-weight: 600;
        color: #e0e0e0;
        margin-bottom: 12px;
      }

      .question-description {
        font-size: 14px;
        color: #999;
        margin-bottom: 24px;
        line-height: 1.6;
      }

      /* Option Cards */
      .question-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }

      .option-card {
        background: #2a2a2a;
        border: 2px solid #404040;
        border-radius: 12px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .option-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.1) 0%,
          rgba(118, 75, 162, 0.1) 100%
        );
        opacity: 0;
        transition: opacity 0.3s;
      }

      .option-card:hover::before {
        opacity: 1;
      }

      .option-card:hover {
        border-color: #667eea;
        transform: translateY(-4px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
      }

      .option-card.selected {
        border-color: #667eea;
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.2) 0%,
          rgba(118, 75, 162, 0.2) 100%
        );
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.4);
      }

      .option-card.selected::after {
        content: "âœ“";
        position: absolute;
        top: 12px;
        right: 12px;
        width: 28px;
        height: 28px;
        background: #667eea;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 16px;
      }

      .option-icon {
        font-size: 40px;
        margin-bottom: 12px;
        display: block;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .option-title {
        font-size: 16px;
        font-weight: 600;
        color: #e0e0e0;
        margin-bottom: 6px;
      }

      .option-description {
        font-size: 12px;
        color: #999;
        line-height: 1.4;
      }

      /* Navigation */
      .questionnaire-navigation {
        display: flex;
        justify-content: space-between;
        padding: 24px 32px;
        background: #252525;
        border-top: 1px solid #404040;
        border-radius: 0 0 20px 20px;
      }

      .btn-questionnaire-back,
      .btn-questionnaire-next {
        padding: 12px 32px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        border: none;
      }

      .btn-questionnaire-back {
        background: #3a3a3a;
        color: #e0e0e0;
        border: 1px solid #505050;
      }

      .btn-questionnaire-back:hover {
        background: #454545;
      }

      .btn-questionnaire-back:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-questionnaire-next {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-questionnaire-next:hover {
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        transform: translateY(-2px);
      }

      .btn-questionnaire-next:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Welcome Screen */
      .welcome-screen {
        text-align: center;
        padding: 40px 20px;
      }

      .welcome-icon {
        font-size: 80px;
        margin-bottom: 24px;
        animation: float 3s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .welcome-title {
        font-size: 28px;
        font-weight: 700;
        color: #e0e0e0;
        margin-bottom: 16px;
      }

      .welcome-description {
        font-size: 16px;
        color: #999;
        line-height: 1.6;
        margin-bottom: 32px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
      }

      .welcome-features {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 20px;
        margin-top: 32px;
      }

      .welcome-feature {
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 12px;
        padding: 24px;
        transition: all 0.3s;
      }

      .welcome-feature:hover {
        border-color: #667eea;
        transform: translateY(-4px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.2);
      }

      .welcome-feature-icon {
        font-size: 36px;
        margin-bottom: 12px;
      }

      .welcome-feature-title {
        font-size: 16px;
        font-weight: 600;
        color: #e0e0e0;
        margin-bottom: 8px;
      }

      .welcome-feature-text {
        font-size: 13px;
        color: #999;
        line-height: 1.5;
      }

      /* ============================================ */
      /* PHASE 1.3: UI ORGANIZATION & ENHANCEMENT */
      /* ============================================ */

      /* Search Bar */
      .search-container {
        padding: 12px 15px;
        border-bottom: 1px solid #404040;
        background: #252525;
      }

      .search-box {
        position: relative;
        width: 100%;
      }

      .search-input {
        width: 100%;
        padding: 10px 40px 10px 36px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #e0e0e0;
        font-size: 13px;
        transition: all 0.2s;
      }

      .search-input:focus {
        outline: none;
        border-color: #0066cc;
        background: #2d2d2d;
      }

      .search-input::placeholder {
        color: #666;
      }

      .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #666;
        font-size: 14px;
        pointer-events: none;
      }

      .search-clear {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        color: #666;
        cursor: pointer;
        padding: 4px;
        display: none;
        transition: color 0.2s;
      }

      .search-clear:hover {
        color: #e0e0e0;
      }

      .search-clear.show {
        display: block;
      }

      /* Quick Access Toolbar */
      .quick-access-bar {
        display: flex;
        gap: 4px;
        padding: 8px 15px;
        background: #252525;
        border-bottom: 1px solid #404040;
        flex-wrap: wrap;
      }

      .quick-access-btn {
        width: 36px;
        height: 36px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        color: #999;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        font-size: 16px;
      }

      .quick-access-btn:hover {
        background: #333;
        border-color: #0066cc;
        color: #0066cc;
      }

      .quick-access-btn.active {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .quick-access-btn.favorite {
        color: #fbbf24;
      }

      /* Workspace Presets */
      .workspace-presets {
        display: flex;
        gap: 6px;
        padding: 10px 15px;
        background: #1f1f1f;
        border-bottom: 1px solid #404040;
        overflow-x: auto;
        scrollbar-width: thin;
      }

      .workspace-preset-btn {
        padding: 8px 14px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #999;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .workspace-preset-btn:hover {
        background: #333;
        border-color: #505050;
        color: #e0e0e0;
      }

      .workspace-preset-btn.active {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .workspace-preset-btn i {
        font-size: 12px;
      }

      /* Favorites System */
      .favorite-star {
        position: absolute;
        top: 4px;
        right: 4px;
        color: #666;
        cursor: pointer;
        font-size: 12px;
        z-index: 10;
        transition: all 0.2s;
        padding: 4px;
      }

      .favorite-star:hover {
        color: #fbbf24;
        transform: scale(1.2);
      }

      .favorite-star.active {
        color: #fbbf24;
      }

      .asset-item {
        position: relative;
      }

      /* Recent Items */
      .recent-items-section {
        margin-bottom: 15px;
      }

      .recent-item {
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        padding: 8px 10px;
        margin-bottom: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 12px;
      }

      .recent-item:hover {
        background: #333;
        border-color: #0066cc;
      }

      .recent-item i {
        color: #0066cc;
        font-size: 14px;
        width: 20px;
      }

      .recent-item-name {
        flex: 1;
        color: #ccc;
      }

      .recent-item-time {
        color: #666;
        font-size: 10px;
      }

      /* Keyboard Shortcut Overlay */
      .shortcuts-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(8px);
      }

      .shortcuts-overlay.show {
        display: flex;
      }

      .shortcuts-panel {
        background: #2d2d2d;
        border: 1px solid #404040;
        border-radius: 12px;
        padding: 30px;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      }

      .shortcuts-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
      }

      .shortcuts-title {
        font-size: 24px;
        font-weight: 600;
        color: #e0e0e0;
      }

      .shortcuts-close {
        width: 32px;
        height: 32px;
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 6px;
        color: #999;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .shortcuts-close:hover {
        background: #454545;
        color: #e0e0e0;
      }

      .shortcuts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 24px;
      }

      .shortcuts-category {
        background: #252525;
        border: 1px solid #404040;
        border-radius: 8px;
        padding: 16px;
      }

      .shortcuts-category-title {
        font-size: 14px;
        font-weight: 600;
        color: #0066cc;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .shortcut-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #333;
      }

      .shortcut-item:last-child {
        border-bottom: none;
      }

      .shortcut-action {
        color: #ccc;
        font-size: 13px;
      }

      .shortcut-keys {
        display: flex;
        gap: 4px;
      }

      .shortcut-key {
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 11px;
        font-weight: 600;
        color: #e0e0e0;
        font-family: "Courier New", monospace;
        min-width: 24px;
        text-align: center;
      }

      /* UI Mode Toggle */
      .ui-mode-toggle {
        display: flex;
        gap: 0;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 2px;
        margin: 10px 15px;
      }

      .ui-mode-btn {
        flex: 1;
        padding: 8px 12px;
        background: transparent;
        border: none;
        border-radius: 4px;
        color: #999;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
      }

      .ui-mode-btn:hover {
        color: #e0e0e0;
      }

      .ui-mode-btn.active {
        background: #0066cc;
        color: white;
      }

      /* Advanced Mode Indicators */
      .advanced-only {
        display: none;
      }

      body.advanced-mode .advanced-only {
        display: block;
      }

      /* Settings Button */
      .settings-btn {
        position: fixed;
        bottom: 80px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: #0066cc;
        border: none;
        border-radius: 50%;
        color: white;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.4);
        transition: all 0.2s;
        z-index: 1500;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-btn:hover {
        background: #0052a3;
        transform: scale(1.1);
        box-shadow: 0 6px 16px rgba(0, 102, 204, 0.6);
      }

      .settings-btn:active {
        transform: scale(0.95);
      }

      @media (max-width: 768px) {
        .settings-btn {
          bottom: 70px;
          right: 15px;
          width: 44px;
          height: 44px;
          font-size: 18px;
        }
      }

      /* ============================================ */
      /* PHASE 1.4: PERFORMANCE OPTIMIZATION */
      /* ============================================ */

      /* Performance Monitor */
      .performance-monitor {
        position: fixed;
        top: 60px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid #404040;
        border-radius: 8px;
        padding: 12px;
        font-family: "Courier New", monospace;
        font-size: 11px;
        color: #0f0;
        z-index: 2000;
        min-width: 200px;
        backdrop-filter: blur(8px);
        display: none;
      }

      .performance-monitor.show {
        display: block;
      }

      .perf-stat {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        padding: 2px 0;
      }

      .perf-label {
        color: #888;
      }

      .perf-value {
        font-weight: 600;
      }

      .perf-value.good {
        color: #0f0;
      }

      .perf-value.warning {
        color: #fbbf24;
      }

      .perf-value.bad {
        color: #f00;
      }

      .perf-divider {
        height: 1px;
        background: #404040;
        margin: 6px 0;
      }

      .perf-toggle-btn {
        position: fixed;
        top: 60px;
        right: 20px;
        width: 32px;
        height: 32px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #404040;
        border-radius: 4px;
        color: #0f0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2001;
        font-size: 14px;
        transition: all 0.2s;
      }

      .perf-toggle-btn:hover {
        background: rgba(0, 0, 0, 0.9);
        border-color: #0f0;
      }

      /* Loading Progress Bar */
      .loading-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: rgba(0, 102, 204, 0.3);
        z-index: 10000;
        display: none;
      }

      .loading-bar.show {
        display: block;
      }

      .loading-progress {
        height: 100%;
        background: linear-gradient(90deg, #0066cc, #00ccff);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(0, 102, 204, 0.8);
      }

      /* Quality Settings Indicator */
      .quality-indicator {
        position: fixed;
        bottom: 140px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 11px;
        color: #ccc;
        z-index: 1500;
        display: none;
        align-items: center;
        gap: 8px;
      }

      .quality-indicator.show {
        display: flex;
      }

      .quality-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #0f0;
      }

      .quality-dot.medium {
        background: #fbbf24;
      }

      .quality-dot.low {
        background: #f00;
      }

      @media (max-width: 768px) {
        .performance-monitor {
          top: 10px;
          right: 10px;
          font-size: 10px;
          min-width: 160px;
          padding: 8px;
        }

        .perf-toggle-btn {
          top: 10px;
          right: 10px;
        }

        .quality-indicator {
          bottom: 80px;
          right: 10px;
        }
      }

      /* ============================================ */
      /* PHASE 2: TEMPLATE SYSTEM */
      /* ============================================ */

      /* Template Library Modal */
      .template-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 9998;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(8px);
      }

      .template-modal.show {
        display: flex;
      }

      .template-modal-content {
        background: #2d2d2d;
        border: 1px solid #404040;
        border-radius: 12px;
        width: 90%;
        max-width: 1200px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      }

      .template-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid #404040;
      }

      .template-modal-title {
        font-size: 24px;
        font-weight: 600;
        color: #e0e0e0;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .template-modal-close {
        width: 36px;
        height: 36px;
        background: #3a3a3a;
        border: 1px solid #505050;
        border-radius: 6px;
        color: #999;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        font-size: 18px;
      }

      .template-modal-close:hover {
        background: #454545;
        color: #e0e0e0;
      }

      .template-filters {
        display: flex;
        gap: 8px;
        padding: 16px 24px;
        border-bottom: 1px solid #404040;
        flex-wrap: wrap;
      }

      .template-filter-btn {
        padding: 8px 16px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #999;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .template-filter-btn:hover {
        background: #333;
        border-color: #505050;
        color: #e0e0e0;
      }

      .template-filter-btn.active {
        background: #0066cc;
        border-color: #0066cc;
        color: white;
      }

      .template-grid-container {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
      }

      .template-category-title {
        font-size: 16px;
        font-weight: 600;
        color: #0066cc;
        margin-bottom: 16px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .template-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 32px;
      }

      .template-card {
        background: #252525;
        border: 1px solid #404040;
        border-radius: 8px;
        overflow: hidden;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
      }

      .template-card:hover {
        transform: translateY(-4px);
        border-color: #0066cc;
        box-shadow: 0 8px 24px rgba(0, 102, 204, 0.3);
      }

      .template-preview {
        width: 100%;
        height: 160px;
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .template-preview i {
        font-size: 48px;
        color: #0066cc;
        opacity: 0.5;
      }

      .template-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .template-badge {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px 8px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 4px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .template-badge.new {
        background: #0066cc;
        color: white;
      }

      .template-badge.popular {
        background: #fbbf24;
        color: #000;
      }

      .template-badge.advanced {
        background: #dc2626;
        color: white;
      }

      .template-info {
        padding: 16px;
      }

      .template-name {
        font-size: 16px;
        font-weight: 600;
        color: #e0e0e0;
        margin-bottom: 6px;
      }

      .template-description {
        font-size: 13px;
        color: #999;
        margin-bottom: 12px;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .template-tags {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .template-tag {
        padding: 3px 8px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 4px;
        font-size: 11px;
        color: #888;
      }

      .template-actions {
        display: flex;
        gap: 8px;
      }

      .template-btn {
        flex: 1;
        padding: 10px;
        background: #0066cc;
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .template-btn:hover {
        background: #0052a3;
      }

      .template-btn-secondary {
        background: #3a3a3a;
        color: #e0e0e0;
      }

      .template-btn-secondary:hover {
        background: #454545;
      }

      /* New Project Button */
      .new-project-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #0066cc 0%, #0052a3 100%);
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
      }

      .new-project-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 102, 204, 0.5);
      }

      @media (max-width: 768px) {
        .template-modal-content {
          width: 95%;
          max-height: 90vh;
        }

        .template-grid {
          grid-template-columns: 1fr;
        }

        .template-filters {
          padding: 12px 16px;
        }

        .template-grid-container {
          padding: 16px;
        }
      }

      /* ============================================ */
      /* RESPONSIVE BREAKPOINTS */
      /* ============================================ */

      /* Mobile Portrait: 320px - 480px */
      @media (max-width: 480px) {
        .mobile-bottom-nav {
          display: block;
        }

        .hamburger-btn {
          display: flex;
        }

        .top-toolbar {
          padding: 0 50px;
          height: 50px;
        }

        .toolbar-title {
          font-size: 14px;
        }

        .toolbar-section {
          display: none;
        }

        .left-sidebar {
          left: -100%;
          width: 85%;
          max-width: 320px;
          transition: left 0.3s ease;
          z-index: 1000;
        }

        .left-sidebar.mobile-open {
          left: 0;
        }

        .right-sidebar {
          right: -100%;
          width: 85%;
          max-width: 320px;
          transition: right 0.3s ease;
          z-index: 1000;
        }

        .right-sidebar.mobile-open {
          right: 0;
        }

        .asset-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 6px;
        }

        .sidebar-tab {
          font-size: 10px;
          padding: 10px 4px;
        }

        .property-group {
          padding: 12px;
        }

        .vector-inputs,
        .vector-labels {
          gap: 4px;
        }

        /* Enlarge touch targets */
        .toolbar-btn,
        .btn,
        .mode-btn,
        .asset-item,
        .hierarchy-item {
          min-height: 44px;
          touch-action: manipulation;
        }

        .property-input,
        .vector-input {
          min-height: 44px;
          font-size: 16px; /* Prevents zoom on iOS */
        }
      }

      /* Mobile Landscape: 481px - 767px */
      @media (min-width: 481px) and (max-width: 767px) {
        .mobile-bottom-nav {
          display: block;
        }

        .hamburger-btn {
          display: flex;
        }

        .top-toolbar {
          padding: 0 50px;
        }

        .left-sidebar {
          width: 280px;
          left: -100%;
          transition: left 0.3s ease;
          z-index: 1000;
        }

        .left-sidebar.mobile-open {
          left: 0;
        }

        .right-sidebar {
          width: 300px;
          right: -100%;
          transition: right 0.3s ease;
          z-index: 1000;
        }

        .right-sidebar.mobile-open {
          right: 0;
        }

        .asset-grid {
          grid-template-columns: repeat(3, 1fr);
        }

        /* Touch targets */
        .toolbar-btn,
        .btn,
        .mode-btn {
          min-height: 44px;
        }
      }

      /* Tablet Portrait: 768px - 1024px */
      @media (min-width: 768px) and (max-width: 1024px) {
        .left-sidebar {
          width: 260px;
        }

        .right-sidebar {
          width: 280px;
        }

        .asset-grid {
          grid-template-columns: repeat(2, 1fr);
        }

        .top-toolbar {
          padding: 0 15px;
        }

        .toolbar-section {
          gap: 6px;
        }

        .toolbar-btn {
          padding: 8px 12px;
          font-size: 12px;
        }
      }

      /* Tablet Landscape: 1025px - 1366px */
      @media (min-width: 1025px) and (max-width: 1366px) {
        .left-sidebar {
          width: 280px;
        }

        .right-sidebar {
          width: 300px;
        }

        .asset-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      /* Desktop: 1367px+ */
      @media (min-width: 1367px) {
        .left-sidebar {
          width: 320px;
        }

        .right-sidebar {
          width: 340px;
        }

        .asset-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 10px;
        }
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 500px) {
        .top-toolbar {
          height: 40px;
        }

        .mobile-bottom-nav {
          height: 50px;
        }

        .left-sidebar,
        .right-sidebar {
          top: 40px;
        }
      }

      /* High DPI screens */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        /* Sharper rendering for high-DPI displays */
        .toolbar-btn,
        .btn,
        .asset-item {
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        }
      }

      /* Reduced motion preference */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }

      /* Dark mode support (system preference) */
      @media (prefers-color-scheme: light) {
        /* Future: Light theme support */
      }

      /* GAME BUILDER STYLES */
      .game-template-btn {
        background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px 10px;
        color: #aaa;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 5px;
      }

      .game-template-btn:hover {
        background: linear-gradient(135deg, #3a3a3a 0%, #2f2f2f 100%);
        border-color: #00aaff;
        color: #00aaff;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 170, 255, 0.3);
      }

      .game-template-btn.selected {
        background: linear-gradient(135deg, #00aaff 0%, #0088cc 100%);
        border-color: #00aaff;
        color: white;
        box-shadow: 0 4px 12px rgba(0, 170, 255, 0.5);
      }

      .blueprint-card {
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
      }

      .blueprint-card.active {
        border-color: #00ff88;
        background: linear-gradient(135deg, #1a3a2a 0%, #1f2f1f 100%);
      }

      .blueprint-card.suggestion {
        border-color: #ffaa00;
        background: linear-gradient(135deg, #3a3a1a 0%, #2f2f1f 100%);
        box-shadow: 0 0 15px rgba(255, 170, 0, 0.3);
      }

      .blueprint-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .blueprint-card-title {
        font-weight: 600;
        font-size: 13px;
        color: #fff;
      }

      .blueprint-card.active .blueprint-card-title {
        color: #00ff88;
      }

      .blueprint-card.suggestion .blueprint-card-title {
        color: #ffaa00;
      }

      .blueprint-card-badge {
        font-size: 10px;
        padding: 3px 8px;
        border-radius: 12px;
        font-weight: 600;
      }

      .blueprint-card-badge.active {
        background: #00ff88;
        color: #000;
      }

      .blueprint-card-badge.suggestion {
        background: #ffaa00;
        color: #000;
      }

      .blueprint-card-description {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 10px;
        line-height: 1.4;
      }

      .blueprint-card-actions {
        display: flex;
        gap: 8px;
      }

      .blueprint-card-btn {
        flex: 1;
        background: #333;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 6px 12px;
        color: #aaa;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.2s ease;
      }

      .blueprint-card-btn:hover {
        background: #444;
        border-color: #00aaff;
        color: #00aaff;
      }

      .blueprint-card-btn.primary {
        background: linear-gradient(135deg, #00aaff 0%, #0088cc 100%);
        border-color: #00aaff;
        color: white;
      }

      .blueprint-card-btn.primary:hover {
        background: linear-gradient(135deg, #00bbff 0%, #0099dd 100%);
        box-shadow: 0 2px 8px rgba(0, 170, 255, 0.4);
      }

      .blueprint-card-btn.danger {
        background: #ff4444;
        border-color: #ff4444;
        color: white;
      }

      .blueprint-card-btn.danger:hover {
        background: #ff5555;
      }

      /* GAME HUB SUB-TABS */
      .game-subtab {
        flex: 1;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 6px;
        padding: 8px 12px;
        color: #aaa;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .game-subtab:hover {
        background: #3a3a3a;
        border-color: #00aaff;
        color: #00aaff;
      }

      .game-subtab.active {
        background: linear-gradient(135deg, #00aaff 0%, #0088cc 100%);
        border-color: #00aaff;
        color: white;
        box-shadow: 0 2px 8px rgba(0, 170, 255, 0.4);
      }

      .game-subpanel {
        display: none;
      }

      .game-subpanel.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <!-- Workspace Presets Bar -->
    <div class="workspace-presets" id="workspace-presets">
      <div
        class="workspace-preset-btn active"
        onclick="setWorkspacePreset('general')"
        data-tooltip="General workspace - balanced layout for all tasks"
      >
        <i class="fas fa-th-large"></i>
        <span>General</span>
      </div>
      <div
        class="workspace-preset-btn"
        onclick="setWorkspacePreset('modeling')"
        data-tooltip="Modeling workspace - optimized for creating 3D objects"
      >
        <i class="fas fa-cube"></i>
        <span>Modeling</span>
      </div>
      <div
        class="workspace-preset-btn"
        onclick="setWorkspacePreset('lighting')"
        data-tooltip="Lighting workspace - focus on lights and materials"
      >
        <i class="fas fa-lightbulb"></i>
        <span>Lighting</span>
      </div>
      <div
        class="workspace-preset-btn advanced-only"
        onclick="setWorkspacePreset('animation')"
        data-tooltip="Animation workspace - timeline and keyframe tools"
      >
        <i class="fas fa-film"></i>
        <span>Animation</span>
      </div>
      <div
        class="workspace-preset-btn advanced-only"
        onclick="setWorkspacePreset('scripting')"
        data-tooltip="Scripting workspace - code editor and console"
      >
        <i class="fas fa-code"></i>
        <span>Scripting</span>
      </div>
    </div>

    <!-- Top Toolbar -->
    <div class="top-toolbar">
      <div
        class="toolbar-title"
        data-tooltip="Three.js Professional World Builder"
      >
        <i class="fas fa-cube"></i> World Builder
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-section">
        <button
          type="button"
          class="new-project-btn"
          onclick="showTemplateLibrary()"
          data-tooltip="Start a new project from template (Ctrl+N)"
        >
          <i class="fas fa-file"></i>
          <span>New Project</span>
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-section">
        <button
          type="button"
          class="toolbar-btn"
          id="mode-toggle"
          data-tooltip="Switch between edit and play mode to test your scene"
        >
          <i class="fas fa-gamepad"></i>
          <span id="mode-text">Play Mode</span>
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-section">
        <button
          type="button"
          class="toolbar-btn"
          onclick="undo()"
          data-tooltip="Undo the last action (Ctrl+Z)"
        >
          <i class="fas fa-undo"></i> Undo
        </button>
        <button
          type="button"
          class="toolbar-btn"
          onclick="redo()"
          data-tooltip="Redo the last undone action (Ctrl+Y)"
        >
          <i class="fas fa-redo"></i> Redo
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-section">
        <button
          type="button"
          class="toolbar-btn"
          onclick="saveScene()"
          data-tooltip="Save your scene to a JSON file"
        >
          <i class="fas fa-save"></i> Save
        </button>
        <button
          type="button"
          class="toolbar-btn"
          onclick="loadScene()"
          data-tooltip="Load a previously saved scene from JSON"
        >
          <i class="fas fa-folder-open"></i> Load
        </button>
        <button
          type="button"
          class="toolbar-btn"
          onclick="exportCode()"
          data-tooltip="Export your scene as standalone HTML code"
        >
          <i class="fas fa-code"></i> Export
        </button>
      </div>
    </div>

    <!-- Play Mode Overlay -->
    <div class="play-mode-overlay" id="play-mode-overlay">
      <i class="fas fa-gamepad"></i> PLAY MODE - Click to control | ESC to
      return to editor
    </div>

    <!-- Left Sidebar - Asset Library -->
    <div class="left-sidebar" id="left-sidebar">
      <div class="sidebar-tabs">
        <div class="sidebar-tab active" onclick="switchLeftTab('assets')">
          <i class="fas fa-box"></i><br />Assets
        </div>
        <div class="sidebar-tab" onclick="switchLeftTab('library')">
          <i class="fas fa-book"></i><br />Library
        </div>
        <div class="sidebar-tab" onclick="switchLeftTab('objects')">
          <i class="fas fa-layer-group"></i><br />Objects
        </div>
        <div class="sidebar-tab" onclick="switchLeftTab('collisions')">
          <i class="fas fa-shield-alt"></i><br />Collision
        </div>
      </div>

      <!-- Search Bar -->
      <div class="search-container">
        <div class="search-box">
          <i class="fas fa-search search-icon"></i>
          <input
            type="text"
            class="search-input"
            id="asset-search"
            placeholder="Search assets..."
            oninput="searchAssets(this.value)"
          />
          <i
            class="fas fa-times search-clear"
            id="search-clear"
            onclick="clearSearch()"
          ></i>
        </div>
      </div>

      <!-- UI Mode Toggle -->
      <div class="ui-mode-toggle">
        <button
          type="button"
          class="ui-mode-btn active"
          onclick="setUIMode('beginner')"
          data-tooltip="Beginner mode - simplified interface"
        >
          <i class="fas fa-user"></i> Beginner
        </button>
        <button
          type="button"
          class="ui-mode-btn"
          onclick="setUIMode('advanced')"
          data-tooltip="Advanced mode - all features unlocked"
        >
          <i class="fas fa-user-cog"></i> Advanced
        </button>
      </div>

      <div class="sidebar-content">
        <!-- Assets Panel -->
        <div class="sidebar-panel active" id="panel-assets">
          <div class="section-title">Primitives</div>
          <div class="asset-grid">
            <div
              class="asset-item"
              onclick="createAsset('box')"
              data-tooltip="Add a cube - perfect for building blocks, walls, and boxes"
            >
              <i class="fas fa-cube"></i>
              <div class="asset-item-name">Cube</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('sphere')"
              data-tooltip="Add a sphere - great for balls, planets, and rounded objects"
            >
              <i class="fas fa-circle"></i>
              <div class="asset-item-name">Sphere</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('cylinder')"
              data-tooltip="Add a cylinder - useful for columns, pipes, and containers"
            >
              <i class="fas fa-database"></i>
              <div class="asset-item-name">Cylinder</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('plane')"
              data-tooltip="Add a flat plane - ideal for floors, walls, and flat surfaces"
            >
              <i class="fas fa-square"></i>
              <div class="asset-item-name">Plane</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('cone')"
              data-tooltip="Add a cone - perfect for pyramids, arrows, and pointed objects"
            >
              <i class="fas fa-play"></i>
              <div class="asset-item-name">Cone</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('torus')"
              data-tooltip="Add a torus (donut shape) - great for rings and decorative elements"
            >
              <i class="fas fa-circle-notch"></i>
              <div class="asset-item-name">Torus</div>
            </div>
          </div>

          <div class="section-title">Environment</div>
          <div class="asset-grid">
            <div
              class="asset-item"
              onclick="createAsset('wall')"
              data-tooltip="Create a wall - vertical barrier for rooms and boundaries"
            >
              <i class="fas fa-bars"></i>
              <div class="asset-item-name">Wall</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('floor')"
              data-tooltip="Create a floor - large horizontal surface for walking"
            >
              <i class="fas fa-border-all"></i>
              <div class="asset-item-name">Floor</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('stairs')"
              data-tooltip="Add stairs - for connecting different levels"
            >
              <i class="fas fa-stairs"></i>
              <div class="asset-item-name">Stairs</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('door')"
              data-tooltip="Add a door - entrance or exit point"
            >
              <i class="fas fa-door-open"></i>
              <div class="asset-item-name">Door</div>
            </div>
          </div>

          <div class="section-title">Lights</div>
          <div class="asset-grid">
            <div
              class="asset-item"
              onclick="createAsset('pointLight')"
              data-tooltip="Point light - emits light in all directions from a single point"
            >
              <i class="fas fa-lightbulb"></i>
              <div class="asset-item-name">Point Light</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('spotLight')"
              data-tooltip="Spot light - focused beam of light like a flashlight"
            >
              <i class="fas fa-circle-notch"></i>
              <div class="asset-item-name">Spot Light</div>
            </div>
          </div>

          <div class="section-title">Special</div>
          <div class="asset-grid">
            <div
              class="asset-item"
              onclick="createAsset('spawnPoint')"
              data-tooltip="Spawn point - where the player starts in play mode"
            >
              <i class="fas fa-user"></i>
              <div class="asset-item-name">Spawn Point</div>
            </div>
            <div
              class="asset-item"
              onclick="createAsset('group')"
              data-tooltip="Empty group - organize multiple objects together"
            >
              <i class="fas fa-object-group"></i>
              <div class="asset-item-name">Group</div>
            </div>
          </div>

          <div class="section-title">3D Models</div>
          <div class="file-input-wrapper">
            <input
              type="file"
              id="model-file-input"
              accept=".glb,.gltf"
              onchange="loadModel(event)"
            />
            <label for="model-file-input" class="file-input-label">
              <i class="fas fa-upload"></i> Load GLB/GLTF
            </label>
          </div>
        </div>

        <!-- Library Panel -->
        <div class="sidebar-panel" id="panel-library">
          <div class="section-title">Default Assets</div>
          <div class="asset-grid">
            <div class="asset-item" onclick="createDefaultAsset('grass')">
              <i class="fas fa-seedling"></i>
              <div class="asset-item-name">Grass Plane</div>
            </div>
            <div class="asset-item" onclick="createDefaultAsset('pedestal')">
              <i class="fas fa-th-large"></i>
              <div class="asset-item-name">Pedestal</div>
            </div>
            <div class="asset-item" onclick="createDefaultAsset('wall')">
              <i class="fas fa-border-all"></i>
              <div class="asset-item-name">Wall</div>
            </div>
            <div class="asset-item" onclick="createDefaultAsset('frame')">
              <i class="fas fa-image"></i>
              <div class="asset-item-name">Art Frame</div>
            </div>
            <div class="asset-item" onclick="createDefaultAsset('floor')">
              <i class="fas fa-square"></i>
              <div class="asset-item-name">Floor Tile</div>
            </div>
            <div class="asset-item" onclick="createDefaultAsset('ceiling')">
              <i class="fas fa-minus"></i>
              <div class="asset-item-name">Ceiling</div>
            </div>
          </div>

          <div class="section-title">Environment</div>
          <div class="asset-grid">
            <div class="asset-item" onclick="createDefaultAsset('skybox')">
              <i class="fas fa-cloud"></i>
              <div class="asset-item-name">Sky</div>
            </div>
            <div
              class="asset-item"
              onclick="createDefaultAsset('ambientlight')"
            >
              <i class="fas fa-sun"></i>
              <div class="asset-item-name">Ambient Light</div>
            </div>
          </div>
        </div>

        <!-- Objects Panel -->
        <div class="sidebar-panel" id="panel-objects">
          <div class="section-title">Scene Hierarchy</div>
          <div id="hierarchy-list"></div>
        </div>

        <!-- Collisions Panel -->
        <div class="sidebar-panel" id="panel-collisions">
          <div class="section-title">Collision Objects</div>
          <div id="collision-list"></div>
          <button
            type="button"
            class="btn btn-secondary"
            onclick="toggleAllColliders()"
          >
            <i class="fas fa-eye"></i> Toggle Helpers
          </button>
          <button type="button" class="btn" onclick="rebuildColliders()">
            <i class="fas fa-sync"></i> Rebuild All
          </button>
        </div>
      </div>
    </div>

    <!-- Right Sidebar - Properties -->
    <div class="right-sidebar" id="right-sidebar">
      <div class="sidebar-tabs">
        <div class="sidebar-tab active" onclick="switchRightTab('properties')">
          <i class="fas fa-sliders-h"></i><br />Properties
        </div>
        <div class="sidebar-tab" onclick="switchRightTab('scene')">
          <i class="fas fa-globe"></i><br />Scene
        </div>
        <div class="sidebar-tab" onclick="switchRightTab('blueprint')">
          <i class="fas fa-project-diagram"></i><br />Blueprint
        </div>
        <div class="sidebar-tab" onclick="switchRightTab('game')">
          <i class="fas fa-gamepad"></i><br>Game
        </div>
      </div>

      <div class="sidebar-content">
        <!-- Properties Panel -->
        <div class="sidebar-panel active" id="panel-properties">
          <div class="no-selection" id="no-selection">
            <i
              class="fas fa-mouse-pointer"
              style="
                font-size: 32px;
                color: #444;
                margin-bottom: 10px;
                display: block;
              "
            ></i>
            Select an object to edit properties
          </div>

          <div id="properties-content" style="display: none">
            <div class="property-group">
              <div class="property-label">Object Name</div>
              <input
                type="text"
                class="property-input"
                id="obj-name"
                oninput="updateObjectName()"
              />
            </div>

            <div class="property-group">
              <div class="property-label">Transform Mode</div>
              <div class="transform-mode-group">
                <button
                  type="button"
                  class="mode-btn active"
                  id="mode-translate"
                  onclick="setTransformMode('translate')"
                >
                  <i class="fas fa-arrows-alt"></i> Move
                </button>
                <button
                  type="button"
                  class="mode-btn"
                  id="mode-rotate"
                  onclick="setTransformMode('rotate')"
                >
                  <i class="fas fa-redo"></i> Rotate
                </button>
                <button
                  type="button"
                  class="mode-btn"
                  id="mode-scale"
                  onclick="setTransformMode('scale')"
                >
                  <i class="fas fa-expand"></i> Scale
                </button>
              </div>
            </div>

            <div class="property-group">
              <div class="property-label">Position</div>
              <div class="vector-labels">
                <div class="vector-label">X</div>
                <div class="vector-label">Y</div>
                <div class="vector-label">Z</div>
              </div>
              <div class="vector-inputs">
                <input
                  type="number"
                  class="vector-input"
                  id="pos-x"
                  step="0.1"
                  oninput="updatePosition('x', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="pos-y"
                  step="0.1"
                  oninput="updatePosition('y', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="pos-z"
                  step="0.1"
                  oninput="updatePosition('z', this.value)"
                />
              </div>
            </div>

            <div class="property-group">
              <div class="property-label">Rotation (degrees)</div>
              <div class="vector-labels">
                <div class="vector-label">X</div>
                <div class="vector-label">Y</div>
                <div class="vector-label">Z</div>
              </div>
              <div class="vector-inputs">
                <input
                  type="number"
                  class="vector-input"
                  id="rot-x"
                  step="1"
                  oninput="updateRotation('x', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="rot-y"
                  step="1"
                  oninput="updateRotation('y', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="rot-z"
                  step="1"
                  oninput="updateRotation('z', this.value)"
                />
              </div>
            </div>

            <div class="property-group">
              <div class="property-label">Scale</div>
              <div class="vector-labels">
                <div class="vector-label">X</div>
                <div class="vector-label">Y</div>
                <div class="vector-label">Z</div>
              </div>
              <div class="vector-inputs">
                <input
                  type="number"
                  class="vector-input"
                  id="scale-x"
                  step="0.1"
                  oninput="updateScale('x', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="scale-y"
                  step="0.1"
                  oninput="updateScale('y', this.value)"
                />
                <input
                  type="number"
                  class="vector-input"
                  id="scale-z"
                  step="0.1"
                  oninput="updateScale('z', this.value)"
                />
              </div>
            </div>

            <div class="property-group" id="material-section">
              <div class="property-label">Material</div>
              <div class="color-picker-wrapper">
                <div
                  class="color-preview"
                  id="color-preview"
                  onclick="document.getElementById('obj-color').click()"
                ></div>
                <input type="color" id="obj-color" oninput="updateColor()" />
                <input
                  type="text"
                  class="property-input"
                  id="color-hex"
                  style="flex: 1"
                  oninput="updateColorFromHex()"
                  placeholder="#ffffff"
                />
              </div>

              <div class="property-label" style="margin-top: 12px">
                Roughness
              </div>
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value="0.5"
                id="obj-roughness"
                oninput="updateMaterial()"
                style="width: 100%"
              />

              <div class="property-label" style="margin-top: 12px">
                Metalness
              </div>
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value="0.5"
                id="obj-metalness"
                oninput="updateMaterial()"
                style="width: 100%"
              />
            </div>

            <div
              class="property-group"
              id="light-section"
              style="display: none"
            >
              <div class="property-label">Light Color</div>
              <div class="color-picker-wrapper">
                <div
                  class="color-preview"
                  id="light-color-preview"
                  onclick="document.getElementById('light-color').click()"
                ></div>
                <input
                  type="color"
                  id="light-color"
                  oninput="updateLightColor()"
                />
              </div>

              <div class="property-label" style="margin-top: 12px">
                Intensity
              </div>
              <input
                type="number"
                class="property-input"
                id="light-intensity"
                min="0"
                step="0.1"
                value="1"
                oninput="updateLightIntensity()"
              />

              <div class="property-label">Distance (0 = infinite)</div>
              <input
                type="number"
                class="property-input"
                id="light-distance"
                min="0"
                step="1"
                value="0"
                oninput="updateLightDistance()"
              />
            </div>

            <div class="property-group" id="collision-section">
              <div class="property-label">Collision</div>
              <div class="checkbox-wrapper">
                <input
                  type="checkbox"
                  id="has-collision"
                  onchange="toggleObjectCollision()"
                />
                <label for="has-collision">Enable Collision</label>
              </div>

              <!-- Collision Shape Selector -->
              <div
                id="collision-shape-options"
                style="margin-top: 10px; display: none"
              >
                <div class="property-label">Collision Shape</div>
                <select
                  class="property-input"
                  id="collision-shape"
                  onchange="updateCollisionShape()"
                >
                  <option value="box">Box</option>
                  <option value="sphere">Sphere</option>
                  <option value="capsule">Capsule</option>
                  <option value="mesh">Mesh (Exact)</option>
                </select>

                <!-- Trigger Checkbox -->
                <div class="checkbox-wrapper" style="margin-top: 10px">
                  <input
                    type="checkbox"
                    id="is-trigger"
                    onchange="updateIsTrigger()"
                  />
                  <label
                    for="is-trigger"
                    data-tooltip="Trigger volumes detect collisions but don't physically block objects"
                    >Is Trigger</label
                  >
                </div>

                <!-- Trigger Behavior Options (shown only when Is Trigger is checked) -->
                <div
                  id="trigger-behavior-options"
                  style="margin-top: 10px; display: none"
                >
                  <div class="property-label">Trigger Behavior</div>
                  <select
                    class="property-input"
                    id="trigger-behavior"
                    onchange="updateTriggerBehavior()"
                  >
                    <option value="none">None (Custom Code)</option>
                    <option value="checkpoint">
                      Checkpoint (Save Position)
                    </option>
                    <option value="damage">Damage Zone (Hurt Player)</option>
                    <option value="heal">Healing Zone (Heal Player)</option>
                    <option value="teleport">
                      Teleporter (Move to Target)
                    </option>
                    <option value="speedboost">Speed Boost Zone</option>
                    <option value="killzone">Kill Zone (Reset Level)</option>
                    <option value="collect">
                      Collectible (Disappear on Touch)
                    </option>
                    <option value="door">Door Trigger (Open/Close)</option>
                    <option value="message">Show Message</option>
                  </select>

                  <!-- Behavior-Specific Parameters -->
                  <div id="trigger-params" style="margin-top: 8px">
                    <!-- Damage Amount (for damage/heal zones) -->
                    <div id="param-damage" style="display: none">
                      <div
                        class="property-label"
                        style="font-size: 11px; margin-top: 5px"
                      >
                        Damage/Heal Amount
                      </div>
                      <input
                        type="number"
                        class="property-input"
                        id="trigger-damage-amount"
                        value="10"
                        onchange="updateTriggerParams()"
                        style="font-size: 12px"
                      />
                    </div>

                    <!-- Teleport Target (for teleporter) -->
                    <div id="param-teleport" style="display: none">
                      <div
                        class="property-label"
                        style="font-size: 11px; margin-top: 5px"
                      >
                        Teleport To (Object Name)
                      </div>
                      <input
                        type="text"
                        class="property-input"
                        id="trigger-teleport-target"
                        placeholder="TargetPoint"
                        onchange="updateTriggerParams()"
                        style="font-size: 12px"
                      />
                    </div>

                    <!-- Speed Boost (for speed zones) -->
                    <div id="param-speed" style="display: none">
                      <div
                        class="property-label"
                        style="font-size: 11px; margin-top: 5px"
                      >
                        Speed Multiplier
                      </div>
                      <input
                        type="number"
                        class="property-input"
                        id="trigger-speed-mult"
                        value="2"
                        step="0.1"
                        onchange="updateTriggerParams()"
                        style="font-size: 12px"
                      />
                    </div>

                    <!-- Message (for message triggers) -->
                    <div id="param-message" style="display: none">
                      <div
                        class="property-label"
                        style="font-size: 11px; margin-top: 5px"
                      >
                        Message Text
                      </div>
                      <input
                        type="text"
                        class="property-input"
                        id="trigger-message-text"
                        placeholder="Enter message..."
                        onchange="updateTriggerParams()"
                        style="font-size: 12px"
                      />
                    </div>
                  </div>

                  <!-- Trigger Event Log -->
                  <div style="margin-top: 10px; font-size: 11px; color: #888">
                    <div class="checkbox-wrapper">
                      <input
                        type="checkbox"
                        id="trigger-log-events"
                        onchange="updateTriggerParams()"
                        checked
                      />
                      <label for="trigger-log-events" style="font-size: 11px"
                        >Log Events to Console</label
                      >
                    </div>
                  </div>
                </div>

                <!-- Collision Layer -->
                <div class="property-label" style="margin-top: 10px">
                  Collision Layer
                </div>
                <select
                  class="property-input"
                  id="collision-layer"
                  onchange="updateCollisionLayer()"
                >
                  <option value="0">Default</option>
                  <option value="1">Player</option>
                  <option value="2">Enemy</option>
                  <option value="3">Environment</option>
                  <option value="4">Projectile</option>
                  <option value="5">Pickup</option>
                  <option value="6">Trigger</option>
                  <option value="7">Custom 1</option>
                  <option value="8">Custom 2</option>
                </select>

                <!-- Collision Mask (Collides With) -->
                <div
                  style="
                    margin-top: 15px;
                    padding-top: 10px;
                    border-top: 1px solid rgba(255, 255, 255, 0.1);
                  "
                >
                  <div
                    class="property-label"
                    style="
                      display: flex;
                      justify-content: space-between;
                      align-items: center;
                    "
                  >
                    <span
                      data-tooltip="Select which layers this object can collide with"
                      >Collides With</span
                    >
                    <button
                      type="button"
                      onclick="toggleAllLayers()"
                      style="
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        color: white;
                        padding: 2px 8px;
                        border-radius: 3px;
                        cursor: pointer;
                        font-size: 11px;
                      "
                    >
                      All
                    </button>
                  </div>
                  <div
                    id="collision-mask-checkboxes"
                    style="
                      margin-top: 8px;
                      max-height: 150px;
                      overflow-y: auto;
                      font-size: 12px;
                    "
                  >
                    <!-- Layer checkboxes will be generated here -->
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-0"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-0" style="font-size: 12px"
                        >Default</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-1"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-1" style="font-size: 12px"
                        >Player</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-2"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-2" style="font-size: 12px"
                        >Enemy</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-3"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-3" style="font-size: 12px"
                        >Environment</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-4"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-4" style="font-size: 12px"
                        >Projectile</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-5"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-5" style="font-size: 12px"
                        >Pickup</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-6"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-6" style="font-size: 12px"
                        >Trigger</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-7"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-7" style="font-size: 12px"
                        >Custom 1</label
                      >
                    </div>
                    <div class="checkbox-wrapper" style="margin: 4px 0">
                      <input
                        type="checkbox"
                        id="mask-layer-8"
                        onchange="updateCollisionMask()"
                        checked
                      />
                      <label for="mask-layer-8" style="font-size: 12px"
                        >Custom 2</label
                      >
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Physics / Rigidbody Section -->
            <div class="property-group" id="physics-section">
              <div class="property-label">Physics (Rigidbody)</div>
              <div class="checkbox-wrapper">
                <input
                  type="checkbox"
                  id="has-physics"
                  onchange="toggleObjectPhysics()"
                />
                <label
                  for="has-physics"
                  data-tooltip="Add realistic physics simulation to this object"
                  >Enable Physics</label
                >
              </div>

              <!-- Physics Options (shown only when physics is enabled) -->
              <div id="physics-options" style="margin-top: 10px; display: none">
                <!-- Body Type -->
                <div class="property-label" style="margin-top: 10px">
                  Body Type
                </div>
                <select
                  class="property-input"
                  id="physics-body-type"
                  onchange="updatePhysicsBodyType()"
                >
                  <option value="dynamic">Dynamic (Moves with physics)</option>
                  <option value="static">Static (Never moves)</option>
                  <option value="kinematic">
                    Kinematic (Script controlled)
                  </option>
                </select>

                <!-- Mass -->
                <div id="physics-mass-group" style="margin-top: 10px">
                  <div class="property-label">Mass (kg)</div>
                  <input
                    type="number"
                    class="property-input"
                    id="physics-mass"
                    value="1.0"
                    step="0.1"
                    min="0.1"
                    onchange="updatePhysicsMass()"
                  />
                </div>

                <!-- Use Gravity -->
                <div class="checkbox-wrapper" style="margin-top: 10px">
                  <input
                    type="checkbox"
                    id="physics-use-gravity"
                    onchange="updatePhysicsGravity()"
                    checked
                  />
                  <label for="physics-use-gravity">Use Gravity</label>
                </div>

                <!-- Friction -->
                <div class="property-label" style="margin-top: 10px">
                  Friction
                </div>
                <input
                  type="range"
                  class="property-input"
                  id="physics-friction"
                  min="0"
                  max="1"
                  step="0.05"
                  value="0.5"
                  oninput="updatePhysicsFriction()"
                />
                <div style="font-size: 11px; color: #888; margin-top: 2px">
                  <span id="physics-friction-value">0.5</span> (0 = ice, 1 =
                  sticky)
                </div>

                <!-- Bounciness (Restitution) -->
                <div class="property-label" style="margin-top: 10px">
                  Bounciness
                </div>
                <input
                  type="range"
                  class="property-input"
                  id="physics-bounciness"
                  min="0"
                  max="1"
                  step="0.05"
                  value="0.3"
                  oninput="updatePhysicsBounciness()"
                />
                <div style="font-size: 11px; color: #888; margin-top: 2px">
                  <span id="physics-bounciness-value">0.3</span> (0 = no bounce,
                  1 = super bouncy)
                </div>

                <!-- Physics Material Presets -->
                <div class="property-label" style="margin-top: 15px">
                  Material Preset
                </div>
                <select
                  class="property-input"
                  id="physics-material-preset"
                  onchange="applyPhysicsMaterialPreset()"
                >
                  <option value="custom">Custom</option>
                  <option value="wood">Wood</option>
                  <option value="metal">Metal</option>
                  <option value="rubber">Rubber</option>
                  <option value="ice">Ice</option>
                  <option value="bouncy">Super Bouncy</option>
                </select>
              </div>
            </div>

            <!-- Collision Callbacks Section -->
            <div class="property-group" id="callbacks-section">
              <div class="property-label">
                <span>Collision Callbacks</span>
                <span style="font-size: 10px; color: #888; font-weight: normal">
                  (JavaScript)</span
                >
              </div>
              <div class="checkbox-wrapper">
                <input
                  type="checkbox"
                  id="has-callbacks"
                  onchange="toggleCallbacks()"
                />
                <label
                  for="has-callbacks"
                  data-tooltip="Add custom JavaScript code that runs on collision events"
                  >Enable Custom Callbacks</label
                >
              </div>

              <!-- Callback Code Editor -->
              <div
                id="callbacks-editor"
                style="margin-top: 10px; display: none"
              >
                <div style="font-size: 11px; color: #aaa; margin-bottom: 8px">
                  Write JavaScript code to run on collision events. Use
                  <code
                    style="
                      background: rgba(255, 255, 255, 0.1);
                      padding: 2px 4px;
                      border-radius: 2px;
                    "
                    >other</code
                  >
                  to access the other object.
                </div>

                <!-- onCollisionEnter -->
                <div style="margin-bottom: 15px">
                  <div class="property-label" style="font-size: 12px">
                    onCollisionEnter
                    <button
                      type="button"
                      onclick="insertCallbackTemplate('enter')"
                      style="
                        float: right;
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        color: #888;
                        padding: 2px 6px;
                        border-radius: 3px;
                        cursor: pointer;
                        font-size: 10px;
                      "
                    >
                      Template
                    </button>
                  </div>
                  <textarea
                    class="property-input"
                    id="callback-enter"
                    rows="3"
                    placeholder="console.log('Hit:', other.name);"
                    style="
                      font-family: 'Courier New', monospace;
                      font-size: 11px;
                      resize: vertical;
                    "
                    oninput="updateCallback('enter')"
                  ></textarea>
                </div>

                <!-- onCollisionStay -->
                <div style="margin-bottom: 15px">
                  <div class="property-label" style="font-size: 12px">
                    onCollisionStay
                    <button
                      type="button"
                      onclick="insertCallbackTemplate('stay')"
                      style="
                        float: right;
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        color: #888;
                        padding: 2px 6px;
                        border-radius: 3px;
                        cursor: pointer;
                        font-size: 10px;
                      "
                    >
                      Template
                    </button>
                  </div>
                  <textarea
                    class="property-input"
                    id="callback-stay"
                    rows="3"
                    placeholder="// Runs every frame while colliding"
                    style="
                      font-family: 'Courier New', monospace;
                      font-size: 11px;
                      resize: vertical;
                    "
                    oninput="updateCallback('stay')"
                  ></textarea>
                </div>

                <!-- onCollisionExit -->
                <div style="margin-bottom: 15px">
                  <div class="property-label" style="font-size: 12px">
                    onCollisionExit
                    <button
                      type="button"
                      onclick="insertCallbackTemplate('exit')"
                      style="
                        float: right;
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        color: #888;
                        padding: 2px 6px;
                        border-radius: 3px;
                        cursor: pointer;
                        font-size: 10px;
                      "
                    >
                      Template
                    </button>
                  </div>
                  <textarea
                    class="property-input"
                    id="callback-exit"
                    rows="3"
                    placeholder="// Runs when collision ends"
                    style="
                      font-family: 'Courier New', monospace;
                      font-size: 11px;
                      resize: vertical;
                    "
                    oninput="updateCallback('exit')"
                  ></textarea>
                </div>

                <!-- Error Display -->
                <div
                  id="callback-error"
                  style="
                    display: none;
                    background: rgba(255, 0, 0, 0.2);
                    border: 1px solid rgba(255, 0, 0, 0.5);
                    padding: 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    margin-top: 10px;
                  "
                >
                  <strong>âš ï¸ Error:</strong>
                  <span id="callback-error-text"></span>
                </div>

                <!-- Available Variables -->
                <div
                  style="
                    margin-top: 15px;
                    padding: 8px;
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 4px;
                    font-size: 10px;
                    color: #888;
                  "
                >
                  <strong>Available in callbacks:</strong><br />
                  â€¢ <code>other</code> - The other object involved in
                  collision<br />
                  â€¢ <code>this</code> - This object (current object)<br />
                  â€¢ <code>collision</code> - Collision data (contact points,
                  normal, etc.)<br />
                  â€¢ All scene objects accessible via global scope
                </div>
              </div>
            </div>

            <div class="property-group">
              <button
                type="button"
                class="btn btn-danger"
                onclick="deleteSelectedObject()"
              >
                <i class="fas fa-trash"></i> Delete Object
              </button>
            </div>
          </div>
        </div>

        <!-- Scene Settings Panel -->
        <div class="sidebar-panel" id="panel-scene">
          <div class="property-group">
            <div class="property-label">Background Color</div>
            <div class="color-picker-wrapper">
              <div
                class="color-preview"
                id="bg-color-preview"
                onclick="document.getElementById('bg-color').click()"
              ></div>
              <input
                type="color"
                id="bg-color"
                value="#2a2a2a"
                oninput="updateBackgroundColor()"
              />
            </div>
          </div>

          <div class="property-group">
            <div class="property-label">Fog</div>
            <div class="checkbox-wrapper">
              <input
                type="checkbox"
                id="fog-enabled"
                checked
                onchange="updateFog()"
              />
              <label for="fog-enabled">Enable Fog</label>
            </div>
            <div class="property-label" style="margin-top: 10px">
              Fog Distance
            </div>
            <input
              type="number"
              class="property-input"
              id="fog-distance"
              value="200"
              oninput="updateFog()"
            />
          </div>

          <div class="property-group">
            <div class="property-label">Grid (Press G to toggle)</div>
            <div class="checkbox-wrapper">
              <input
                type="checkbox"
                id="show-grid-checkbox"
                checked
                onchange="toggleGrid()"
              />
              <label for="show-grid-checkbox">Show Grid</label>
            </div>
          </div>

          <div class="property-group">
            <div class="property-label">Ambient Light Intensity</div>
            <input
              type="range"
              min="0"
              max="2"
              step="0.1"
              value="0.4"
              id="ambient-intensity"
              oninput="updateAmbientLight()"
              style="width: 100%"
            />
          </div>

          <div class="property-group">
            <div class="property-label">Sun Light Intensity</div>
            <input
              type="range"
              min="0"
              max="2"
              step="0.1"
              value="0.8"
              id="sun-intensity"
              oninput="updateSunLight()"
              style="width: 100%"
            />
          </div>

          <div class="property-group">
            <div class="property-label">Spawn Point Info</div>
            <div class="spawn-point-info" id="spawn-info">
              No spawn point in scene. Add one from the Assets panel.
            </div>
          </div>
        </div>

        <!-- Blueprint Panel -->
        <div class="sidebar-panel" id="panel-blueprint">
          <div class="no-selection" id="blueprint-no-selection">
            <i
              class="fas fa-project-diagram"
              style="
                font-size: 32px;
                color: #444;
                margin-bottom: 10px;
                display: block;
              "
            ></i>
            Select an object to create Blueprints
          </div>

          <div id="blueprint-content" style="display: none">
            <div class="property-group">
              <div class="property-label">Blueprint System</div>
              <div class="checkbox-wrapper">
                <input
                  type="checkbox"
                  id="has-blueprint"
                  onchange="toggleBlueprint()"
                />
                <label for="has-blueprint">Enable Blueprint</label>
              </div>
            </div>

            <div id="blueprint-editor" style="display: none">
              <!-- AI Assistant Button -->
              <div class="property-group ai-assistant-group">
                <button
                  type="button"
                  class="btn-ai-assistant"
                  onclick="openBlueprintQuestionnaire()"
                >
                  <span class="ai-icon">ðŸª„</span>
                  <div class="ai-text">
                    <div class="ai-title">Create with AI Assistant</div>
                    <div class="ai-subtitle">
                      Build blueprints by answering questions
                    </div>
                  </div>
                </button>
              </div>

              <!-- Node Palette -->
              <div class="property-group" style="margin-bottom: 10px">
                <div class="property-label" style="margin-bottom: 8px">
                  Add Nodes
                  <button
                    type="button"
                    class="btn btn-secondary"
                    onclick="clearBlueprint()"
                    style="float: right; padding: 4px 8px; font-size: 11px"
                  >
                    <i class="fas fa-trash"></i> Clear All
                  </button>
                </div>

                <!-- Event Nodes -->
                <details style="margin-bottom: 8px">
                  <summary
                    style="
                      background: #2a5a2a;
                      padding: 6px 10px;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                      font-weight: 600;
                    "
                  >
                    ðŸ“ Events
                  </summary>
                  <div
                    class="node-palette"
                    id="event-nodes"
                    style="padding: 8px 0"
                  >
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('On Start')"
                    >
                      ðŸ“ On Start
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('On Collision Enter')"
                    >
                      ðŸ“ On Collision Enter
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('On Trigger Enter')"
                    >
                      ðŸ“ On Trigger Enter
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('On Click')"
                    >
                      ðŸ“ On Click
                    </button>
                  </div>
                </details>

                <!-- Action Nodes -->
                <details style="margin-bottom: 8px">
                  <summary
                    style="
                      background: #2a3a5a;
                      padding: 6px 10px;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                      font-weight: 600;
                    "
                  >
                    âš¡ Actions
                  </summary>
                  <div
                    class="node-palette"
                    id="action-nodes"
                    style="padding: 8px 0"
                  >
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Change Color')"
                    >
                      âš¡ Change Color
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Move Object')"
                    >
                      âš¡ Move Object
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Destroy Object')"
                    >
                      âš¡ Destroy Object
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Log Message')"
                    >
                      âš¡ Log Message
                    </button>
                  </div>
                </details>

                <!-- Flow Nodes -->
                <details style="margin-bottom: 8px">
                  <summary
                    style="
                      background: #5a4a2a;
                      padding: 6px 10px;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 12px;
                      font-weight: 600;
                    "
                  >
                    ðŸ”€ Flow Control
                  </summary>
                  <div
                    class="node-palette"
                    id="flow-nodes"
                    style="padding: 8px 0"
                  >
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Branch')"
                    >
                      ðŸ”€ Branch (If)
                    </button>
                    <button
                      type="button"
                      class="node-palette-btn"
                      onclick="addBlueprintNode('Delay')"
                    >
                      ðŸ”€ Delay
                    </button>
                  </div>
                </details>
              </div>

              <!-- Blueprint Canvas -->
              <div class="property-group">
                <div class="property-label" style="margin-bottom: 8px">
                  Blueprint Graph
                  <button
                    type="button"
                    class="btn"
                    onclick="testBlueprint()"
                    style="float: right; padding: 4px 8px; font-size: 11px"
                  >
                    <i class="fas fa-play"></i> Test
                  </button>
                </div>
                <div
                  id="blueprint-canvas-container"
                  style="
                    background-color: #1a1a1a;
                    background-image:
                      linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                      linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                      linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                      linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
                    background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
                    background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
                    border: 2px solid #444;
                    border-radius: 6px;
                    height: 400px;
                    overflow: auto;
                    position: relative;
                    cursor: grab;
                    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
                  "
                >
                  <svg
                    id="blueprint-canvas"
                    style="
                      width: 100%;
                      height: 100%;
                      min-width: 800px;
                      min-height: 600px;
                    "
                  >
                    <!-- Connection lines will be drawn here -->
                    <g id="blueprint-connections"></g>
                    <!-- Nodes will be rendered here -->
                    <foreignObject
                      id="blueprint-nodes"
                      x="0"
                      y="0"
                      width="100%"
                      height="100%"
                    >
                      <div
                        xmlns="http://www.w3.org/1999/xhtml"
                        style="width: 100%; height: 100%; position: relative"
                      >
                        <!-- Nodes rendered dynamically -->
                      </div>
                    </foreignObject>
                  </svg>
                </div>

                <!-- Blueprint Info -->
                <div
                  style="
                    margin-top: 8px;
                    font-size: 11px;
                    color: #888;
                    padding: 8px;
                    background: #222;
                    border-radius: 4px;
                  "
                >
                  <strong>Tips:</strong><br />
                  â€¢ Click nodes from palette to add<br />
                  â€¢ Drag pins to create connections<br />
                  â€¢ Right-click node to delete<br />
                  â€¢ Test runs the blueprint
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Game Panel -->
        <div class="sidebar-panel" id="panel-game">
          <!-- Game Hub Header -->
          <div style="background: linear-gradient(135deg, #2a2a5a 0%, #1f1f4a 100%); padding: 15px; border-bottom: 2px solid #444; margin: -15px -15px 15px -15px;">
            <div style="font-size: 18px; font-weight: 700; color: white; margin-bottom: 5px;">
              ðŸŽ® Game Development Hub
            </div>
            <div style="font-size: 11px; color: #aaa;">
              Professional Game Builder with Visual Blueprints
            </div>
          </div>

          <!-- Sub-Navigation Tabs -->
          <div style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #333; padding-bottom: 5px;">
            <button type="button" class="game-subtab active" onclick="switchGameSubTab('features')" data-subtab="features">
              <i class="fas fa-puzzle-piece"></i> Features
            </button>
            <button type="button" class="game-subtab" onclick="switchGameSubTab('blueprints')" data-subtab="blueprints">
              <i class="fas fa-project-diagram"></i> Blueprints
            </button>
            <button type="button" class="game-subtab" onclick="switchGameSubTab('docs')" data-subtab="docs">
              <i class="fas fa-book"></i> Docs
            </button>
          </div>

          <!-- Features Sub-Panel -->
          <div class="game-subpanel active" id="game-subpanel-features">
            <!-- Game Template Selection -->
            <div id="game-template-selector" style="margin-bottom: 20px;">
              <div class="property-label" style="margin-bottom: 10px;">
                Choose Game Template:
              </div>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('fps')" data-template="fps">
                  <i class="fas fa-crosshairs"></i><br>
                  <span style="font-size: 11px;">FPS</span>
                </button>
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('platformer')" data-template="platformer">
                  <i class="fas fa-running"></i><br>
                  <span style="font-size: 11px;">Platformer</span>
                </button>
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('adventure')" data-template="adventure">
                  <i class="fas fa-map"></i><br>
                  <span style="font-size: 11px;">Adventure</span>
                </button>
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('racing')" data-template="racing">
                  <i class="fas fa-flag-checkered"></i><br>
                  <span style="font-size: 11px;">Racing</span>
                </button>
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('puzzle')" data-template="puzzle">
                  <i class="fas fa-puzzle-piece"></i><br>
                  <span style="font-size: 11px;">Puzzle</span>
                </button>
                <button type="button" class="game-template-btn" onclick="selectGameTemplate('custom')" data-template="custom">
                  <i class="fas fa-plus-circle"></i><br>
                  <span style="font-size: 11px;">Custom</span>
                </button>
              </div>
            </div>

            <!-- Active Blueprints -->
            <div id="active-blueprints-section" style="display: none;">
              <div class="property-label" style="margin-bottom: 10px;">
                âœ… Active Blueprints
              </div>
              <div id="active-blueprints-list" style="margin-bottom: 20px;">
                <!-- Active blueprint cards will appear here -->
              </div>

              <!-- Smart Suggestions -->
              <div class="property-label" style="margin-bottom: 10px;">
                ðŸ’¡ Smart Suggestions
              </div>
              <div id="smart-suggestions-list" style="margin-bottom: 20px;">
                <!-- Smart suggestion cards will appear here -->
              </div>

              <!-- Inactive Blueprints -->
              <div class="property-label" style="margin-bottom: 10px;">
                ðŸ“‹ Available Blueprints
              </div>
              <div id="inactive-blueprints-list">
                <!-- Inactive blueprint cards will appear here -->
              </div>
            </div>
          </div>

          <!-- Blueprints Sub-Panel -->
          <div class="game-subpanel" id="game-subpanel-blueprints">
            <div class="property-label" style="margin-bottom: 10px;">
              Visual Blueprint Editor
            </div>

            <div style="background: #222; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
              <div style="font-size: 12px; color: #aaa; margin-bottom: 8px;">
                <strong style="color: #00aaff;">Game Controller Object:</strong>
              </div>
              <div id="game-controller-status" style="font-size: 11px; color: #888;">
                No game controller. Add a feature to create one.
              </div>
            </div>

            <!-- Embedded Blueprint Canvas -->
            <div class="property-label" style="margin-bottom: 8px;">
              Blueprint Graph
              <button type="button" class="btn" onclick="testGameBlueprints()" style="float: right; padding: 4px 8px; font-size: 11px;">
                <i class="fas fa-play"></i> Test All
              </button>
            </div>
            <div id="game-blueprint-canvas-container" style="background-color: #1a1a1a; background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px); background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px; border: 2px solid #444; border-radius: 6px; height: 350px; overflow: auto; position: relative; cursor: grab; box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);">
              <svg id="game-blueprint-canvas" style="width: 100%; height: 100%; min-width: 800px; min-height: 600px;">
                <g id="game-blueprint-connections"></g>
                <foreignObject id="game-blueprint-nodes" x="0" y="0" width="100%" height="100%">
                  <div xmlns="http://www.w3.org/1999/xhtml" style="width: 100%; height: 100%; position: relative;"></div>
                </foreignObject>
              </svg>
            </div>

            <!-- Blueprint Node Palette -->
            <div style="margin-top: 15px;">
              <div class="property-label" style="margin-bottom: 8px;">
                Add Blueprint Nodes
              </div>
              <details open style="margin-bottom: 8px;">
                <summary style="background: #2a5a2a; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
                  ðŸ“ Events
                </summary>
                <div style="padding: 8px 0;">
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('On Start')">ðŸ“ On Start</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('On Collision Enter')">ðŸ“ On Collision Enter</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('On Trigger Enter')">ðŸ“ On Trigger Enter</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('On Click')">ðŸ“ On Click</button>
                </div>
              </details>

              <details style="margin-bottom: 8px;">
                <summary style="background: #2a3a5a; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
                  âš¡ Actions
                </summary>
                <div style="padding: 8px 0;">
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Change Color')">âš¡ Change Color</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Move Object')">âš¡ Move Object</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Destroy Object')">âš¡ Destroy Object</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Log Message')">âš¡ Log Message</button>
                </div>
              </details>

              <details style="margin-bottom: 8px;">
                <summary style="background: #5a4a2a; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
                  ðŸ”€ Flow Control
                </summary>
                <div style="padding: 8px 0;">
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Branch')">ðŸ”€ Branch (If)</button>
                  <button type="button" class="node-palette-btn" onclick="addGameBlueprintNode('Delay')">ðŸ”€ Delay</button>
                </div>
              </details>
            </div>

            <div style="margin-top: 10px; font-size: 11px; color: #888; padding: 8px; background: #222; border-radius: 4px;">
              <strong>Tips:</strong><br>
              â€¢ Add features from Features tab to auto-generate blueprints<br>
              â€¢ Drag nodes to reposition them<br>
              â€¢ Click pins to create connections<br>
              â€¢ Right-click nodes to delete
            </div>
          </div>

          <!-- Documentation Sub-Panel -->
          <div class="game-subpanel" id="game-subpanel-docs">
            <div class="property-label" style="margin-bottom: 10px;">
              ðŸ“š Game Development System Documentation
            </div>

            <div style="background: #222; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #00aaff;">
              <div style="font-size: 14px; font-weight: 700; color: #00aaff; margin-bottom: 10px;">
                ðŸŽ® Welcome to the Game Development Hub
              </div>
              <div style="font-size: 12px; color: #ccc; line-height: 1.6;">
                A professional, visual game development system combining feature-based development with node-based blueprint programming.
              </div>
            </div>

            <!-- Quick Start Guide -->
            <details open style="margin-bottom: 15px;">
              <summary style="background: linear-gradient(135deg, #2a5a2a 0%, #1f4a1f 100%); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; color: white;">
                ðŸš€ Quick Start Guide
              </summary>
              <div style="padding: 12px; background: #1a1a1a; border-radius: 0 0 6px 6px; font-size: 11px; color: #aaa; line-height: 1.8;">
                <strong style="color: #00ff88;">Step 1: Choose a Template</strong><br>
                Go to the <strong>Features</strong> tab and select a game type (FPS, Platformer, etc.). This pre-configures starter blueprints.
                <br><br>
                <strong style="color: #00ff88;">Step 2: Add Features</strong><br>
                Click on <strong style="color: #ffaa00;">Smart Suggestions</strong> or <strong>Available Blueprints</strong> to add game features. Each feature:<br>
                â€¢ Spawns objects in your 3D scene<br>
                â€¢ Creates visual blueprint nodes<br>
                â€¢ Auto-connects logic flow
                <br><br>
                <strong style="color: #00ff88;">Step 3: View & Edit Blueprints</strong><br>
                Switch to the <strong>Blueprints</strong> tab to see the visual programming graph. You can:<br>
                â€¢ Add custom nodes from the palette<br>
                â€¢ Connect nodes by dragging between pins<br>
                â€¢ Edit node parameters<br>
                â€¢ Test blueprint logic
                <br><br>
                <strong style="color: #00ff88;">Step 4: Test Your Game</strong><br>
                Click <strong>Play Mode</strong> in the top toolbar to test your game in first-person mode!
              </div>
            </details>

            <!-- Features Reference -->
            <details style="margin-bottom: 15px;">
              <summary style="background: linear-gradient(135deg, #2a3a5a 0%, #1f2f4a 100%); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; color: white;">
                ðŸ§© Features Reference
              </summary>
              <div style="padding: 12px; background: #1a1a1a; border-radius: 0 0 6px 6px; font-size: 11px; color: #aaa; line-height: 1.8;">
                <strong style="color: #00aaff;">Movement</strong> - Player WASD controls with collision<br>
                <strong style="color: #00aaff;">Jump</strong> - Space to jump mechanic<br>
                <strong style="color: #00aaff;">Gravity</strong> - Realistic physics simulation<br>
                <strong style="color: #00aaff;">Collectibles</strong> - Spawns 5 rotating golden coins<br>
                <strong style="color: #00aaff;">Enemies</strong> - Spawns 3 AI-controlled red cubes<br>
                <strong style="color: #00aaff;">Shooting</strong> - Click-to-shoot projectile system<br>
                <strong style="color: #00aaff;">Score</strong> - Track and display player score<br>
                <strong style="color: #00aaff;">Health</strong> - Health/damage system
              </div>
            </details>

            <!-- Blueprint Nodes Reference -->
            <details style="margin-bottom: 15px;">
              <summary style="background: linear-gradient(135deg, #5a4a2a 0%, #4a3a1f 100%); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; color: white;">
                ðŸ“ Blueprint Nodes Reference
              </summary>
              <div style="padding: 12px; background: #1a1a1a; border-radius: 0 0 6px 6px; font-size: 11px; color: #aaa; line-height: 1.8;">
                <strong style="color: #2a5a2a; background: #2a5a2a; padding: 2px 6px; border-radius: 3px;">EVENTS</strong> (Green Nodes)<br>
                â€¢ <strong>On Start</strong> - Triggers when game starts<br>
                â€¢ <strong>On Collision Enter</strong> - Triggers on physics collision<br>
                â€¢ <strong>On Trigger Enter</strong> - Triggers when entering trigger zone<br>
                â€¢ <strong>On Click</strong> - Triggers on mouse click
                <br><br>
                <strong style="color: #2a3a5a; background: #2a3a5a; padding: 2px 6px; border-radius: 3px;">ACTIONS</strong> (Blue Nodes)<br>
                â€¢ <strong>Change Color</strong> - Modify object color<br>
                â€¢ <strong>Move Object</strong> - Translate object position<br>
                â€¢ <strong>Destroy Object</strong> - Remove from scene<br>
                â€¢ <strong>Log Message</strong> - Console output
                <br><br>
                <strong style="color: #5a4a2a; background: #5a4a2a; padding: 2px 6px; border-radius: 3px;">FLOW</strong> (Orange Nodes)<br>
                â€¢ <strong>Branch</strong> - If/else conditional logic<br>
                â€¢ <strong>Delay</strong> - Wait before executing next node
              </div>
            </details>

            <!-- Advanced Tips -->
            <details style="margin-bottom: 15px;">
              <summary style="background: linear-gradient(135deg, #5a2a5a 0%, #4a1f4a 100%); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; color: white;">
                ðŸ’¡ Advanced Tips & Tricks
              </summary>
              <div style="padding: 12px; background: #1a1a1a; border-radius: 0 0 6px 6px; font-size: 11px; color: #aaa; line-height: 1.8;">
                <strong style="color: #ffaa00;">Smart Suggestions System</strong><br>
                The system intelligently suggests features based on what's already active. For example:<br>
                â€¢ If you have Movement â†’ Suggests Enemies<br>
                â€¢ If you have Shooting â†’ Suggests Crosshair<br>
                â€¢ If you have Jump â†’ Suggests Collectibles
                <br><br>
                <strong style="color: #ffaa00;">Game Controller Object</strong><br>
                When you add your first feature, a glowing green sphere called "ðŸŽ® Game Controller" is created. This object holds ALL your game's blueprint logic. Select it to view/edit blueprints.
                <br><br>
                <strong style="color: #ffaa00;">Auto-Generated Blueprints</strong><br>
                Each feature automatically creates connected blueprint nodes. You can extend these by adding custom nodes from the palette in the Blueprints tab.
                <br><br>
                <strong style="color: #ffaa00;">Keyboard Shortcuts</strong><br>
                â€¢ <strong>G</strong> - Toggle grid visibility<br>
                â€¢ <strong>W</strong> - Move tool<br>
                â€¢ <strong>E</strong> - Rotate tool<br>
                â€¢ <strong>R</strong> - Scale tool<br>
                â€¢ <strong>Ctrl+Z</strong> - Undo<br>
                â€¢ <strong>Ctrl+Y</strong> - Redo<br>
                â€¢ <strong>Del</strong> - Delete selected
              </div>
            </details>

            <!-- System Architecture -->
            <details style="margin-bottom: 15px;">
              <summary style="background: linear-gradient(135deg, #404040 0%, #2a2a2a 100%); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; color: white;">
                ðŸ—ï¸ System Architecture
              </summary>
              <div style="padding: 12px; background: #1a1a1a; border-radius: 0 0 6px 6px; font-size: 11px; color: #aaa; line-height: 1.8;">
                <strong style="color: #00aaff;">Three-Layer Architecture:</strong>
                <br><br>
                <strong>1. Feature Layer (Game Tab)</strong><br>
                High-level game features that users click to add. Each feature is a pre-configured bundle of objects + blueprints.
                <br><br>
                <strong>2. Blueprint Layer (Visual Programming)</strong><br>
                Node-based visual programming system. Features auto-generate blueprint nodes, which can be customized and extended.
                <br><br>
                <strong>3. Runtime Layer (Play Mode)</strong><br>
                When you click Play Mode, blueprints are executed in real-time to control game behavior.
              </div>
            </details>

            <div style="margin-top: 20px; padding: 12px; background: linear-gradient(135deg, #1a3a2a 0%, #1f2f1f 100%); border-radius: 6px; border: 2px solid #00ff88;">
              <div style="font-size: 12px; font-weight: 700; color: #00ff88; margin-bottom: 8px;">
                âœ¨ You're Ready to Build!
              </div>
              <div style="font-size: 11px; color: #aaa;">
                Head to the <strong style="color: white;">Features</strong> tab and start creating your game. No coding required!
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Blueprint Questionnaire Modal -->
    <div id="blueprint-questionnaire-modal" class="questionnaire-modal">
      <div
        class="questionnaire-overlay"
        onclick="closeBlueprintQuestionnaire()"
      ></div>
      <div class="questionnaire-container">
        <!-- Header -->
        <div class="questionnaire-header">
          <div class="questionnaire-title">
            <span class="questionnaire-icon">ðŸª„</span>
            Blueprint AI Assistant
          </div>
          <button
            type="button"
            class="questionnaire-close"
            onclick="closeBlueprintQuestionnaire()"
          >
            Ã—
          </button>
        </div>

        <!-- Progress Bar -->
        <div class="questionnaire-progress-container">
          <div
            class="questionnaire-progress-bar"
            id="questionnaire-progress-bar"
          ></div>
          <div
            class="questionnaire-progress-text"
            id="questionnaire-progress-text"
          >
            Step 1 of 4
          </div>
        </div>

        <!-- Content Area -->
        <div class="questionnaire-content" id="questionnaire-content">
          <!-- Questions will be dynamically inserted here -->
        </div>

        <!-- Navigation -->
        <div class="questionnaire-navigation">
          <button
            type="button"
            class="btn-questionnaire-back"
            id="btn-questionnaire-back"
            onclick="questionnaireGoBack()"
          >
            â† Back
          </button>
          <button
            type="button"
            class="btn-questionnaire-next"
            id="btn-questionnaire-next"
            onclick="questionnaireNext()"
          >
            Next â†’
          </button>
        </div>
      </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- Cannon.js Physics Library (Browser/UMD build) -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
      // ============================================
      // GLOBAL VARIABLES
      // ============================================
      let scene, camera, renderer;
      let orbitControls, transformControls;
      let selectedObject = null;
      let objectHighlight = null;
      let sceneObjects = [];
      let colliderObjects = [];
      let colliderHelpers = [];
      let showColliderHelpers = false;

      // Physics (Cannon.js)
      let physicsWorld = null;
      let physicsBodies = new Map(); // Maps THREE.Object3D.uuid -> CANNON.Body
      let physicsEnabled = true;
      let physicsTimeScale = 1.0; // For slow-motion/fast-forward
      const DEFAULT_GRAVITY = -9.82;

      // Scene elements
      let gridHelper, ambientLight, directionalLight;
      let spawnPoint = null;

      // Undo/Redo
      const MAX_UNDO_HISTORY = 50;
      let undoStack = [];
      let redoStack = [];

      // Raycasting
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();

      // Play mode
      let isPlayMode = false;
      let playModeCamera, editorCamera;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      let velocity = new THREE.Vector3();
      let direction = new THREE.Vector3();
      let euler = new THREE.Euler(0, 0, 0, "YXZ");
      let isLocked = false;

      // ============================================
      // INITIALIZATION
      // ============================================
      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);
        scene.fog = new THREE.Fog(0x2a2a2a, 0, 200);

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(8, 6, 8);
        camera.lookAt(0, 0, 0);
        editorCamera = camera;

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;

        setupLighting();
        setupGround();
        initPhysicsWorld();
        loadEditorControls();

        // Events
        window.addEventListener("resize", onWindowResize);
        renderer.domElement.addEventListener("click", onCanvasClick);
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        document
          .getElementById("mode-toggle")
          .addEventListener("click", togglePlayMode);

        animate();
      }

      function setupLighting() {
        ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        ambientLight.name = "_AmbientLight";
        scene.add(ambientLight);

        directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.name = "_DirectionalLight";
        scene.add(directionalLight);
      }

      function setupGround() {
        gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x2a2a2a);
        gridHelper.name = "_GridHelper";
        gridHelper.visible = true;
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(5);
        axesHelper.name = "_AxesHelper";
        scene.add(axesHelper);

        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.8,
          metalness: 0.2,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.01;
        ground.receiveShadow = true;
        ground.name = "_Ground";
        scene.add(ground);

        // Add ground to colliders
        addCollider(ground);
      }

      // ============================================
      // PHYSICS SYSTEM (CANNON.JS)
      // ============================================

      function initPhysicsWorld() {
        // Create physics world
        physicsWorld = new CANNON.World({
          gravity: new CANNON.Vec3(0, DEFAULT_GRAVITY, 0),
        });

        // Set solver iterations for stability
        physicsWorld.solver.iterations = 10;

        // Use SAPBroadphase for better performance
        physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);

        // Allow sleeping for performance
        physicsWorld.allowSleep = true;

        // Create ground physics body
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
          mass: 0, // Static body
          shape: groundShape,
          material: new CANNON.Material({ friction: 0.5, restitution: 0.3 }),
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to horizontal
        physicsWorld.addBody(groundBody);

        console.log("âœ… Physics World initialized (Cannon.js)");
      }

      function updateGravity(x, y, z) {
        if (!physicsWorld) return;
        physicsWorld.gravity.set(x, y, z);
        console.log(`Gravity set to (${x}, ${y}, ${z})`);
      }

      function setPhysicsTimeScale(scale) {
        physicsTimeScale = Math.max(0.1, Math.min(scale, 5.0)); // Clamp between 0.1x and 5.0x
        console.log(`Physics time scale: ${physicsTimeScale}x`);
      }

      function togglePhysics() {
        physicsEnabled = !physicsEnabled;
        console.log(`Physics ${physicsEnabled ? "enabled" : "disabled"}`);
      }

      // ============================================
      // RIGIDBODY SYSTEM
      // ============================================

      function toggleObjectPhysics() {
        if (!selectedObject) return;

        const enabled = document.getElementById("has-physics").checked;
        const optionsDiv = document.getElementById("physics-options");

        if (enabled) {
          // Initialize physics properties
          selectedObject.userData.hasPhysics = true;
          selectedObject.userData.bodyType = "dynamic";
          selectedObject.userData.mass = 1.0;
          selectedObject.userData.friction = 0.5;
          selectedObject.userData.restitution = 0.3;
          selectedObject.userData.useGravity = true;

          // Create physics body
          createPhysicsBody(selectedObject);

          // Show UI options
          optionsDiv.style.display = "block";
          updatePhysicsUI();
        } else {
          // Remove physics
          selectedObject.userData.hasPhysics = false;
          removePhysicsBody(selectedObject);

          // Hide UI options
          optionsDiv.style.display = "none";
        }
      }

      function createPhysicsBody(obj) {
        if (!physicsWorld || !obj.geometry) return;

        // Remove existing body if any
        removePhysicsBody(obj);

        const userData = obj.userData;
        const bodyType = userData.bodyType || "dynamic";
        const mass = bodyType === "dynamic" ? userData.mass || 1.0 : 0;

        // Create shape based on collision shape or geometry
        let shape;
        const collisionShape = userData.collisionShape || "box";

        switch (collisionShape) {
          case "sphere":
            const box = new THREE.Box3().setFromObject(obj);
            const size = box.getSize(new THREE.Vector3());
            const radius = Math.max(size.x, size.y, size.z) / 2;
            shape = new CANNON.Sphere(radius);
            break;
          case "capsule":
            // Cannon.js doesn't have capsule, use cylinder
            const boxCap = new THREE.Box3().setFromObject(obj);
            const sizeCap = boxCap.getSize(new THREE.Vector3());
            const height = Math.max(sizeCap.x, sizeCap.y, sizeCap.z);
            const radiusCap =
              (Math.min(sizeCap.x, sizeCap.z) +
                Math.max(sizeCap.x, sizeCap.z)) /
              4;
            shape = new CANNON.Cylinder(radiusCap, radiusCap, height, 8);
            break;
          case "box":
          default:
            const boxDef = new THREE.Box3().setFromObject(obj);
            const sizeDef = boxDef.getSize(new THREE.Vector3());
            shape = new CANNON.Box(
              new CANNON.Vec3(sizeDef.x / 2, sizeDef.y / 2, sizeDef.z / 2)
            );
            break;
        }

        // Create physics body
        const body = new CANNON.Body({
          mass: mass,
          shape: shape,
          position: new CANNON.Vec3(
            obj.position.x,
            obj.position.y,
            obj.position.z
          ),
          quaternion: new CANNON.Quaternion(
            obj.quaternion.x,
            obj.quaternion.y,
            obj.quaternion.z,
            obj.quaternion.w
          ),
          material: new CANNON.Material({
            friction: userData.friction || 0.5,
            restitution: userData.restitution || 0.3,
          }),
        });

        // Apply gravity setting
        body.allowGravity = userData.useGravity !== false;

        // Store reference to THREE.js object on physics body
        body.threejsObject = obj;

        // Add collision event listeners for callbacks
        body.addEventListener("collide", (event) => {
          const otherBody = event.body;
          const otherObj = otherBody.threejsObject;

          if (otherObj) {
            // Track collisions
            if (!obj.userData.physicsCollisions) {
              obj.userData.physicsCollisions = new Set();
            }

            const isNewCollision = !obj.userData.physicsCollisions.has(
              otherObj.uuid
            );

            if (isNewCollision) {
              // onCollisionEnter
              obj.userData.physicsCollisions.add(otherObj.uuid);
              executeCallback(obj, "enter", otherObj, event.contact);

              // Execute Blueprint on collision enter
              if (obj.userData.blueprint && obj.userData.blueprint.enabled) {
                executeBlueprint(obj, "On Collision Enter", {
                  otherObject: otherObj,
                });
              }
            } else {
              // onCollisionStay
              executeCallback(obj, "stay", otherObj, event.contact);
            }
          }
        });

        // Add to physics world
        physicsWorld.addBody(body);
        physicsBodies.set(obj.uuid, body);

        console.log(
          `Physics body created for ${
            obj.name || "Unnamed"
          } (${bodyType}, mass: ${mass})`
        );
      }

      function removePhysicsBody(obj) {
        if (!physicsWorld) return;

        const body = physicsBodies.get(obj.uuid);
        if (body) {
          physicsWorld.removeBody(body);
          physicsBodies.delete(obj.uuid);
        }
      }

      function updatePhysicsBodyType() {
        if (!selectedObject) return;

        const bodyType = document.getElementById("physics-body-type").value;
        selectedObject.userData.bodyType = bodyType;

        // Show/hide mass for non-dynamic bodies
        document.getElementById("physics-mass-group").style.display =
          bodyType === "dynamic" ? "block" : "none";

        // Recreate physics body
        if (selectedObject.userData.hasPhysics) {
          createPhysicsBody(selectedObject);
        }

        console.log(`Body type: ${bodyType}`);
      }

      function updatePhysicsMass() {
        if (!selectedObject) return;

        const mass =
          parseFloat(document.getElementById("physics-mass").value) || 1.0;
        selectedObject.userData.mass = mass;

        // Update physics body
        const body = physicsBodies.get(selectedObject.uuid);
        if (body && selectedObject.userData.bodyType === "dynamic") {
          body.mass = mass;
          body.updateMassProperties();
        }
      }

      function updatePhysicsGravity() {
        if (!selectedObject) return;

        const useGravity = document.getElementById(
          "physics-use-gravity"
        ).checked;
        selectedObject.userData.useGravity = useGravity;

        // Update physics body
        const body = physicsBodies.get(selectedObject.uuid);
        if (body) {
          body.allowGravity = useGravity;
        }
      }

      function updatePhysicsFriction() {
        if (!selectedObject) return;

        const friction = parseFloat(
          document.getElementById("physics-friction").value
        );
        selectedObject.userData.friction = friction;
        document.getElementById("physics-friction-value").textContent =
          friction.toFixed(2);

        // Update physics body material
        const body = physicsBodies.get(selectedObject.uuid);
        if (body && body.material) {
          body.material.friction = friction;
        }
      }

      function updatePhysicsBounciness() {
        if (!selectedObject) return;

        const bounciness = parseFloat(
          document.getElementById("physics-bounciness").value
        );
        selectedObject.userData.restitution = bounciness;
        document.getElementById("physics-bounciness-value").textContent =
          bounciness.toFixed(2);

        // Update physics body material
        const body = physicsBodies.get(selectedObject.uuid);
        if (body && body.material) {
          body.material.restitution = bounciness;
        }
      }

      function applyPhysicsMaterialPreset() {
        if (!selectedObject) return;

        const preset = document.getElementById("physics-material-preset").value;

        const presets = {
          wood: { friction: 0.4, restitution: 0.2 },
          metal: { friction: 0.3, restitution: 0.4 },
          rubber: { friction: 0.8, restitution: 0.9 },
          ice: { friction: 0.05, restitution: 0.1 },
          bouncy: { friction: 0.5, restitution: 0.95 },
        };

        if (presets[preset]) {
          const { friction, restitution } = presets[preset];

          // Update sliders
          document.getElementById("physics-friction").value = friction;
          document.getElementById("physics-bounciness").value = restitution;
          document.getElementById("physics-friction-value").textContent =
            friction.toFixed(2);
          document.getElementById("physics-bounciness-value").textContent =
            restitution.toFixed(2);

          // Update object data
          selectedObject.userData.friction = friction;
          selectedObject.userData.restitution = restitution;

          // Update physics body
          const body = physicsBodies.get(selectedObject.uuid);
          if (body && body.material) {
            body.material.friction = friction;
            body.material.restitution = restitution;
          }

          console.log(`Applied ${preset} material preset`);
        }
      }

      function updatePhysicsUI() {
        if (!selectedObject) return;

        const userData = selectedObject.userData;

        document.getElementById("physics-body-type").value =
          userData.bodyType || "dynamic";
        document.getElementById("physics-mass").value = userData.mass || 1.0;
        document.getElementById("physics-use-gravity").checked =
          userData.useGravity !== false;
        document.getElementById("physics-friction").value =
          userData.friction || 0.5;
        document.getElementById("physics-bounciness").value =
          userData.restitution || 0.3;
        document.getElementById("physics-friction-value").textContent = (
          userData.friction || 0.5
        ).toFixed(2);
        document.getElementById("physics-bounciness-value").textContent = (
          userData.restitution || 0.3
        ).toFixed(2);

        // Show/hide mass for non-dynamic bodies
        document.getElementById("physics-mass-group").style.display =
          userData.bodyType === "dynamic" ? "block" : "none";
      }

      // ============================================
      // COLLISION CALLBACKS SYSTEM
      // ============================================

      function toggleCallbacks() {
        if (!selectedObject) return;

        const enabled = document.getElementById("has-callbacks").checked;
        const editorDiv = document.getElementById("callbacks-editor");

        if (enabled) {
          selectedObject.userData.hasCallbacks = true;
          selectedObject.userData.callbacks = selectedObject.userData
            .callbacks || {
            enter: "",
            stay: "",
            exit: "",
          };

          // Show editor and load code
          editorDiv.style.display = "block";
          loadCallbacksUI();
        } else {
          selectedObject.userData.hasCallbacks = false;
          editorDiv.style.display = "none";
        }
      }

      function updateCallback(type) {
        if (!selectedObject || !selectedObject.userData.callbacks) return;

        const code = document.getElementById(`callback-${type}`).value;
        selectedObject.userData.callbacks[type] = code;

        // Try to compile/validate the code
        try {
          if (code.trim()) {
            // Test compile the function
            new Function("other", "collision", code);
          }
          hideCallbackError();
        } catch (error) {
          showCallbackError(`${type}: ${error.message}`);
        }
      }

      function loadCallbacksUI() {
        if (!selectedObject || !selectedObject.userData.callbacks) return;

        const callbacks = selectedObject.userData.callbacks;
        document.getElementById("callback-enter").value = callbacks.enter || "";
        document.getElementById("callback-stay").value = callbacks.stay || "";
        document.getElementById("callback-exit").value = callbacks.exit || "";
      }

      function insertCallbackTemplate(type) {
        const templates = {
          enter: `// Example: Log collision and change color
console.log('Collision with:', other.name);
this.material.color.setHex(0xff0000);`,

          stay: `// Example: Apply continuous damage
if (other.userData.health) {
    other.userData.health -= 0.1;
    console.log(other.name + ' health:', other.userData.health);
}`,

          exit: `// Example: Reset color when collision ends
this.material.color.setHex(0x00ff00);
console.log('No longer colliding with:', other.name);`,
        };

        if (templates[type]) {
          document.getElementById(`callback-${type}`).value = templates[type];
          updateCallback(type);
        }
      }

      function showCallbackError(message) {
        const errorDiv = document.getElementById("callback-error");
        const errorText = document.getElementById("callback-error-text");
        errorText.textContent = message;
        errorDiv.style.display = "block";
      }

      function hideCallbackError() {
        document.getElementById("callback-error").style.display = "none";
      }

      // Execute a callback safely with error handling
      function executeCallback(obj, type, other, collision) {
        if (!obj || !obj.userData.hasCallbacks || !obj.userData.callbacks)
          return;

        const code = obj.userData.callbacks[type];
        if (!code || !code.trim()) return;

        try {
          // Create function with 'this' context = obj, and parameters
          const func = new Function("other", "collision", code);
          func.call(obj, other, collision);
        } catch (error) {
          console.error(
            `Callback error in ${obj.name || "Unnamed"}.on${type}:`,
            error.message
          );
        }
      }

      function toggleGrid() {
        if (gridHelper) {
          gridHelper.visible = !gridHelper.visible;
          const checkbox = document.getElementById("show-grid-checkbox");
          if (checkbox) {
            checkbox.checked = gridHelper.visible;
          }
          showNotification(gridHelper.visible ? "Grid shown" : "Grid hidden");
        }
      }

      function loadEditorControls() {
        const orbitScript = document.createElement("script");
        orbitScript.src =
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js";
        orbitScript.onload = () => {
          orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
          orbitControls.enableDamping = true;
          orbitControls.dampingFactor = 0.15;
          orbitControls.screenSpacePanning = true;
          orbitControls.minDistance = 1;
          orbitControls.maxDistance = 200;
          loadTransformControls();
        };
        document.head.appendChild(orbitScript);

        // Load GLTF Loader
        const gltfScript = document.createElement("script");
        gltfScript.src =
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js";
        document.head.appendChild(gltfScript);
      }

      function loadTransformControls() {
        const transformScript = document.createElement("script");
        transformScript.src =
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js";
        transformScript.onload = () => {
          transformControls = new THREE.TransformControls(
            camera,
            renderer.domElement
          );
          transformControls.setMode("translate");
          transformControls.setSize(1.2);
          scene.add(transformControls);

          transformControls.addEventListener("dragging-changed", (event) => {
            orbitControls.enabled = !event.value;
            if (!event.value && selectedObject) {
              saveUndoState(selectedObject, "transform");
              updatePropertiesPanel();
            }
          });

          transformControls.addEventListener("change", () => {
            if (objectHighlight && selectedObject) {
              objectHighlight.update();
            }
            if (selectedObject && selectedObject.userData.isSpawnPoint) {
              updateSpawnInfo();
            }
          });
        };
        document.head.appendChild(transformScript);
      }

      // ============================================
      // ASSET CREATION
      // ============================================
      function createAsset(type) {
        let geometry, material, object;

        switch (type) {
          case "box":
            geometry = new THREE.BoxGeometry(2, 2, 2);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Cube";
            break;

          case "sphere":
            geometry = new THREE.SphereGeometry(1, 32, 32);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Sphere";
            break;

          case "cylinder":
            geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Cylinder";
            break;

          case "plane":
            geometry = new THREE.PlaneGeometry(4, 4);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
              side: THREE.DoubleSide,
            });
            object = new THREE.Mesh(geometry, material);
            object.receiveShadow = true;
            object.castShadow = true;
            object.name = "Plane";
            break;

          case "cone":
            geometry = new THREE.ConeGeometry(1, 2, 32);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Cone";
            break;

          case "torus":
            geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
            material = new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              roughness: 0.5,
              metalness: 0.5,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Torus";
            break;

          case "wall":
            geometry = new THREE.BoxGeometry(10, 5, 0.5);
            material = new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.8,
              metalness: 0.2,
            });
            object = new THREE.Mesh(geometry, material);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Wall";
            addCollider(object);
            break;

          case "floor":
            geometry = new THREE.BoxGeometry(10, 0.5, 10);
            material = new THREE.MeshStandardMaterial({
              color: 0x8b7355,
              roughness: 0.9,
              metalness: 0.1,
            });
            object = new THREE.Mesh(geometry, material);
            object.receiveShadow = true;
            object.castShadow = true;
            object.name = "Floor";
            addCollider(object);
            break;

          case "stairs":
            object = createStairs();
            break;

          case "door":
            object = createDoor();
            break;

          case "pointLight":
            object = new THREE.PointLight(0xffffff, 1, 20);
            object.castShadow = true;
            object.name = "Point Light";
            const sphereGeom = new THREE.SphereGeometry(0.2, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            object.add(sphere);
            break;

          case "spotLight":
            object = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
            object.castShadow = true;
            object.name = "Spot Light";
            const coneGeom = new THREE.ConeGeometry(0.3, 0.6, 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const cone = new THREE.Mesh(coneGeom, coneMat);
            cone.rotation.x = Math.PI;
            object.add(cone);
            break;

          case "spawnPoint":
            if (spawnPoint) {
              alert("Spawn point already exists! Select it to move it.");
              selectObject(spawnPoint);
              return;
            }
            object = createSpawnPoint();
            spawnPoint = object;
            updateSpawnInfo();
            break;

          case "group":
            object = new THREE.Group();
            object.name = "Group";
            break;
        }

        if (object) {
          object.position.set(
            (Math.random() - 0.5) * 8,
            type === "floor" ? 0.25 : type === "wall" ? 2.5 : 2,
            (Math.random() - 0.5) * 8
          );

          scene.add(object);
          sceneObjects.push(object);
          updateHierarchy();
          updateCollisionList();
          selectObject(object);
          saveUndoState(object, "create");
        }

        return object;
      }

      // Create default assets from Library tab
      function createDefaultAsset(type) {
        let object;

        switch (type) {
          case "grass":
            object = createGrassPlane();
            break;

          case "pedestal":
            object = createPedestal();
            break;

          case "wall":
            const wallGeometry = new THREE.BoxGeometry(10, 5, 0.5);
            const wallMaterial = new THREE.MeshStandardMaterial({
              color: 0xe8d5c4,
              roughness: 0.85,
              metalness: 0.1,
            });
            object = new THREE.Mesh(wallGeometry, wallMaterial);
            object.castShadow = true;
            object.receiveShadow = true;
            object.name = "Museum Wall";
            object.position.set(0, 2.5, 0);
            break;

          case "frame":
            object = createArtFrame();
            break;

          case "floor":
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b7355,
              roughness: 0.9,
              metalness: 0.05,
            });
            object = new THREE.Mesh(floorGeometry, floorMaterial);
            object.rotation.x = -Math.PI / 2;
            object.receiveShadow = true;
            object.name = "Floor Tile";
            object.position.set(0, 0, 0);
            break;

          case "ceiling":
            const ceilingGeometry = new THREE.PlaneGeometry(20, 20);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
              color: 0xf5f5f5,
              roughness: 0.8,
              metalness: 0.1,
            });
            object = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            object.rotation.x = Math.PI / 2;
            object.receiveShadow = true;
            object.name = "Ceiling";
            object.position.set(0, 8, 0);
            break;

          case "skybox":
            scene.background = new THREE.Color(0x87ceeb);
            showNotification("Sky color applied to scene");
            return;

          case "ambientlight":
            object = new THREE.AmbientLight(0xffffff, 0.6);
            object.name = "Ambient Light";
            break;
        }

        if (object) {
          scene.add(object);
          sceneObjects.push(object);
          updateHierarchy();
          updateCollisionList();
          selectObject(object);
          saveUndoState(object, "create");
          showNotification("Added " + object.name + " to scene");
        }
      }

      // Create enhanced grass plane with instanced blades
      function createGrassPlane() {
        const group = new THREE.Group();
        group.name = "Grass Plane";

        // Canvas texture for broad grass color/variation
        const cvs = document.createElement("canvas");
        cvs.width = 1024;
        cvs.height = 1024;
        const ctx = cvs.getContext("2d");

        // Base gradient - natural grass tones
        const g = ctx.createLinearGradient(0, 0, 0, cvs.height);
        g.addColorStop(0, "#2e5f2a");
        g.addColorStop(0.6, "#274f22");
        g.addColorStop(1, "#1f451b");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, cvs.width, cvs.height);

        // Add random blade strokes for micro-variation
        ctx.strokeStyle = "rgba(30,70,30,0.16)";
        for (let i = 0; i < 1400; i++) {
          const x = Math.random() * cvs.width;
          const y = Math.random() * cvs.height;
          const h = 6 + Math.random() * 30;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.quadraticCurveTo(
            x + (Math.random() - 0.5) * 8,
            y - h / 2,
            x + (Math.random() - 0.5) * 6,
            y - h
          );
          ctx.stroke();
        }

        const grassTex = new THREE.CanvasTexture(cvs);
        grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.set(8, 4);
        try {
          grassTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        } catch (e) {}

        // Main grass plane
        const grassPlaneGeom = new THREE.PlaneGeometry(30, 30);
        const grassPlaneMat = new THREE.MeshStandardMaterial({
          map: grassTex,
          roughness: 0.9,
          metalness: 0.05,
        });
        const grassPlane = new THREE.Mesh(grassPlaneGeom, grassPlaneMat);
        grassPlane.rotation.x = -Math.PI / 2;
        grassPlane.receiveShadow = true;
        group.add(grassPlane);

        // Add instanced thin blades for depth and parallax
        try {
          // Create blade texture with alpha
          const bladeCanvas = document.createElement("canvas");
          bladeCanvas.width = 64;
          bladeCanvas.height = 256;
          const bctx = bladeCanvas.getContext("2d");

          // Blade gradient
          const g2 = bctx.createLinearGradient(0, 0, 0, bladeCanvas.height);
          g2.addColorStop(0, "#66b86a");
          g2.addColorStop(1, "#2f7a2f");
          bctx.fillStyle = g2;
          bctx.fillRect(0, 0, bladeCanvas.width, bladeCanvas.height);

          // Alpha mask: triangular taper
          bctx.globalCompositeOperation = "destination-in";
          bctx.beginPath();
          bctx.moveTo(bladeCanvas.width / 2, 0);
          bctx.lineTo(bladeCanvas.width, bladeCanvas.height);
          bctx.lineTo(0, bladeCanvas.height);
          bctx.closePath();
          bctx.fillStyle = "rgba(0,0,0,1)";
          bctx.fill();

          // Add subtle vein lines
          bctx.globalCompositeOperation = "source-over";
          bctx.strokeStyle = "rgba(20,60,20,0.12)";
          bctx.lineWidth = 1.2;
          for (let v = 0; v < 6; v++) {
            const sx = bladeCanvas.width / 2 + (Math.random() - 0.5) * 6;
            const sy = Math.random() * bladeCanvas.height * 0.1;
            const ex = bladeCanvas.width / 2 + (Math.random() - 0.5) * 10;
            const ey =
              bladeCanvas.height - Math.random() * bladeCanvas.height * 0.05;
            bctx.beginPath();
            bctx.moveTo(sx, sy);
            bctx.quadraticCurveTo(
              bladeCanvas.width / 2 + (Math.random() - 0.5) * 12,
              bladeCanvas.height * 0.5,
              ex,
              ey
            );
            bctx.stroke();
          }

          const bladeTex = new THREE.CanvasTexture(bladeCanvas);
          try {
            bladeTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
          } catch (e) {}
          bladeTex.wrapS = bladeTex.wrapT = THREE.ClampToEdgeWrapping;

          const perMeshCount = 400;
          const planeGeom = new THREE.PlaneGeometry(0.06, 1.0);
          const bladeMat = new THREE.MeshStandardMaterial({
            map: bladeTex,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.4,
            roughness: 0.95,
          });

          // Create two crossed instanced meshes
          const bladesA = new THREE.InstancedMesh(
            planeGeom,
            bladeMat,
            perMeshCount
          );
          const bladesB = new THREE.InstancedMesh(
            planeGeom,
            bladeMat,
            perMeshCount
          );
          bladesA.receiveShadow = true;
          bladesB.receiveShadow = true;

          const dummy = new THREE.Object3D();
          for (let i = 0; i < perMeshCount; i++) {
            const x = (Math.random() - 0.5) * 30;
            const z = (Math.random() - 0.5) * 30;
            const h = 0.15 + Math.random() * 0.45;
            const rotY = (Math.random() - 0.5) * 1.2;

            // bladesA
            dummy.position.set(x, h / 2, z);
            dummy.rotation.set(0, rotY, 0);
            dummy.scale.set(1, h, 1);
            dummy.updateMatrix();
            bladesA.setMatrixAt(i, dummy.matrix);

            // bladesB: crossed 90deg
            dummy.rotation.set(0, rotY + Math.PI / 2, 0);
            dummy.updateMatrix();
            bladesB.setMatrixAt(i, dummy.matrix);
          }

          bladesA.instanceMatrix.needsUpdate = true;
          bladesB.instanceMatrix.needsUpdate = true;
          group.add(bladesA);
          group.add(bladesB);
        } catch (e) {
          console.warn("Instanced grass blades failed", e);
        }

        group.position.set(0, 0, 0);
        return group;
      }

      // Create museum pedestal
      function createPedestal() {
        const group = new THREE.Group();
        group.name = "Pedestal";

        // Base
        const baseGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.3, 32);
        const baseMaterial = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.4,
          metalness: 0.6,
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.castShadow = true;
        base.receiveShadow = true;
        base.position.y = 0.15;
        group.add(base);

        // Column
        const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 32);
        const columnMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          roughness: 0.7,
          metalness: 0.2,
        });
        const column = new THREE.Mesh(columnGeometry, columnMaterial);
        column.castShadow = true;
        column.receiveShadow = true;
        column.position.y = 1.3;
        group.add(column);

        // Top
        const topGeometry = new THREE.CylinderGeometry(1.1, 0.9, 0.2, 32);
        const topMaterial = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.4,
          metalness: 0.6,
        });
        const top = new THREE.Mesh(topGeometry, topMaterial);
        top.castShadow = true;
        top.receiveShadow = true;
        top.position.y = 2.4;
        group.add(top);

        group.position.set(0, 0, 0);
        return group;
      }

      // Create art frame
      function createArtFrame() {
        const group = new THREE.Group();
        group.name = "Art Frame";

        // Frame border
        const frameMaterial = new THREE.MeshStandardMaterial({
          color: 0x8b7355,
          roughness: 0.6,
          metalness: 0.3,
        });

        const thickness = 0.15;
        const width = 3;
        const height = 4;
        const border = 0.3;

        // Top
        const topGeom = new THREE.BoxGeometry(
          width + border * 2,
          border,
          thickness
        );
        const top = new THREE.Mesh(topGeom, frameMaterial);
        top.position.set(0, height / 2 + border / 2, 0);
        group.add(top);

        // Bottom
        const bottom = new THREE.Mesh(topGeom, frameMaterial);
        bottom.position.set(0, -height / 2 - border / 2, 0);
        group.add(bottom);

        // Left
        const sideGeom = new THREE.BoxGeometry(border, height, thickness);
        const left = new THREE.Mesh(sideGeom, frameMaterial);
        left.position.set(-width / 2 - border / 2, 0, 0);
        group.add(left);

        // Right
        const right = new THREE.Mesh(sideGeom, frameMaterial);
        right.position.set(width / 2 + border / 2, 0, 0);
        group.add(right);

        // Canvas/backing
        const canvasGeom = new THREE.PlaneGeometry(width, height);
        const canvasMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.9,
        });
        const canvas = new THREE.Mesh(canvasGeom, canvasMaterial);
        canvas.position.z = -thickness / 2;
        group.add(canvas);

        group.position.set(0, 3, 0);
        group.castShadow = true;
        group.receiveShadow = true;
        return group;
      }

      function createStairs() {
        const group = new THREE.Group();
        group.name = "Stairs";

        const stepCount = 8;
        const stepWidth = 4;
        const stepHeight = 0.3;
        const stepDepth = 1;

        for (let i = 0; i < stepCount; i++) {
          const geometry = new THREE.BoxGeometry(
            stepWidth,
            stepHeight,
            stepDepth
          );
          const material = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            roughness: 0.9,
            metalness: 0.1,
          });
          const step = new THREE.Mesh(geometry, material);
          step.castShadow = true;
          step.receiveShadow = true;
          step.position.set(0, i * stepHeight, -i * stepDepth);
          group.add(step);
        }

        addCollider(group);
        return group;
      }

      function createDoor() {
        const group = new THREE.Group();
        group.name = "Door";

        // Frame
        const frameMaterial = new THREE.MeshStandardMaterial({
          color: 0x654321,
          roughness: 0.8,
        });

        const leftFrame = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 4, 0.2),
          frameMaterial
        );
        leftFrame.position.set(-1.1, 2, 0);
        leftFrame.castShadow = true;
        group.add(leftFrame);

        const rightFrame = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 4, 0.2),
          frameMaterial
        );
        rightFrame.position.set(1.1, 2, 0);
        rightFrame.castShadow = true;
        group.add(rightFrame);

        const topFrame = new THREE.Mesh(
          new THREE.BoxGeometry(2.4, 0.2, 0.2),
          frameMaterial
        );
        topFrame.position.set(0, 4, 0);
        topFrame.castShadow = true;
        group.add(topFrame);

        // Door
        const doorMaterial = new THREE.MeshStandardMaterial({
          color: 0x8b4513,
          roughness: 0.7,
        });
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(2, 3.8, 0.1),
          doorMaterial
        );
        door.position.set(0, 1.9, 0);
        door.castShadow = true;
        door.receiveShadow = true;
        group.add(door);

        addCollider(group);
        return group;
      }

      function createSpawnPoint() {
        const group = new THREE.Group();
        group.name = "Spawn Point";
        group.userData.isSpawnPoint = true;

        // Body (capsule approximation)
        const bodyGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 16);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.5,
          emissive: 0x00ff00,
          emissiveIntensity: 0.2,
        });
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        body.position.y = 0.8;
        group.add(body);

        // Head
        const headGeom = new THREE.SphereGeometry(0.3, 16, 16);
        const head = new THREE.Mesh(headGeom, bodyMat);
        head.position.y = 1.8;
        group.add(head);

        // Direction arrow
        const arrowGeom = new THREE.ConeGeometry(0.2, 0.6, 8);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const arrow = new THREE.Mesh(arrowGeom, arrowMat);
        arrow.rotation.x = Math.PI / 2;
        arrow.position.set(0, 1, 0.6);
        group.add(arrow);

        // Base circle
        const circleGeom = new THREE.RingGeometry(0.4, 0.5, 32);
        const circleMat = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          side: THREE.DoubleSide,
        });
        const circle = new THREE.Mesh(circleGeom, circleMat);
        circle.rotation.x = -Math.PI / 2;
        group.add(circle);

        group.position.y = 0;
        return group;
      }

      // ============================================
      // MODEL LOADING
      // ============================================
      function loadModel(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const arrayBuffer = e.target.result;
          const blob = new Blob([arrayBuffer]);
          const url = URL.createObjectURL(blob);

          const loader = new THREE.GLTFLoader();
          loader.load(
            url,
            function (gltf) {
              const model = gltf.scene;
              model.name = file.name.replace(/\.[^/.]+$/, "");

              model.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });

              model.position.set(0, 1, 0);
              scene.add(model);
              sceneObjects.push(model);
              updateHierarchy();
              selectObject(model);
              saveUndoState(model, "create");

              URL.revokeObjectURL(url);
            },
            undefined,
            function (error) {
              console.error("Error loading model:", error);
              alert("Error loading 3D model. Please check the file format.");
            }
          );
        };
        reader.readAsArrayBuffer(file);
        event.target.value = "";
      }

      // ============================================
      // COLLISION SYSTEM
      // ============================================
      function addCollider(obj) {
        if (!colliderObjects.includes(obj)) {
          colliderObjects.push(obj);
          obj.userData.hasCollision = true;
          updateCollisionList();
        }
      }

      function removeCollider(obj) {
        const index = colliderObjects.indexOf(obj);
        if (index > -1) {
          colliderObjects.splice(index, 1);
          obj.userData.hasCollision = false;
          updateCollisionList();
        }
      }

      function toggleObjectCollision() {
        if (!selectedObject) return;

        const enabled = document.getElementById("has-collision").checked;
        const optionsDiv = document.getElementById("collision-shape-options");

        if (enabled) {
          addCollider(selectedObject);
          optionsDiv.style.display = "block";

          // Initialize collision properties if not set
          if (!selectedObject.userData.collisionShape) {
            selectedObject.userData.collisionShape = "box";
          }
          if (selectedObject.userData.isTrigger === undefined) {
            selectedObject.userData.isTrigger = false;
          }
          if (selectedObject.userData.collisionLayer === undefined) {
            selectedObject.userData.collisionLayer = 0;
          }
          if (selectedObject.userData.collisionMask === undefined) {
            // Default: collide with all layers (bits 0-8 set)
            selectedObject.userData.collisionMask = 0x1ff; // Binary: 111111111
          }

          // Update UI
          document.getElementById("collision-shape").value =
            selectedObject.userData.collisionShape;
          document.getElementById("is-trigger").checked =
            selectedObject.userData.isTrigger;
          document.getElementById("collision-layer").value =
            selectedObject.userData.collisionLayer;
          updateCollisionMaskUI();

          rebuildColliderHelpers();
        } else {
          removeCollider(selectedObject);
          optionsDiv.style.display = "none";
        }
      }

      // NEW: Update collision shape type
      function updateCollisionShape() {
        if (!selectedObject) return;

        const shape = document.getElementById("collision-shape").value;
        selectedObject.userData.collisionShape = shape;

        console.log(`Collision shape changed to: ${shape}`);
        rebuildColliderHelpers();
      }

      // NEW: Toggle trigger mode
      function updateIsTrigger() {
        if (!selectedObject) return;

        const isTrigger = document.getElementById("is-trigger").checked;
        selectedObject.userData.isTrigger = isTrigger;

        // Show/hide trigger behavior options
        const behaviorOptions = document.getElementById(
          "trigger-behavior-options"
        );
        if (isTrigger) {
          behaviorOptions.style.display = "block";
          // Initialize trigger behavior if not set
          if (!selectedObject.userData.triggerBehavior) {
            selectedObject.userData.triggerBehavior = "none";
            selectedObject.userData.triggerParams = {};
          }
          updateTriggerBehaviorUI();
        } else {
          behaviorOptions.style.display = "none";
        }

        console.log(`Trigger mode: ${isTrigger}`);
        rebuildColliderHelpers();
      }

      // NEW: Update trigger behavior type
      function updateTriggerBehavior() {
        if (!selectedObject) return;

        const behavior = document.getElementById("trigger-behavior").value;
        selectedObject.userData.triggerBehavior = behavior;

        // Show/hide parameter sections based on behavior
        document.getElementById("param-damage").style.display =
          behavior === "damage" || behavior === "heal" ? "block" : "none";
        document.getElementById("param-teleport").style.display =
          behavior === "teleport" ? "block" : "none";
        document.getElementById("param-speed").style.display =
          behavior === "speedboost" ? "block" : "none";
        document.getElementById("param-message").style.display =
          behavior === "message" ? "block" : "none";

        console.log(`Trigger behavior: ${behavior}`);
      }

      // NEW: Update trigger parameters
      function updateTriggerParams() {
        if (!selectedObject) return;

        if (!selectedObject.userData.triggerParams) {
          selectedObject.userData.triggerParams = {};
        }

        const params = selectedObject.userData.triggerParams;
        const behavior = selectedObject.userData.triggerBehavior;

        // Save behavior-specific parameters
        if (behavior === "damage" || behavior === "heal") {
          params.amount =
            parseFloat(
              document.getElementById("trigger-damage-amount").value
            ) || 10;
        } else if (behavior === "teleport") {
          params.targetName = document.getElementById(
            "trigger-teleport-target"
          ).value;
        } else if (behavior === "speedboost") {
          params.speedMultiplier =
            parseFloat(document.getElementById("trigger-speed-mult").value) ||
            2;
        } else if (behavior === "message") {
          params.messageText = document.getElementById(
            "trigger-message-text"
          ).value;
        }

        // Log events setting
        params.logEvents =
          document.getElementById("trigger-log-events").checked;

        console.log("Trigger params updated:", params);
      }

      // NEW: Update trigger behavior UI from object data
      function updateTriggerBehaviorUI() {
        if (!selectedObject) return;

        const behavior = selectedObject.userData.triggerBehavior || "none";
        const params = selectedObject.userData.triggerParams || {};

        // Set behavior dropdown
        document.getElementById("trigger-behavior").value = behavior;

        // Set parameters
        if (behavior === "damage" || behavior === "heal") {
          document.getElementById("trigger-damage-amount").value =
            params.amount || 10;
        } else if (behavior === "teleport") {
          document.getElementById("trigger-teleport-target").value =
            params.targetName || "";
        } else if (behavior === "speedboost") {
          document.getElementById("trigger-speed-mult").value =
            params.speedMultiplier || 2;
        } else if (behavior === "message") {
          document.getElementById("trigger-message-text").value =
            params.messageText || "";
        }

        // Log events checkbox
        document.getElementById("trigger-log-events").checked =
          params.logEvents !== false;

        // Show correct parameter section
        updateTriggerBehavior();
      }

      // NEW: Update collision layer
      function updateCollisionLayer() {
        if (!selectedObject) return;

        const layer = parseInt(
          document.getElementById("collision-layer").value
        );
        selectedObject.userData.collisionLayer = layer;

        console.log(`Collision layer changed to: ${layer}`);
      }

      // NEW: Update collision mask from checkboxes
      function updateCollisionMask() {
        if (!selectedObject) return;

        let mask = 0;
        // Check each layer checkbox and build the bitmask
        for (let i = 0; i <= 8; i++) {
          const checkbox = document.getElementById(`mask-layer-${i}`);
          if (checkbox && checkbox.checked) {
            mask |= 1 << i; // Set bit i
          }
        }

        selectedObject.userData.collisionMask = mask;
        console.log(`Collision mask updated: ${mask.toString(2)} (${mask})`);
      }

      // NEW: Update collision mask UI from object's mask value
      function updateCollisionMaskUI() {
        if (!selectedObject) return;

        const mask = selectedObject.userData.collisionMask || 0x1ff;

        // Update checkboxes based on mask bits
        for (let i = 0; i <= 8; i++) {
          const checkbox = document.getElementById(`mask-layer-${i}`);
          if (checkbox) {
            checkbox.checked = (mask & (1 << i)) !== 0;
          }
        }
      }

      // NEW: Toggle all layer checkboxes
      function toggleAllLayers() {
        if (!selectedObject) return;

        // Check if all are currently selected
        const allSelected = selectedObject.userData.collisionMask === 0x1ff;

        // Toggle: if all selected, deselect all; otherwise select all
        const newMask = allSelected ? 0 : 0x1ff;
        selectedObject.userData.collisionMask = newMask;

        // Update UI
        for (let i = 0; i <= 8; i++) {
          const checkbox = document.getElementById(`mask-layer-${i}`);
          if (checkbox) {
            checkbox.checked = !allSelected;
          }
        }

        console.log(`All layers toggled: ${allSelected ? "OFF" : "ON"}`);
      }

      // NEW: Check if two objects should collide based on layer/mask
      function canObjectsCollide(obj1, obj2) {
        if (!obj1.userData.hasCollision || !obj2.userData.hasCollision) {
          return false;
        }

        const layer1 = obj1.userData.collisionLayer || 0;
        const layer2 = obj2.userData.collisionLayer || 0;
        const mask1 =
          obj1.userData.collisionMask !== undefined
            ? obj1.userData.collisionMask
            : 0x1ff;
        const mask2 =
          obj2.userData.collisionMask !== undefined
            ? obj2.userData.collisionMask
            : 0x1ff;

        // Check if obj1's mask includes obj2's layer AND obj2's mask includes obj1's layer
        const obj1CanHitObj2 = (mask1 & (1 << layer2)) !== 0;
        const obj2CanHitObj1 = (mask2 & (1 << layer1)) !== 0;

        return obj1CanHitObj2 && obj2CanHitObj1;
      }

      // NEW: Get color for collision layer (visual differentiation)
      function getLayerColor(layer, isTrigger) {
        // Triggers always use cyan
        if (isTrigger) return 0x00ffff;

        // Layer-specific colors for better visual distinction
        const layerColors = [
          0x00ff00, // 0: Default - Green
          0x0088ff, // 1: Player - Blue
          0xff0044, // 2: Enemy - Red
          0x888888, // 3: Environment - Gray
          0xffaa00, // 4: Projectile - Orange
          0xffff00, // 5: Pickup - Yellow
          0xff00ff, // 6: Trigger - Magenta
          0x00ffaa, // 7: Custom 1 - Aqua
          0xaa00ff, // 8: Custom 2 - Purple
        ];

        return layerColors[layer] || 0x00ff00;
      }

      // NEW: Simple AABB collision detection with trigger event system
      function detectCollisions() {
        // Track current frame's collisions
        const currentFrameCollisions = new Map();

        // Check all pairs of collision objects
        for (let i = 0; i < colliderObjects.length; i++) {
          for (let j = i + 1; j < colliderObjects.length; j++) {
            const obj1 = colliderObjects[i];
            const obj2 = colliderObjects[j];

            // Check if these objects should collide based on layer/mask
            if (!canObjectsCollide(obj1, obj2)) {
              continue;
            }

            // Simple AABB collision check
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);

            if (box1.intersectsBox(box2)) {
              const collisionKey = `${obj1.uuid}-${obj2.uuid}`;
              currentFrameCollisions.set(collisionKey, { obj1, obj2 });

              // Initialize previous collision tracking if needed
              if (!obj1.userData.activeTriggers)
                obj1.userData.activeTriggers = new Set();
              if (!obj2.userData.activeTriggers)
                obj2.userData.activeTriggers = new Set();

              // Check if this is a new collision (onTriggerEnter)
              const wasColliding1 = obj1.userData.activeTriggers.has(obj2.uuid);
              const wasColliding2 = obj2.userData.activeTriggers.has(obj1.uuid);

              if (!wasColliding1 && !wasColliding2) {
                // TRIGGER ENTER
                fireTriggerEvent(obj1, obj2, "enter");
                fireTriggerEvent(obj2, obj1, "enter");
              } else {
                // TRIGGER STAY
                fireTriggerEvent(obj1, obj2, "stay");
                fireTriggerEvent(obj2, obj1, "stay");
              }

              // Mark as active
              obj1.userData.activeTriggers.add(obj2.uuid);
              obj2.userData.activeTriggers.add(obj1.uuid);
            }
          }
        }

        // Check for exits (objects no longer colliding)
        colliderObjects.forEach((obj) => {
          if (!obj.userData.activeTriggers) return;

          const previousTriggers = new Set(obj.userData.activeTriggers);
          previousTriggers.forEach((otherUuid) => {
            // Find if still colliding
            let stillColliding = false;
            currentFrameCollisions.forEach(({ obj1, obj2 }) => {
              if (
                (obj1.uuid === obj.uuid && obj2.uuid === otherUuid) ||
                (obj2.uuid === obj.uuid && obj1.uuid === otherUuid)
              ) {
                stillColliding = true;
              }
            });

            if (!stillColliding) {
              // TRIGGER EXIT
              const otherObj = colliderObjects.find(
                (o) => o.uuid === otherUuid
              );
              if (otherObj) {
                fireTriggerEvent(obj, otherObj, "exit");
              }
              obj.userData.activeTriggers.delete(otherUuid);
            }
          });
        });
      }

      // NEW: Fire trigger events and execute behaviors
      function fireTriggerEvent(trigger, other, eventType) {
        // Only fire if trigger object is marked as trigger
        if (!trigger.userData.isTrigger) return;

        const params = trigger.userData.triggerParams || {};
        const behavior = trigger.userData.triggerBehavior || "none";

        // Log events if enabled
        if (params.logEvents !== false) {
          console.log(
            `[Trigger ${eventType.toUpperCase()}] ${
              trigger.name || "Unnamed"
            } <-> ${other.name || "Unnamed"}`
          );
        }

        // Execute trigger behavior (only on enter event to avoid spam)
        if (eventType === "enter") {
          executeTriggerBehavior(trigger, other, behavior, params);
        }

        // Execute Blueprint if enabled
        if (trigger.userData.blueprint && trigger.userData.blueprint.enabled) {
          executeBlueprint(trigger, "On Trigger Enter", { otherObject: other });
        }
      }

      // NEW: Execute trigger behavior based on type
      function executeTriggerBehavior(trigger, other, behavior, params) {
        switch (behavior) {
          case "checkpoint":
            // Save checkpoint position
            if (camera && isPlayMode) {
              trigger.userData.savedPosition = camera.position.clone();
              console.log(
                `ðŸ’¾ Checkpoint saved at (${camera.position.x.toFixed(
                  1
                )}, ${camera.position.y.toFixed(
                  1
                )}, ${camera.position.z.toFixed(1)})`
              );
            }
            break;

          case "damage":
            // Apply damage (would need health system)
            const damageAmount = params.amount || 10;
            console.log(`ðŸ’¥ Damage: -${damageAmount} HP`);
            break;

          case "heal":
            // Apply healing
            const healAmount = params.amount || 10;
            console.log(`ðŸ’š Heal: +${healAmount} HP`);
            break;

          case "teleport":
            // Teleport to target
            if (camera && isPlayMode && params.targetName) {
              const targetObj = sceneObjects.find(
                (obj) => obj.name === params.targetName
              );
              if (targetObj) {
                camera.position.copy(targetObj.position);
                console.log(`âœ¨ Teleported to ${params.targetName}`);
              } else {
                console.warn(
                  `âš ï¸ Teleport target '${params.targetName}' not found`
                );
              }
            }
            break;

          case "speedboost":
            // Speed boost (would need to modify player speed)
            const speedMult = params.speedMultiplier || 2;
            console.log(`âš¡ Speed Boost: ${speedMult}x`);
            break;

          case "killzone":
            // Reset to spawn/checkpoint
            if (camera && isPlayMode) {
              // Find last checkpoint or spawn point
              const checkpoint = colliderObjects.find(
                (obj) =>
                  obj.userData.isTrigger &&
                  obj.userData.triggerBehavior === "checkpoint" &&
                  obj.userData.savedPosition
              );
              if (checkpoint && checkpoint.userData.savedPosition) {
                camera.position.copy(checkpoint.userData.savedPosition);
                console.log(`â˜ ï¸ Kill Zone! Respawning at checkpoint...`);
              } else {
                camera.position.set(0, 10, 20);
                console.log(`â˜ ï¸ Kill Zone! Respawning at spawn...`);
              }
            }
            break;

          case "collect":
            // Hide collected object
            trigger.visible = false;
            console.log(`â­ Collected: ${trigger.name || "Item"}`);
            break;

          case "door":
            // Toggle door visibility/position
            trigger.userData.doorOpen = !trigger.userData.doorOpen;
            if (trigger.userData.doorOpen) {
              trigger.position.y += 5;
              console.log(`ðŸšª Door opened`);
            } else {
              trigger.position.y -= 5;
              console.log(`ðŸšª Door closed`);
            }
            break;

          case "message":
            // Show message
            const message = params.messageText || "Trigger activated!";
            console.log(`ðŸ“¢ ${message}`);
            // Could show on-screen UI message here
            break;

          case "none":
          default:
            // Custom code - no built-in behavior
            break;
        }
      }

      function toggleAllColliders() {
        showColliderHelpers = !showColliderHelpers;
        rebuildColliderHelpers();
      }

      function rebuildColliders() {
        rebuildColliderHelpers();
        updateCollisionList();
      }

      function rebuildColliderHelpers() {
        // Remove old helpers
        colliderHelpers.forEach((helper) => {
          scene.remove(helper);
        });
        colliderHelpers = [];

        if (!showColliderHelpers) return;

        // Create new helpers based on collision shape type
        colliderObjects.forEach((obj) => {
          const shape = obj.userData.collisionShape || "box";
          const isTrigger = obj.userData.isTrigger || false;
          const layer = obj.userData.collisionLayer || 0;
          const color = getLayerColor(layer, isTrigger); // Layer-specific colors

          let helper;

          switch (shape) {
            case "box":
              helper = new THREE.BoxHelper(obj, color);
              break;
            case "sphere":
              helper = createSphereColliderHelper(obj, color);
              break;
            case "capsule":
              helper = createCapsuleColliderHelper(obj, color);
              break;
            case "mesh":
              // Use WireframeGeometry for exact mesh collision
              if (obj.geometry) {
                const wireframe = new THREE.WireframeGeometry(obj.geometry);
                const mat = new THREE.LineBasicMaterial({ color: color });
                helper = new THREE.LineSegments(wireframe, mat);
                helper.position.copy(obj.position);
                helper.rotation.copy(obj.rotation);
                helper.scale.copy(obj.scale);
              } else {
                // Fall back to box helper if no geometry
                helper = new THREE.BoxHelper(obj, color);
              }
              break;
          }

          if (helper) {
            helper.name = "_ColliderHelper";
            scene.add(helper);
            colliderHelpers.push(helper);
          }
        });
      }

      // Helper function to create sphere collision wireframe
      function createSphereColliderHelper(obj, color) {
        // Calculate bounding sphere radius
        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        const radius = Math.max(size.x, size.y, size.z) / 2;

        // Create sphere wireframe
        const geometry = new THREE.SphereGeometry(radius, 16, 12);
        const wireframe = new THREE.WireframeGeometry(geometry);
        const mat = new THREE.LineBasicMaterial({ color: color });
        const helper = new THREE.LineSegments(wireframe, mat);

        // Position at object center
        const center = box.getCenter(new THREE.Vector3());
        helper.position.copy(center);

        return helper;
      }

      // Helper function to create capsule collision wireframe
      function createCapsuleColliderHelper(obj, color) {
        // Calculate capsule dimensions from bounding box
        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());

        // Capsule is tallest dimension for height, average of others for radius
        const height = Math.max(size.x, size.y, size.z);
        const radius =
          (Math.min(size.x, size.z) + Math.max(size.x, size.z)) / 4;

        // Create capsule geometry (cylinder + 2 hemispheres)
        const cylinderHeight = Math.max(0.1, height - radius * 2);
        const geometry = new THREE.CapsuleGeometry(
          radius,
          cylinderHeight,
          8,
          16
        );
        const wireframe = new THREE.WireframeGeometry(geometry);
        const mat = new THREE.LineBasicMaterial({ color: color });
        const helper = new THREE.LineSegments(wireframe, mat);

        // Position at object center
        const center = box.getCenter(new THREE.Vector3());
        helper.position.copy(center);

        return helper;
      }

      function updateCollisionList() {
        const list = document.getElementById("collision-list");
        list.innerHTML = "";

        if (colliderObjects.length === 0) {
          list.innerHTML =
            '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No collision objects</div>';
          return;
        }

        colliderObjects.forEach((obj) => {
          const item = document.createElement("div");
          item.className = "collision-item";
          item.innerHTML = `
                    <div class="collision-item-header">
                        <span>${obj.name || "Unnamed"}</span>
                        <button type="button" class="collision-toggle enabled" onclick="removeCollider(sceneObjects.find(o => o.uuid === '${
                          obj.uuid
                        }'))">
                            <i class="fas fa-check"></i> Enabled
                        </button>
                    </div>
                `;
          list.appendChild(item);
        });
      }

      // ============================================
      // OBJECT SELECTION & MANIPULATION
      // ============================================
      function onCanvasClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
          let object = intersects[0].object;

          while (object.parent && object.parent !== scene) {
            if (sceneObjects.includes(object.parent)) {
              object = object.parent;
              break;
            }
            object = object.parent;
          }

          // In play mode, execute "On Click" blueprints
          if (isPlayMode) {
            if (
              object.userData.blueprint &&
              object.userData.blueprint.enabled
            ) {
              executeBlueprint(object, "On Click", {});
            }
            return;
          }

          // In edit mode, select object
          if (!transformControls) return;
          if (isSelectableObject(object)) {
            selectObject(object);
          }
        } else {
          if (!isPlayMode) {
            deselectObject();
          }
        }
      }

      function isSelectableObject(obj) {
        if (!obj) return false;
        if (obj.name && obj.name.startsWith("_")) return false;
        return sceneObjects.includes(obj);
      }

      function selectObject(obj) {
        if (selectedObject === obj) return;

        deselectObject();
        selectedObject = obj;

        if (transformControls) {
          transformControls.attach(obj);
        }

        createHighlight(obj);
        updatePropertiesPanel();
        updateHierarchy();
      }

      function deselectObject() {
        if (!selectedObject) return;

        if (transformControls) {
          transformControls.detach();
        }

        removeHighlight();
        selectedObject = null;

        document.getElementById("no-selection").style.display = "block";
        document.getElementById("properties-content").style.display = "none";
        updateHierarchy();
      }

      function createHighlight(obj) {
        removeHighlight();

        if (obj.isLight) return;

        objectHighlight = new THREE.BoxHelper(obj, 0x00ddff);
        objectHighlight.material.linewidth = 2;
        scene.add(objectHighlight);
      }

      function removeHighlight() {
        if (objectHighlight) {
          scene.remove(objectHighlight);
          objectHighlight.geometry.dispose();
          objectHighlight.material.dispose();
          objectHighlight = null;
        }
      }

      // ============================================
      // PROPERTIES PANEL
      // ============================================
      function updatePropertiesPanel() {
        if (!selectedObject) {
          document.getElementById("no-selection").style.display = "block";
          document.getElementById("properties-content").style.display = "none";
          return;
        }

        document.getElementById("no-selection").style.display = "none";
        document.getElementById("properties-content").style.display = "block";

        document.getElementById("obj-name").value = selectedObject.name || "";

        document.getElementById("pos-x").value =
          selectedObject.position.x.toFixed(2);
        document.getElementById("pos-y").value =
          selectedObject.position.y.toFixed(2);
        document.getElementById("pos-z").value =
          selectedObject.position.z.toFixed(2);

        document.getElementById("rot-x").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.x
        ).toFixed(0);
        document.getElementById("rot-y").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.y
        ).toFixed(0);
        document.getElementById("rot-z").value = THREE.MathUtils.radToDeg(
          selectedObject.rotation.z
        ).toFixed(0);

        document.getElementById("scale-x").value =
          selectedObject.scale.x.toFixed(2);
        document.getElementById("scale-y").value =
          selectedObject.scale.y.toFixed(2);
        document.getElementById("scale-z").value =
          selectedObject.scale.z.toFixed(2);

        // Material or Light
        if (selectedObject.isLight) {
          document.getElementById("material-section").style.display = "none";
          document.getElementById("light-section").style.display = "block";

          const color = "#" + selectedObject.color.getHexString();
          document.getElementById("light-color").value = color;
          document.getElementById("light-color-preview").style.backgroundColor =
            color;
          document.getElementById("light-intensity").value =
            selectedObject.intensity;
          document.getElementById("light-distance").value =
            selectedObject.distance || 0;
        } else if (selectedObject.material) {
          document.getElementById("material-section").style.display = "block";
          document.getElementById("light-section").style.display = "none";

          const color = "#" + selectedObject.material.color.getHexString();
          document.getElementById("obj-color").value = color;
          document.getElementById("color-preview").style.backgroundColor =
            color;
          document.getElementById("color-hex").value = color;
          document.getElementById("obj-roughness").value =
            selectedObject.material.roughness || 0.5;
          document.getElementById("obj-metalness").value =
            selectedObject.material.metalness || 0.5;
        } else {
          document.getElementById("material-section").style.display = "none";
          document.getElementById("light-section").style.display = "none";
        }

        // Collision
        const hasCollision = selectedObject.userData.hasCollision || false;
        document.getElementById("has-collision").checked = hasCollision;

        // Show/hide collision options
        const collisionOptions = document.getElementById(
          "collision-shape-options"
        );
        if (hasCollision) {
          collisionOptions.style.display = "block";

          // Update collision shape dropdown
          const shape = selectedObject.userData.collisionShape || "box";
          document.getElementById("collision-shape").value = shape;

          // Update trigger checkbox
          const isTrigger = selectedObject.userData.isTrigger || false;
          document.getElementById("is-trigger").checked = isTrigger;

          // Show/hide trigger behavior options
          const behaviorOptions = document.getElementById(
            "trigger-behavior-options"
          );
          if (isTrigger) {
            behaviorOptions.style.display = "block";
            updateTriggerBehaviorUI();
          } else {
            behaviorOptions.style.display = "none";
          }

          // Update collision layer
          const layer = selectedObject.userData.collisionLayer || 0;
          document.getElementById("collision-layer").value = layer;

          // Update collision mask checkboxes
          updateCollisionMaskUI();
        } else {
          collisionOptions.style.display = "none";
        }

        // Physics
        const hasPhysics = selectedObject.userData.hasPhysics || false;
        document.getElementById("has-physics").checked = hasPhysics;

        // Show/hide physics options
        const physicsOptions = document.getElementById("physics-options");
        if (hasPhysics) {
          physicsOptions.style.display = "block";
          updatePhysicsUI();
        } else {
          physicsOptions.style.display = "none";
        }

        // Callbacks
        const hasCallbacks = selectedObject.userData.hasCallbacks || false;
        document.getElementById("has-callbacks").checked = hasCallbacks;

        // Show/hide callback editor
        const callbacksEditor = document.getElementById("callbacks-editor");
        if (hasCallbacks) {
          callbacksEditor.style.display = "block";
          loadCallbacksUI();
        } else {
          callbacksEditor.style.display = "none";
        }
      }

      function updateObjectName() {
        if (!selectedObject) return;
        selectedObject.name = document.getElementById("obj-name").value;
        updateHierarchy();
        updateCollisionList();
      }

      function updatePosition(axis, value) {
        if (!selectedObject) return;
        selectedObject.position[axis] = parseFloat(value) || 0;
        if (objectHighlight) objectHighlight.update();
        if (selectedObject.userData.isSpawnPoint) updateSpawnInfo();
      }

      function updateRotation(axis, value) {
        if (!selectedObject) return;
        selectedObject.rotation[axis] = THREE.MathUtils.degToRad(
          parseFloat(value) || 0
        );
        if (objectHighlight) objectHighlight.update();
        if (selectedObject.userData.isSpawnPoint) updateSpawnInfo();
      }

      function updateScale(axis, value) {
        if (!selectedObject) return;
        selectedObject.scale[axis] = parseFloat(value) || 1;
        if (objectHighlight) objectHighlight.update();
      }

      function updateColor() {
        if (!selectedObject || !selectedObject.material) return;
        const color = document.getElementById("obj-color").value;
        selectedObject.material.color.setStyle(color);
        document.getElementById("color-preview").style.backgroundColor = color;
        document.getElementById("color-hex").value = color;
      }

      function updateColorFromHex() {
        if (!selectedObject || !selectedObject.material) return;
        const hex = document.getElementById("color-hex").value;
        try {
          selectedObject.material.color.setStyle(hex);
          document.getElementById("obj-color").value = hex;
          document.getElementById("color-preview").style.backgroundColor = hex;
        } catch (e) {}
      }

      function updateMaterial() {
        if (!selectedObject || !selectedObject.material) return;
        selectedObject.material.roughness = parseFloat(
          document.getElementById("obj-roughness").value
        );
        selectedObject.material.metalness = parseFloat(
          document.getElementById("obj-metalness").value
        );
      }

      function updateLightColor() {
        if (!selectedObject || !selectedObject.isLight) return;
        const color = document.getElementById("light-color").value;
        selectedObject.color.setStyle(color);
        document.getElementById("light-color-preview").style.backgroundColor =
          color;
      }

      function updateLightIntensity() {
        if (!selectedObject || !selectedObject.isLight) return;
        selectedObject.intensity = parseFloat(
          document.getElementById("light-intensity").value
        );
      }

      function updateLightDistance() {
        if (!selectedObject || !selectedObject.isLight) return;
        selectedObject.distance = parseFloat(
          document.getElementById("light-distance").value
        );
      }

      function setTransformMode(mode) {
        if (!transformControls) return;
        transformControls.setMode(mode);

        document.getElementById("mode-translate").classList.remove("active");
        document.getElementById("mode-rotate").classList.remove("active");
        document.getElementById("mode-scale").classList.remove("active");
        document.getElementById("mode-" + mode).classList.add("active");
      }

      function deleteSelectedObject() {
        if (!selectedObject) return;

        if (selectedObject.userData.isSpawnPoint) {
          spawnPoint = null;
          updateSpawnInfo();
        }

        saveUndoState(selectedObject, "delete");
        scene.remove(selectedObject);

        if (selectedObject.geometry) selectedObject.geometry.dispose();
        if (selectedObject.material) {
          if (Array.isArray(selectedObject.material)) {
            selectedObject.material.forEach((m) => m.dispose());
          } else {
            selectedObject.material.dispose();
          }
        }

        const index = sceneObjects.indexOf(selectedObject);
        if (index > -1) sceneObjects.splice(index, 1);

        removeCollider(selectedObject);
        deselectObject();
        updateHierarchy();
      }

      // ============================================
      // HIERARCHY
      // ============================================
      function updateHierarchy() {
        const list = document.getElementById("hierarchy-list");
        list.innerHTML = "";

        if (sceneObjects.length === 0) {
          list.innerHTML =
            '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No objects in scene</div>';
          return;
        }

        sceneObjects.forEach((obj) => {
          const item = document.createElement("div");
          item.className = "hierarchy-item";
          if (obj === selectedObject) item.classList.add("selected");

          let icon = "fa-cube";
          if (obj.isLight) icon = "fa-lightbulb";
          if (obj.userData.isSpawnPoint) icon = "fa-user";
          if (obj.type === "Group") icon = "fa-object-group";

          item.innerHTML = `<i class="fas ${icon}"></i><span>${
            obj.name || obj.type
          }</span>`;
          item.onclick = () => selectObject(obj);
          list.appendChild(item);
        });
      }

      // ============================================
      // SCENE SETTINGS
      // ============================================
      function updateBackgroundColor() {
        const color = document.getElementById("bg-color").value;
        scene.background.setStyle(color);
        document.getElementById("bg-color-preview").style.backgroundColor =
          color;
        if (scene.fog) scene.fog.color.setStyle(color);
      }

      function updateFog() {
        const enabled = document.getElementById("fog-enabled").checked;
        const distance = parseFloat(
          document.getElementById("fog-distance").value
        );

        if (enabled) {
          const color = scene.background.getHex();
          scene.fog = new THREE.Fog(color, 0, distance);
        } else {
          scene.fog = null;
        }
      }

      function updateGrid() {
        const enabled = document.getElementById("grid-enabled").checked;
        gridHelper.visible = enabled;
      }

      function updateAmbientLight() {
        const intensity = parseFloat(
          document.getElementById("ambient-intensity").value
        );
        ambientLight.intensity = intensity;
      }

      function updateSunLight() {
        const intensity = parseFloat(
          document.getElementById("sun-intensity").value
        );
        directionalLight.intensity = intensity;
      }

      function updateSpawnInfo() {
        const info = document.getElementById("spawn-info");
        if (!spawnPoint) {
          info.innerHTML =
            "No spawn point in scene. Add one from the Assets panel.";
          return;
        }

        const pos = spawnPoint.position;
        const rot = spawnPoint.rotation;
        info.innerHTML = `
                Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(
          1
        )}, ${pos.z.toFixed(1)})<br>
                Rotation: ${THREE.MathUtils.radToDeg(rot.y).toFixed(0)}Â°
            `;
      }

      // ============================================
      // SIDEBAR TABS
      // ============================================
      function switchLeftTab(tab) {
        document
          .querySelectorAll(".left-sidebar .sidebar-tab")
          .forEach((t) => t.classList.remove("active"));
        document
          .querySelectorAll(".left-sidebar .sidebar-panel")
          .forEach((p) => p.classList.remove("active"));

        event.target.closest(".sidebar-tab").classList.add("active");
        document.getElementById("panel-" + tab).classList.add("active");
      }

      function switchRightTab(tab) {
        document
          .querySelectorAll(".right-sidebar .sidebar-tab")
          .forEach((t) => t.classList.remove("active"));
        document
          .querySelectorAll(".right-sidebar .sidebar-panel")
          .forEach((p) => p.classList.remove("active"));

        event.target.closest(".sidebar-tab").classList.add("active");
        document.getElementById("panel-" + tab).classList.add("active");

        // Update Blueprint panel visibility
        if (tab === "blueprint") {
          const noSelection = document.getElementById("blueprint-no-selection");
          const content = document.getElementById("blueprint-content");

          if (selectedObject) {
            noSelection.style.display = "none";
            content.style.display = "block";
            loadBlueprintUI();
          } else {
            noSelection.style.display = "block";
            content.style.display = "none";
          }
        }
      }

      // ============================================
      // BLUEPRINT SYSTEM
      // ============================================

      // Blueprint state
      let blueprintNodeId = 0;
      let blueprintDragNode = null;
      let blueprintDragConnection = null;
      let blueprintSelectedNode = null;

      // Node Registry
      const blueprintNodeRegistry = {
        "On Start": {
          type: "event",
          icon: "ðŸ“",
          outputs: [{ name: "Execute", type: "exec" }],
        },
        "On Collision Enter": {
          type: "event",
          icon: "ðŸ“",
          outputs: [
            { name: "Execute", type: "exec" },
            { name: "Other Object", type: "data" },
          ],
        },
        "On Trigger Enter": {
          type: "event",
          icon: "ðŸ“",
          outputs: [
            { name: "Execute", type: "exec" },
            { name: "Other Object", type: "data" },
          ],
        },
        "On Click": {
          type: "event",
          icon: "ðŸ“",
          outputs: [{ name: "Execute", type: "exec" }],
        },
        "Change Color": {
          type: "action",
          icon: "âš¡",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [{ name: "Then", type: "exec" }],
          params: [
            {
              name: "color",
              label: "Color",
              type: "color",
              default: "#FF0000",
            },
          ],
        },
        "Move Object": {
          type: "action",
          icon: "âš¡",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [{ name: "Then", type: "exec" }],
          params: [
            { name: "x", label: "X Position", type: "number", default: 0 },
            { name: "y", label: "Y Position", type: "number", default: 1 },
            { name: "z", label: "Z Position", type: "number", default: 0 },
          ],
        },
        "Destroy Object": {
          type: "action",
          icon: "âš¡",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [{ name: "Then", type: "exec" }],
        },
        "Log Message": {
          type: "action",
          icon: "âš¡",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [{ name: "Then", type: "exec" }],
          params: [
            {
              name: "message",
              label: "Message",
              type: "text",
              default: "Hello!",
            },
          ],
        },
        Branch: {
          type: "flow",
          icon: "ðŸ”€",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [
            { name: "True", type: "exec" },
            { name: "False", type: "exec" },
          ],
          params: [
            {
              name: "condition",
              label: "Condition",
              type: "select",
              options: [
                "Is Player",
                "Has Tag: Enemy",
                "Has Tag: Collectible",
                "Y Position > 0",
                "Y Position < 0",
              ],
              default: "Is Player",
            },
          ],
        },
        Delay: {
          type: "flow",
          icon: "ðŸ”€",
          inputs: [{ name: "Execute", type: "exec" }],
          outputs: [{ name: "Then", type: "exec" }],
          params: [
            {
              name: "duration",
              label: "Duration (seconds)",
              type: "number",
              default: 1.0,
            },
          ],
        },
      };

      function toggleBlueprint() {
        if (!selectedObject) return;

        const enabled = document.getElementById("has-blueprint").checked;
        const editor = document.getElementById("blueprint-editor");

        if (enabled) {
          selectedObject.userData.blueprint = {
            enabled: true,
            nodes: [],
            connections: [],
          };
          editor.style.display = "block";
          renderBlueprintCanvas();
        } else {
          selectedObject.userData.blueprint = null;
          editor.style.display = "none";
        }
      }

      function addBlueprintNode(nodeName) {
        if (!selectedObject || !selectedObject.userData.blueprint) return;

        const nodeDefinition = blueprintNodeRegistry[nodeName];
        if (!nodeDefinition) return;

        const nodeId = "node_" + blueprintNodeId++;
        const newNode = {
          id: nodeId,
          name: nodeName,
          type: nodeDefinition.type,
          icon: nodeDefinition.icon,
          position: {
            x: 100 + Math.random() * 200,
            y: 100 + Math.random() * 200,
          },
          inputs: nodeDefinition.inputs || [],
          outputs: nodeDefinition.outputs || [],
          params: {},
        };

        // Initialize parameters with defaults
        if (nodeDefinition.params) {
          nodeDefinition.params.forEach((param) => {
            newNode.params[param.name] = param.default;
          });
        }

        selectedObject.userData.blueprint.nodes.push(newNode);
        renderBlueprintCanvas();
      }

      function clearBlueprint() {
        if (!selectedObject || !selectedObject.userData.blueprint) return;

        if (confirm("Clear all nodes from this Blueprint?")) {
          selectedObject.userData.blueprint.nodes = [];
          selectedObject.userData.blueprint.connections = [];
          renderBlueprintCanvas();
        }
      }

      function testBlueprint() {
        if (!selectedObject || !selectedObject.userData.blueprint) return;

        console.log("ðŸŽ® Testing Blueprint for:", selectedObject.name);
        executeBlueprint(selectedObject, "On Start", {});
      }

      function renderBlueprintCanvas() {
        if (!selectedObject || !selectedObject.userData.blueprint) return;

        const blueprint = selectedObject.userData.blueprint;
        const canvas = document.querySelector("#blueprint-nodes > div");
        const connectionsGroup = document.getElementById(
          "blueprint-connections"
        );

        // Clear canvas
        canvas.innerHTML = "";
        connectionsGroup.innerHTML = "";

        // Render nodes
        blueprint.nodes.forEach((node) => {
          const nodeEl = createNodeElement(node);
          canvas.appendChild(nodeEl);
        });

        // Render connections
        blueprint.connections.forEach((conn) => {
          const line = createConnectionLine(conn);
          if (line) connectionsGroup.appendChild(line);
        });
      }

      function createNodeElement(node) {
        const nodeEl = document.createElement("div");
        nodeEl.className = `blueprint-node ${node.type}`;
        nodeEl.style.left = node.position.x + "px";
        nodeEl.style.top = node.position.y + "px";
        nodeEl.dataset.nodeId = node.id;

        // Header
        const header = document.createElement("div");
        header.className = `blueprint-node-header ${node.type}`;
        header.textContent = `${node.icon} ${node.name}`;
        nodeEl.appendChild(header);

        // Body
        const body = document.createElement("div");
        body.className = "blueprint-node-body";

        // Input pins
        node.inputs.forEach((input) => {
          const pinEl = document.createElement("div");
          pinEl.className = `blueprint-node-pin input`;
          pinEl.innerHTML = `
                    <div class="blueprint-pin ${input.type}" data-pin="${input.name}" data-direction="input"></div>
                    <span>${input.name}</span>
                `;
          body.appendChild(pinEl);
        });

        // Parameters
        const nodeDefinition = blueprintNodeRegistry[node.name];
        if (nodeDefinition.params) {
          nodeDefinition.params.forEach((param) => {
            const paramEl = document.createElement("div");
            paramEl.className = "blueprint-node-param";

            const label = document.createElement("label");
            label.textContent = param.label;
            paramEl.appendChild(label);

            let input;
            if (param.type === "select") {
              input = document.createElement("select");
              param.options.forEach((opt) => {
                const option = document.createElement("option");
                option.value = opt;
                option.textContent = opt;
                if (opt === node.params[param.name]) option.selected = true;
                input.appendChild(option);
              });
            } else if (param.type === "color") {
              input = document.createElement("input");
              input.type = "color";
              input.value = node.params[param.name] || param.default;
            } else if (param.type === "number") {
              input = document.createElement("input");
              input.type = "number";
              input.step = "0.1";
              input.value = node.params[param.name] || param.default;
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.value = node.params[param.name] || param.default;
            }

            input.addEventListener("change", () => {
              node.params[param.name] =
                param.type === "number" ? parseFloat(input.value) : input.value;
            });

            paramEl.appendChild(input);
            body.appendChild(paramEl);
          });
        }

        // Output pins
        node.outputs.forEach((output) => {
          const pinEl = document.createElement("div");
          pinEl.className = `blueprint-node-pin output`;
          pinEl.innerHTML = `
                    <span>${output.name}</span>
                    <div class="blueprint-pin ${output.type}" data-pin="${output.name}" data-direction="output"></div>
                `;
          body.appendChild(pinEl);
        });

        nodeEl.appendChild(body);

        // Make node draggable
        makeNodeDraggable(nodeEl, node);

        // Add pin connection listeners
        addPinConnectionListeners(nodeEl, node);

        // Right-click to delete
        nodeEl.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          if (confirm(`Delete node "${node.name}"?`)) {
            deleteNode(node.id);
          }
        });

        return nodeEl;
      }

      function addPinConnectionListeners(nodeEl, node) {
        const pins = nodeEl.querySelectorAll(".blueprint-pin");

        pins.forEach((pin) => {
          pin.addEventListener("mousedown", (e) => {
            e.stopPropagation(); // Don't trigger node drag

            const direction = pin.dataset.direction;
            const pinName = pin.dataset.pin;
            const pinType = pin.classList.contains("exec") ? "exec" : "data";

            if (direction === "output") {
              // Start dragging a connection from output pin
              startConnectionDrag(node, pinName, pinType, pin);
            } else if (direction === "input") {
              // Check if we're completing a connection
              if (blueprintDragConnection) {
                completeConnection(node, pinName, pinType);
              }
            }
          });

          // Highlight pins on hover during drag
          pin.addEventListener("mouseenter", () => {
            if (blueprintDragConnection && pin.dataset.direction === "input") {
              pin.style.transform = "scale(1.5)";
            }
          });

          pin.addEventListener("mouseleave", () => {
            pin.style.transform = "";
          });
        });
      }

      function startConnectionDrag(sourceNode, pinName, pinType, pinElement) {
        blueprintDragConnection = {
          sourceNode: sourceNode,
          sourcePinName: pinName,
          pinType: pinType,
          pinElement: pinElement,
        };

        // Create temporary connection line
        const canvas = document.getElementById("blueprint-canvas");
        canvas.style.cursor = "crosshair";

        // Add mousemove listener to draw temp line
        const onMouseMove = (e) => {
          if (!blueprintDragConnection) return;

          updateTempConnectionLine(e);
        };

        const onMouseUp = (e) => {
          // Check if we released on a valid input pin
          const targetPin = e.target.closest(".blueprint-pin");

          if (targetPin && targetPin.dataset.direction === "input") {
            const targetNodeEl = targetPin.closest(".blueprint-node");
            const targetNodeId = targetNodeEl.dataset.nodeId;
            const targetNode = selectedObject.userData.blueprint.nodes.find(
              (n) => n.id === targetNodeId
            );
            const targetPinName = targetPin.dataset.pin;
            const targetPinType = targetPin.classList.contains("exec")
              ? "exec"
              : "data";

            completeConnection(targetNode, targetPinName, targetPinType);
          } else {
            cancelConnectionDrag();
          }

          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
          canvas.style.cursor = "grab";
        };

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }

      function updateTempConnectionLine(e) {
        if (!blueprintDragConnection) return;

        const connectionsGroup = document.getElementById(
          "blueprint-connections"
        );

        // Remove old temp line
        const oldTemp = connectionsGroup.querySelector(
          ".blueprint-connection.temp"
        );
        if (oldTemp) oldTemp.remove();

        // Get source pin position
        const sourceNode = blueprintDragConnection.sourceNode;
        const pinElement = blueprintDragConnection.pinElement;
        const rect = pinElement.getBoundingClientRect();
        const canvasRect = document
          .getElementById("blueprint-canvas")
          .getBoundingClientRect();

        const x1 = rect.left - canvasRect.left + rect.width / 2;
        const y1 = rect.top - canvasRect.top + rect.height / 2;
        const x2 = e.clientX - canvasRect.left;
        const y2 = e.clientY - canvasRect.top;

        // Create temp line
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        const midX = (x1 + x2) / 2;

        path.setAttribute(
          "d",
          `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`
        );
        path.setAttribute(
          "class",
          `blueprint-connection temp ${blueprintDragConnection.pinType}`
        );

        connectionsGroup.appendChild(path);
      }

      function completeConnection(targetNode, targetPinName, targetPinType) {
        if (!blueprintDragConnection) return;

        const sourceNode = blueprintDragConnection.sourceNode;
        const sourcePinName = blueprintDragConnection.sourcePinName;
        const sourcePinType = blueprintDragConnection.pinType;

        // Validate connection (can't connect to self, types must match)
        if (sourceNode.id === targetNode.id) {
          console.warn("Cannot connect node to itself");
          cancelConnectionDrag();
          return;
        }

        if (sourcePinType !== targetPinType) {
          console.warn("Pin types must match (exec to exec, data to data)");
          cancelConnectionDrag();
          return;
        }

        // Check if connection already exists
        const connectionKey = `${sourceNode.id}.${sourcePinName}`;
        const targetKey = `${targetNode.id}.${targetPinName}`;

        const blueprint = selectedObject.userData.blueprint;
        const exists = blueprint.connections.some(
          (conn) => conn.from === connectionKey && conn.to === targetKey
        );

        if (exists) {
          console.warn("Connection already exists");
          cancelConnectionDrag();
          return;
        }

        // Remove any existing connection to this input (inputs can only have one connection)
        blueprint.connections = blueprint.connections.filter(
          (conn) => conn.to !== targetKey
        );

        // Add new connection
        blueprint.connections.push({
          from: connectionKey,
          to: targetKey,
        });

        console.log("âœ… Connected:", connectionKey, "â†’", targetKey);

        cancelConnectionDrag();
        renderBlueprintCanvas();
      }

      function cancelConnectionDrag() {
        blueprintDragConnection = null;

        // Remove temp line
        const connectionsGroup = document.getElementById(
          "blueprint-connections"
        );
        const tempLine = connectionsGroup.querySelector(
          ".blueprint-connection.temp"
        );
        if (tempLine) tempLine.remove();
      }

      function makeNodeDraggable(element, node) {
        let isDragging = false;
        let startX, startY;

        element.addEventListener("mousedown", (e) => {
          if (e.button !== 0) return; // Only left click
          if (e.target.classList.contains("blueprint-pin")) return; // Don't drag when clicking pins

          isDragging = true;
          startX = e.clientX - node.position.x;
          startY = e.clientY - node.position.y;
          element.classList.add("selected");
          e.preventDefault();
        });

        document.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          node.position.x = e.clientX - startX;
          node.position.y = e.clientY - startY;
          element.style.left = node.position.x + "px";
          element.style.top = node.position.y + "px";

          renderBlueprintCanvas(); // Re-render to update connections
        });

        document.addEventListener("mouseup", () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove("selected");
          }
        });
      }

      function createConnectionLine(connection) {
        // Find source and target nodes
        const blueprint = selectedObject.userData.blueprint;
        const [sourceId, sourcePinName] = connection.from.split(".");
        const [targetId, targetPinName] = connection.to.split(".");

        const sourceNode = blueprint.nodes.find((n) => n.id === sourceId);
        const targetNode = blueprint.nodes.find((n) => n.id === targetId);

        if (!sourceNode || !targetNode) return null;

        // Calculate pin positions
        const sourcePin = sourceNode.outputs.find(
          (p) => p.name === sourcePinName
        );
        const targetPin = targetNode.inputs.find(
          (p) => p.name === targetPinName
        );

        if (!sourcePin || !targetPin) return null;

        // Get actual DOM pin positions
        const sourcePinEl = document.querySelector(
          `[data-node-id="${sourceId}"] .blueprint-pin[data-pin="${sourcePinName}"][data-direction="output"]`
        );
        const targetPinEl = document.querySelector(
          `[data-node-id="${targetId}"] .blueprint-pin[data-pin="${targetPinName}"][data-direction="input"]`
        );

        if (!sourcePinEl || !targetPinEl) return null;

        const canvasRect = document
          .getElementById("blueprint-canvas")
          .getBoundingClientRect();
        const sourceRect = sourcePinEl.getBoundingClientRect();
        const targetRect = targetPinEl.getBoundingClientRect();

        const x1 = sourceRect.left - canvasRect.left + sourceRect.width / 2;
        const y1 = sourceRect.top - canvasRect.top + sourceRect.height / 2;
        const x2 = targetRect.left - canvasRect.left + targetRect.width / 2;
        const y2 = targetRect.top - canvasRect.top + targetRect.height / 2;

        // Create Bezier curve with better control points
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        const distance = Math.abs(x2 - x1);
        const controlPointOffset = Math.min(distance * 0.5, 150);

        const cx1 = x1 + controlPointOffset;
        const cy1 = y1;
        const cx2 = x2 - controlPointOffset;
        const cy2 = y2;

        path.setAttribute(
          "d",
          `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`
        );
        path.setAttribute("class", `blueprint-connection ${sourcePin.type}`);

        // Add click to delete connection
        path.style.cursor = "pointer";
        path.addEventListener("click", () => {
          if (confirm("Delete this connection?")) {
            blueprint.connections = blueprint.connections.filter(
              (c) => c !== connection
            );
            renderBlueprintCanvas();
          }
        });

        return path;
      }

      function deleteNode(nodeId) {
        if (!selectedObject || !selectedObject.userData.blueprint) return;

        const blueprint = selectedObject.userData.blueprint;

        // Remove node
        blueprint.nodes = blueprint.nodes.filter((n) => n.id !== nodeId);

        // Remove connections involving this node
        blueprint.connections = blueprint.connections.filter((conn) => {
          return (
            !conn.from.startsWith(nodeId + ".") &&
            !conn.to.startsWith(nodeId + ".")
          );
        });

        renderBlueprintCanvas();
      }

      function loadBlueprintUI() {
        if (!selectedObject) return;

        const hasBlueprint =
          selectedObject.userData.blueprint &&
          selectedObject.userData.blueprint.enabled;
        document.getElementById("has-blueprint").checked = hasBlueprint;

        const editor = document.getElementById("blueprint-editor");
        editor.style.display = hasBlueprint ? "block" : "none";

        if (hasBlueprint) {
          renderBlueprintCanvas();
        }
      }

      function executeBlueprint(obj, eventName, context) {
        if (!obj.userData.blueprint || !obj.userData.blueprint.enabled) return;

        const blueprint = obj.userData.blueprint;
        context.targetObject = obj;

        // Find event node matching the event name
        const eventNode = blueprint.nodes.find(
          (node) => node.name === eventName
        );
        if (!eventNode) return;

        console.log("ðŸ“ Blueprint Event:", eventName, "on", obj.name);

        // Execute from the event node
        executeNode(eventNode, context);
      }

      function executeNode(node, context) {
        if (!node) return;

        console.log("âš¡ Executing node:", node.name);

        // Highlight node (visual feedback)
        const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);
        if (nodeEl) {
          nodeEl.classList.add("executing");
          setTimeout(() => nodeEl.classList.remove("executing"), 500);
        }

        // Execute node logic
        switch (node.name) {
          case "Change Color":
            if (context.targetObject && context.targetObject.material) {
              const color = node.params.color || "#FF0000";
              context.targetObject.material.color.setHex(
                parseInt(color.replace("#", "0x"))
              );
              console.log("  â†’ Changed color to", color);
            }
            break;

          case "Move Object":
            if (context.targetObject) {
              const x = parseFloat(node.params.x) || 0;
              const y = parseFloat(node.params.y) || 0;
              const z = parseFloat(node.params.z) || 0;
              context.targetObject.position.set(x, y, z);
              console.log(`  â†’ Moved to (${x}, ${y}, ${z})`);
            }
            break;

          case "Destroy Object":
            if (context.targetObject) {
              scene.remove(context.targetObject);
              sceneObjects = sceneObjects.filter(
                (o) => o !== context.targetObject
              );
              console.log("  â†’ Destroyed object");
            }
            break;

          case "Log Message":
            const message = node.params.message || "Hello!";
            console.log("  â†’ Message:", message);
            break;

          case "Branch":
            const condition = node.params.condition || "Is Player";
            let result = false;
            const checkObj = context.otherObject || context.targetObject;

            if (checkObj) {
              switch (condition) {
                case "Is Player":
                  result =
                    checkObj.name === "Player" || checkObj.userData.isPlayer;
                  break;
                case "Has Tag: Enemy":
                  result = checkObj.userData.tag === "Enemy";
                  break;
                case "Has Tag: Collectible":
                  result = checkObj.userData.tag === "Collectible";
                  break;
                case "Y Position > 0":
                  result = checkObj.position.y > 0;
                  break;
                case "Y Position < 0":
                  result = checkObj.position.y < 0;
                  break;
              }
            }
            console.log(`  â†’ Branch: ${condition} = ${result}`);

            // Execute appropriate output
            const branchOutput = result ? "True" : "False";
            const nextNodes = findConnectedNodes(node.id, branchOutput);
            nextNodes.forEach((nextNode) => executeNode(nextNode, context));
            return; // Don't continue to default flow

          case "Delay":
            const duration = parseFloat(node.params.duration) || 1.0;
            console.log(`  â†’ Waiting ${duration}s...`);
            const nextDelayNodes = findConnectedNodes(node.id, "Then");
            setTimeout(() => {
              nextDelayNodes.forEach((nextNode) =>
                executeNode(nextNode, context)
              );
            }, duration * 1000);
            return; // Don't continue synchronously
        }

        // Find and execute connected nodes (default flow)
        const outputPinNames = node.outputs
          ? node.outputs.map((o) => o.name)
          : [];
        outputPinNames.forEach((pinName) => {
          const nextNodes = findConnectedNodes(node.id, pinName);
          nextNodes.forEach((nextNode) => executeNode(nextNode, context));
        });
      }

      function findConnectedNodes(nodeId, outputPinName) {
        if (!selectedObject || !selectedObject.userData.blueprint) return [];

        const blueprint = selectedObject.userData.blueprint;
        const connectionKey = `${nodeId}.${outputPinName}`;

        const connectedNodeIds = blueprint.connections
          .filter((conn) => conn.from === connectionKey)
          .map((conn) => conn.to.split(".")[0]);

        return connectedNodeIds
          .map((id) => blueprint.nodes.find((n) => n.id === id))
          .filter((n) => n !== undefined);
      }

      // ============================================
      // BLUEPRINT QUESTIONNAIRE SYSTEM
      // ============================================

      // Questionnaire State
      let questionnaireState = {
        currentStep: 0,
        totalSteps: 4,
        answers: {},
        questionHistory: [],
      };

      // Question Tree Data
      const questionTree = {
        welcome: {
          id: "welcome",
          type: "welcome",
          title: "Welcome to Blueprint AI Assistant",
          description:
            "Let me help you create powerful blueprints through simple questions.",
          features: [
            {
              icon: "âš¡",
              title: "Fast & Easy",
              text: "Create complex blueprints in seconds",
            },
            {
              icon: "ðŸŽ¯",
              title: "Guided Process",
              text: "Answer simple questions, get perfect results",
            },
            {
              icon: "ðŸš€",
              title: "Smart Templates",
              text: "Pre-built patterns for common features",
            },
          ],
        },
        root: {
          id: "root",
          question: "What would you like to create?",
          description:
            "Choose the category that best describes what you want to build.",
          type: "single-choice",
          options: [
            {
              id: "game-mechanics",
              icon: "ðŸŽ®",
              title: "Game Mechanics",
              description: "Player movement, combat, physics, controls",
              next: "game-mechanics",
            },
            {
              id: "visual-effects",
              icon: "âœ¨",
              title: "Visual Effects",
              description: "Animations, particles, color changes",
              next: "visual-effects",
            },
            {
              id: "interactions",
              icon: "ðŸ‘†",
              title: "Interactions",
              description: "Click events, triggers, collisions",
              next: "interactions",
            },
            {
              id: "simple-behavior",
              icon: "ðŸ¤–",
              title: "Simple Behavior",
              description: "Basic object behaviors and responses",
              next: "simple-behavior",
            },
          ],
        },
        "game-mechanics": {
          id: "game-mechanics",
          question: "What type of game mechanic?",
          description: "Select the specific mechanic you want to implement.",
          type: "single-choice",
          options: [
            {
              id: "movement",
              icon: "ðŸƒ",
              title: "Movement",
              description: "Move objects, jump, fly, rotate",
              next: "movement-type",
            },
            {
              id: "collection",
              icon: "ðŸ’Ž",
              title: "Collection",
              description: "Collect items, score points",
              next: "collection-type",
            },
            {
              id: "destruction",
              icon: "ðŸ’¥",
              title: "Destruction",
              description: "Destroy objects, remove from scene",
              next: "destruction-type",
            },
            {
              id: "spawning",
              icon: "ðŸŒŸ",
              title: "Spawning",
              description: "Create new objects dynamically",
              next: "spawning-type",
            },
          ],
        },
        "visual-effects": {
          id: "visual-effects",
          question: "What type of visual effect?",
          description: "Choose the visual effect you want to create.",
          type: "single-choice",
          options: [
            {
              id: "color-change",
              icon: "ðŸŽ¨",
              title: "Color Change",
              description: "Change object colors on events",
              next: "generate",
            },
            {
              id: "animation",
              icon: "ðŸ”„",
              title: "Animation",
              description: "Rotate, scale, move smoothly",
              next: "generate",
            },
            {
              id: "flash-pulse",
              icon: "ðŸ’«",
              title: "Flash/Pulse",
              description: "Pulsing or flashing effects",
              next: "generate",
            },
          ],
        },
        interactions: {
          id: "interactions",
          question: "What type of interaction?",
          description:
            "Select how you want users to interact with this object.",
          type: "single-choice",
          options: [
            {
              id: "click-action",
              icon: "ðŸ–±ï¸",
              title: "Click Action",
              description: "Respond to mouse clicks",
              next: "click-action-type",
            },
            {
              id: "collision-response",
              icon: "ðŸ’¥",
              title: "Collision Response",
              description: "React when objects collide",
              next: "collision-type",
            },
            {
              id: "trigger-zone",
              icon: "ðŸ“",
              title: "Trigger Zone",
              description: "Activate when entering area",
              next: "trigger-type",
            },
          ],
        },
        "simple-behavior": {
          id: "simple-behavior",
          question: "What should the object do?",
          description: "Choose a simple behavior for your object.",
          type: "single-choice",
          options: [
            {
              id: "auto-destroy",
              icon: "â±ï¸",
              title: "Auto Destroy",
              description: "Disappear after some time",
              next: "generate",
            },
            {
              id: "constant-rotation",
              icon: "ðŸ”",
              title: "Constant Rotation",
              description: "Spin continuously",
              next: "generate",
            },
            {
              id: "log-events",
              icon: "ðŸ“",
              title: "Log Events",
              description: "Debug with console messages",
              next: "generate",
            },
          ],
        },
        "movement-type": {
          id: "movement-type",
          question: "How should it move?",
          description: "Define the movement pattern.",
          type: "single-choice",
          options: [
            {
              id: "upward-jump",
              icon: "â¬†ï¸",
              title: "Jump Upward",
              description: "Move up when triggered",
              next: "generate",
            },
            {
              id: "forward-move",
              icon: "âž¡ï¸",
              title: "Move Forward",
              description: "Move in a direction",
              next: "generate",
            },
            {
              id: "random-position",
              icon: "ðŸŽ²",
              title: "Random Position",
              description: "Teleport to random location",
              next: "generate",
            },
          ],
        },
        "click-action-type": {
          id: "click-action-type",
          question: "What happens on click?",
          description: "Choose the action to perform when clicked.",
          type: "single-choice",
          options: [
            {
              id: "click-change-color",
              icon: "ðŸŽ¨",
              title: "Change Color",
              description: "Change to a random color",
              next: "generate",
            },
            {
              id: "click-destroy",
              icon: "ðŸ’¥",
              title: "Destroy",
              description: "Remove when clicked",
              next: "generate",
            },
            {
              id: "click-log",
              icon: "ðŸ“",
              title: "Log Message",
              description: "Show message in console",
              next: "generate",
            },
          ],
        },
      };

      // Open Questionnaire
      function openBlueprintQuestionnaire() {
        if (!selectedObject) {
          alert("Please select an object first");
          return;
        }

        // Initialize state
        questionnaireState = {
          currentStep: 0,
          totalSteps: 4,
          answers: {},
          questionHistory: ["welcome"],
        };

        // Show modal
        const modal = document.getElementById("blueprint-questionnaire-modal");
        modal.classList.add("active");

        // Render welcome screen
        renderQuestion("welcome");
      }

      // Close Questionnaire
      function closeBlueprintQuestionnaire() {
        const modal = document.getElementById("blueprint-questionnaire-modal");
        modal.classList.remove("active");
      }

      // Render Question
      function renderQuestion(questionId) {
        const question = questionTree[questionId];
        if (!question) {
          console.error("Question not found:", questionId);
          return;
        }

        const content = document.getElementById("questionnaire-content");
        const backBtn = document.getElementById("btn-questionnaire-back");
        const nextBtn = document.getElementById("btn-questionnaire-next");

        // Update progress
        const progressBar = document.getElementById(
          "questionnaire-progress-bar"
        );
        const progressText = document.getElementById(
          "questionnaire-progress-text"
        );
        const progress =
          (questionnaireState.currentStep / questionnaireState.totalSteps) *
          100;
        progressBar.style.width = progress + "%";
        progressText.textContent = `Step ${
          questionnaireState.currentStep + 1
        } of ${questionnaireState.totalSteps}`;

        // Render based on type
        if (question.type === "welcome") {
          content.innerHTML = `
                    <div class="welcome-screen">
                        <div class="welcome-icon">ðŸª„</div>
                        <div class="welcome-title">${question.title}</div>
                        <div class="welcome-description">${
                          question.description
                        }</div>
                        <div class="welcome-features">
                            ${question.features
                              .map(
                                (feature) => `
                                <div class="welcome-feature">
                                    <div class="welcome-feature-icon">${feature.icon}</div>
                                    <div class="welcome-feature-title">${feature.title}</div>
                                    <div class="welcome-feature-text">${feature.text}</div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;
          backBtn.disabled = true;
          nextBtn.textContent = "Get Started â†’";
        } else if (question.type === "single-choice") {
          content.innerHTML = `
                    <div class="questionnaire-question">
                        <div class="question-title">${question.question}</div>
                        <div class="question-description">${
                          question.description
                        }</div>
                        <div class="question-options">
                            ${question.options
                              .map(
                                (option) => `
                                <div class="option-card" data-option-id="${option.id}" data-question-id="${question.id}" data-next="${option.next}">
                                    <span class="option-icon">${option.icon}</span>
                                    <div class="option-title">${option.title}</div>
                                    <div class="option-description">${option.description}</div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

          // Add click listeners to option cards
          setTimeout(() => {
            document.querySelectorAll(".option-card").forEach((card) => {
              card.addEventListener("click", function () {
                const questionId = this.dataset.questionId;
                const optionId = this.dataset.optionId;
                const nextId = this.dataset.next;
                selectOption(questionId, optionId, nextId);
              });
            });
          }, 0);

          backBtn.disabled = questionnaireState.currentStep === 0;
          nextBtn.textContent = "Next â†’";
          nextBtn.disabled = true; // Enable after selection
        }
      }

      // Select Option
      function selectOption(questionId, optionId, nextQuestionId) {
        // Save answer
        questionnaireState.answers[questionId] = optionId;

        // Update UI
        const cards = document.querySelectorAll(".option-card");
        cards.forEach((card) => {
          card.classList.remove("selected");
          if (card.dataset.optionId === optionId) {
            card.classList.add("selected");
          }
        });

        // Enable next button
        const nextBtn = document.getElementById("btn-questionnaire-next");
        nextBtn.disabled = false;

        // Store next question for navigation
        nextBtn.dataset.nextQuestion = nextQuestionId;
      }

      // Go to Next Question
      function questionnaireNext() {
        const nextBtn = document.getElementById("btn-questionnaire-next");

        // Check if on welcome screen
        if (
          questionnaireState.questionHistory[
            questionnaireState.questionHistory.length - 1
          ] === "welcome"
        ) {
          questionnaireState.currentStep++;
          questionnaireState.questionHistory.push("root");
          renderQuestion("root");
          return;
        }

        // Get next question
        const nextQuestionId = nextBtn.dataset.nextQuestion;

        if (nextQuestionId === "generate") {
          // Generate blueprint
          generateBlueprintFromAnswers();
          closeBlueprintQuestionnaire();
          return;
        }

        // Move to next question
        questionnaireState.currentStep++;
        questionnaireState.questionHistory.push(nextQuestionId);
        renderQuestion(nextQuestionId);
      }

      // Go Back
      function questionnaireGoBack() {
        if (questionnaireState.questionHistory.length <= 1) return;

        questionnaireState.questionHistory.pop();
        questionnaireState.currentStep = Math.max(
          0,
          questionnaireState.currentStep - 1
        );

        const previousQuestionId =
          questionnaireState.questionHistory[
            questionnaireState.questionHistory.length - 1
          ];
        renderQuestion(previousQuestionId);
      }

      // Generate Blueprint from Answers
      function generateBlueprintFromAnswers() {
        if (!selectedObject) return;

        const answers = questionnaireState.answers;
        let blueprint = {
          enabled: true,
          nodes: [],
          connections: [],
        };

        // Simple template generation based on final answer
        const lastAnswer = Object.values(answers).pop();

        // Generate blueprint based on selected option
        switch (lastAnswer) {
          case "click-change-color":
            blueprint = generateClickColorChangeBlueprint();
            break;
          case "click-destroy":
            blueprint = generateClickDestroyBlueprint();
            break;
          case "click-log":
            blueprint = generateClickLogBlueprint();
            break;
          case "upward-jump":
            blueprint = generateJumpBlueprint();
            break;
          case "auto-destroy":
            blueprint = generateAutoDestroyBlueprint();
            break;
          case "constant-rotation":
            blueprint = generateConstantRotationBlueprint();
            break;
          case "color-change":
            blueprint = generateStartColorChangeBlueprint();
            break;
          default:
            blueprint = generateClickColorChangeBlueprint(); // Default
        }

        // Apply blueprint
        selectedObject.userData.blueprint = blueprint;

        // Enable blueprint checkbox
        document.getElementById("has-blueprint").checked = true;
        document.getElementById("blueprint-editor").style.display = "block";

        // Render blueprint
        renderBlueprint();

        // Show success message
        alert(
          "âœ¨ Blueprint created successfully! Your interactive behavior is ready."
        );
      }

      // Blueprint Template Generators
      function generateClickColorChangeBlueprint() {
        return {
          enabled: true,
          nodes: [
            {
              id: "node-" + Date.now() + "-1",
              type: "On Click",
              position: { x: 100, y: 100 },
            },
            {
              id: "node-" + Date.now() + "-2",
              type: "Change Color",
              position: { x: 400, y: 100 },
              params: { color: "#ff6b6b" },
            },
          ],
          connections: [
            {
              from: "node-" + Date.now() + "-1.exec",
              to: "node-" + Date.now() + "-2.exec",
            },
          ],
        };
      }

      function generateClickDestroyBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Click", position: { x: 100, y: 100 } },
            { id: id2, type: "Destroy Object", position: { x: 400, y: 100 } },
          ],
          connections: [{ from: id1 + ".exec", to: id2 + ".exec" }],
        };
      }

      function generateClickLogBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Click", position: { x: 100, y: 100 } },
            {
              id: id2,
              type: "Log Message",
              position: { x: 400, y: 100 },
              params: { message: "Object clicked!" },
            },
          ],
          connections: [{ from: id1 + ".exec", to: id2 + ".exec" }],
        };
      }

      function generateJumpBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Click", position: { x: 100, y: 100 } },
            {
              id: id2,
              type: "Move Object",
              position: { x: 400, y: 100 },
              params: { x: 0, y: 2, z: 0 },
            },
          ],
          connections: [{ from: id1 + ".exec", to: id2 + ".exec" }],
        };
      }

      function generateAutoDestroyBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        const id3 = "node-" + Date.now() + "-3";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Start", position: { x: 100, y: 100 } },
            {
              id: id2,
              type: "Delay",
              position: { x: 350, y: 100 },
              params: { duration: 3000 },
            },
            { id: id3, type: "Destroy Object", position: { x: 600, y: 100 } },
          ],
          connections: [
            { from: id1 + ".exec", to: id2 + ".exec" },
            { from: id2 + ".exec", to: id3 + ".exec" },
          ],
        };
      }

      function generateConstantRotationBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Start", position: { x: 100, y: 100 } },
            {
              id: id2,
              type: "Log Message",
              position: { x: 400, y: 100 },
              params: {
                message:
                  "Rotation started! (Note: Use animation system for continuous rotation)",
              },
            },
          ],
          connections: [{ from: id1 + ".exec", to: id2 + ".exec" }],
        };
      }

      function generateStartColorChangeBlueprint() {
        const id1 = "node-" + Date.now() + "-1";
        const id2 = "node-" + Date.now() + "-2";
        return {
          enabled: true,
          nodes: [
            { id: id1, type: "On Start", position: { x: 100, y: 100 } },
            {
              id: id2,
              type: "Change Color",
              position: { x: 400, y: 100 },
              params: { color: "#4ecdc4" },
            },
          ],
          connections: [{ from: id1 + ".exec", to: id2 + ".exec" }],
        };
      }

      // ============================================
      // PLAY MODE
      // ============================================
      function togglePlayMode() {
        isPlayMode = !isPlayMode;

        const overlay = document.getElementById("play-mode-overlay");
        const modeText = document.getElementById("mode-text");
        const modeBtn = document.getElementById("mode-toggle");
        const leftSidebar = document.getElementById("left-sidebar");
        const rightSidebar = document.getElementById("right-sidebar");

        if (isPlayMode) {
          overlay.classList.add("active");
          modeText.textContent = "Exit Play";
          modeBtn.classList.add("active");
          leftSidebar.style.display = "none";
          rightSidebar.style.display = "none";

          if (transformControls) transformControls.enabled = false;
          if (orbitControls) orbitControls.enabled = false;

          // Hide grid in play mode (save previous state)
          if (gridHelper) {
            window.gridWasVisible = gridHelper.visible;
            gridHelper.visible = false;
          }

          // Setup play camera
          if (spawnPoint) {
            camera.position.copy(spawnPoint.position);
            camera.position.y += 1.6;
            camera.rotation.y = spawnPoint.rotation.y;
          }

          // Execute "On Start" blueprints for all objects
          sceneObjects.forEach((obj) => {
            if (obj.userData.blueprint && obj.userData.blueprint.enabled) {
              executeBlueprint(obj, "On Start", {});
            }
          });

          renderer.domElement.addEventListener("click", requestPointerLock);
        } else {
          overlay.classList.remove("active");
          modeText.textContent = "Play Mode";
          modeBtn.classList.remove("active");
          leftSidebar.style.display = "flex";
          rightSidebar.style.display = "flex";

          if (transformControls) transformControls.enabled = true;
          if (orbitControls) orbitControls.enabled = true;

          // Restore grid visibility from before play mode
          if (gridHelper && window.gridWasVisible !== undefined) {
            gridHelper.visible = window.gridWasVisible;
            const checkbox = document.getElementById("show-grid-checkbox");
            if (checkbox) {
              checkbox.checked = gridHelper.visible;
            }
          }

          exitPointerLock();
        }
      }

      function requestPointerLock() {
        if (!isPlayMode) return;
        renderer.domElement.requestPointerLock();
      }

      function exitPointerLock() {
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }
      }

      document.addEventListener("pointerlockchange", () => {
        isLocked = document.pointerLockElement === renderer.domElement;
      });

      document.addEventListener("mousemove", (event) => {
        if (!isLocked || !isPlayMode) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        euler.setFromQuaternion(camera.quaternion);
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        camera.quaternion.setFromEuler(euler);
      });

      function onKeyDown(event) {
        if (isPlayMode) {
          switch (event.code) {
            case "KeyW":
            case "ArrowUp":
              moveForward = true;
              break;
            case "KeyS":
            case "ArrowDown":
              moveBackward = true;
              break;
            case "KeyA":
            case "ArrowLeft":
              moveLeft = true;
              break;
            case "KeyD":
            case "ArrowRight":
              moveRight = true;
              break;
            case "Escape":
              togglePlayMode();
              break;
          }
        } else {
          // Editor shortcuts
          if (event.ctrlKey && event.key === "z") {
            event.preventDefault();
            undo();
          }
          if (event.ctrlKey && event.key === "y") {
            event.preventDefault();
            redo();
          }
          if (event.ctrlKey && event.key === "s") {
            event.preventDefault();
            saveScene();
          }
          if (event.key === "Delete" && selectedObject) {
            deleteSelectedObject();
          }
          if (event.key === "g" && !event.ctrlKey) {
            event.preventDefault();
            toggleGrid();
          }
          if (event.key === "w" && !event.ctrlKey)
            setTransformMode("translate");
          if (event.key === "e" && !event.ctrlKey) setTransformMode("rotate");
          if (event.key === "r" && !event.ctrlKey) setTransformMode("scale");
        }
      }

      function onKeyUp(event) {
        if (!isPlayMode) return;

        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            moveForward = false;
            break;
          case "KeyS":
          case "ArrowDown":
            moveBackward = false;
            break;
          case "KeyA":
          case "ArrowLeft":
            moveLeft = false;
            break;
          case "KeyD":
          case "ArrowRight":
            moveRight = false;
            break;
        }
      }

      // ============================================
      // UNDO/REDO
      // ============================================
      function saveUndoState(object, actionType = "transform") {
        const state = {
          object: object,
          objectId: object.uuid,
          name: object.name || object.type,
          actionType: actionType,
          position: object.position.clone(),
          rotation: new THREE.Euler().copy(object.rotation),
          scale: object.scale.clone(),
          timestamp: Date.now(),
        };

        undoStack.push(state);
        if (undoStack.length > MAX_UNDO_HISTORY) undoStack.shift();
        redoStack = [];
      }

      function undo() {
        if (undoStack.length === 0) return;

        const state = undoStack.pop();
        const redoState = {
          object: state.object,
          objectId: state.objectId,
          name: state.name,
          actionType: state.actionType,
          position: state.object.position.clone(),
          rotation: new THREE.Euler().copy(state.object.rotation),
          scale: state.object.scale.clone(),
          timestamp: Date.now(),
        };
        redoStack.push(redoState);

        state.object.position.copy(state.position);
        state.object.rotation.copy(state.rotation);
        state.object.scale.copy(state.scale);

        if (selectedObject === state.object) {
          updatePropertiesPanel();
          if (objectHighlight) objectHighlight.update();
        }
      }

      function redo() {
        if (redoStack.length === 0) return;

        const state = redoStack.pop();
        const undoState = {
          object: state.object,
          objectId: state.objectId,
          name: state.name,
          actionType: state.actionType,
          position: state.object.position.clone(),
          rotation: new THREE.Euler().copy(state.object.rotation),
          scale: state.object.scale.clone(),
          timestamp: Date.now(),
        };
        undoStack.push(undoState);

        state.object.position.copy(state.position);
        state.object.rotation.copy(state.rotation);
        state.object.scale.copy(state.scale);

        if (selectedObject === state.object) {
          updatePropertiesPanel();
          if (objectHighlight) objectHighlight.update();
        }
      }

      // ============================================
      // SAVE/LOAD
      // ============================================
      function saveScene() {
        const sceneData = {
          version: "1.0",
          objects: sceneObjects.map((obj) => {
            const data = {
              type: obj.type,
              name: obj.name,
              position: obj.position.toArray(),
              rotation: obj.rotation.toArray(),
              scale: obj.scale.toArray(),
              userData: obj.userData,
              isLight: obj.isLight || false,
            };

            if (obj.geometry) {
              data.geometryType = obj.geometry.type;
              data.geometryParams = obj.geometry.parameters;
            }

            if (obj.material) {
              data.material = {
                color: obj.material.color.getHex(),
                roughness: obj.material.roughness,
                metalness: obj.material.metalness,
                side: obj.material.side,
              };
            }

            if (obj.isLight) {
              data.lightColor = obj.color.getHex();
              data.lightIntensity = obj.intensity;
              data.lightDistance = obj.distance;
            }

            return data;
          }),
          scene: {
            backgroundColor: "#" + scene.background.getHexString(),
            fog: scene.fog
              ? {
                  enabled: true,
                  distance: document.getElementById("fog-distance").value,
                }
              : { enabled: false },
            ambientLightIntensity: ambientLight.intensity,
            sunLightIntensity: directionalLight.intensity,
          },
          camera: {
            position: camera.position.toArray(),
            rotation: camera.rotation.toArray(),
          },
        };

        const json = JSON.stringify(sceneData, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.href = url;
        link.download = "scene-" + Date.now() + ".json";
        link.click();

        URL.revokeObjectURL(url);
      }

      function loadScene() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";

        input.onchange = (event) => {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const sceneData = JSON.parse(e.target.result);

              // Clear scene
              while (sceneObjects.length > 0) {
                const obj = sceneObjects[0];
                scene.remove(obj);
                sceneObjects.shift();
              }
              colliderObjects = [];
              spawnPoint = null;

              // Restore objects
              sceneData.objects.forEach((data) => {
                let object;

                if (data.isLight) {
                  if (data.type === "PointLight") {
                    object = new THREE.PointLight(
                      data.lightColor,
                      data.lightIntensity,
                      data.lightDistance
                    );
                    const sphere = new THREE.Mesh(
                      new THREE.SphereGeometry(0.2, 8, 8),
                      new THREE.MeshBasicMaterial({ color: 0xffff00 })
                    );
                    object.add(sphere);
                  } else if (data.type === "SpotLight") {
                    object = new THREE.SpotLight(
                      data.lightColor,
                      data.lightIntensity,
                      data.lightDistance
                    );
                    const cone = new THREE.Mesh(
                      new THREE.ConeGeometry(0.3, 0.6, 8),
                      new THREE.MeshBasicMaterial({ color: 0xffff00 })
                    );
                    cone.rotation.x = Math.PI;
                    object.add(cone);
                  }
                  object.castShadow = true;
                } else if (data.userData.isSpawnPoint) {
                  object = createSpawnPoint();
                  spawnPoint = object;
                } else if (data.type === "Group") {
                  object = new THREE.Group();
                } else if (data.type === "Mesh") {
                  // Recreate geometry
                  let geometry;
                  // ... (geometry recreation logic)

                  const material = new THREE.MeshStandardMaterial(
                    data.material
                  );
                  object = new THREE.Mesh(geometry, material);
                  object.castShadow = true;
                  object.receiveShadow = true;
                }

                if (object) {
                  object.name = data.name;
                  object.position.fromArray(data.position);
                  object.rotation.fromArray(data.rotation);
                  object.scale.fromArray(data.scale);
                  object.userData = data.userData;

                  if (data.userData.hasCollision) {
                    addCollider(object);
                  }

                  // Recreate physics body if object has physics
                  if (data.userData.hasPhysics) {
                    createPhysicsBody(object);
                  }

                  scene.add(object);
                  sceneObjects.push(object);
                }
              });

              // Restore scene settings
              if (sceneData.scene) {
                scene.background.setStyle(sceneData.scene.backgroundColor);
                document.getElementById("bg-color").value =
                  sceneData.scene.backgroundColor;

                if (sceneData.scene.fog.enabled) {
                  document.getElementById("fog-enabled").checked = true;
                  document.getElementById("fog-distance").value =
                    sceneData.scene.fog.distance;
                  updateFog();
                }

                ambientLight.intensity = sceneData.scene.ambientLightIntensity;
                directionalLight.intensity = sceneData.scene.sunLightIntensity;
              }

              // Restore camera
              if (sceneData.camera) {
                camera.position.fromArray(sceneData.camera.position);
                camera.rotation.fromArray(sceneData.camera.rotation);
              }

              updateHierarchy();
              updateCollisionList();
              updateSpawnInfo();
              deselectObject();
            } catch (err) {
              alert("Error loading scene: " + err.message);
            }
          };
          reader.readAsText(file);
        };

        input.click();
      }

      function exportCode() {
        // Get scene data (same as saveScene)
        const sceneData = {
          version: "1.0",
          objects: sceneObjects.map((obj) => {
            const data = {
              type: obj.type,
              name: obj.name,
              position: obj.position.toArray(),
              rotation: obj.rotation.toArray(),
              scale: obj.scale.toArray(),
              userData: obj.userData,
              isLight: obj.isLight || false,
            };

            if (obj.geometry) {
              data.geometryType = obj.geometry.type;
              data.geometryParams = obj.geometry.parameters;
            }

            if (obj.material) {
              data.material = {
                color: obj.material.color.getHex(),
                roughness: obj.material.roughness,
                metalness: obj.material.metalness,
                side: obj.material.side,
              };
            }

            if (obj.isLight) {
              data.lightColor = obj.color.getHex();
              data.lightIntensity = obj.intensity;
              data.lightDistance = obj.distance;
            }

            return data;
          }),
          scene: {
            backgroundColor: "#" + scene.background.getHexString(),
            fog: scene.fog
              ? {
                  enabled: true,
                  distance: document.getElementById("fog-distance").value,
                }
              : { enabled: false },
            ambientLightIntensity: ambientLight.intensity,
            sunLightIntensity: directionalLight.intensity,
          },
          camera: {
            position: camera.position.toArray(),
            rotation: camera.rotation.toArray(),
          },
        };

        // Generate standalone HTML
        const html = generateStandaloneHTML(sceneData);

        // Download the file
        const blob = new Blob([html], { type: "text/html" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "game-" + Date.now() + ".html";
        link.click();
        URL.revokeObjectURL(url);

        alert("âœ… Game exported successfully! Open the HTML file in your browser to play.");
      }

      function generateStandaloneHTML(sceneData) {
        return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      background: #000;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px 40px;
      border-radius: 10px;
      text-align: center;
      font-size: 16px;
      z-index: 1000;
    }
    #instructions h1 {
      margin-bottom: 20px;
      font-size: 24px;
    }
    #instructions p {
      margin: 10px 0;
    }
    #instructions button {
      margin-top: 20px;
      padding: 12px 30px;
      font-size: 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #instructions button:hover {
      background: #45a049;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="instructions">
    <h1>ðŸŽ® Game Controls</h1>
    <p><strong>WASD</strong> - Move</p>
    <p><strong>Mouse</strong> - Look around</p>
    <p><strong>ESC</strong> - Exit game</p>
    <button id="startBtn">Click to Start</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <script>
    // Scene data embedded from editor
    const SCENE_DATA = ${JSON.stringify(sceneData, null, 2)};

    // Global variables
    let scene, camera, renderer;
    let sceneObjects = [];
    let physicsWorld, physicsBodies = new Map();
    let isLocked = false;

    // Movement controls
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();

    // Initialize the game
    function init() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(SCENE_DATA.scene.backgroundColor);

      // Add fog if enabled
      if (SCENE_DATA.scene.fog && SCENE_DATA.scene.fog.enabled) {
        scene.fog = new THREE.Fog(scene.background, 1, SCENE_DATA.scene.fog.distance);
      }

      // Create camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.fromArray(SCENE_DATA.camera.position);
      camera.rotation.fromArray(SCENE_DATA.camera.rotation);

      // Create renderer
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, SCENE_DATA.scene.ambientLightIntensity);
      scene.add(ambientLight);

      // Add directional light (sun)
      const directionalLight = new THREE.DirectionalLight(0xffffff, SCENE_DATA.scene.sunLightIntensity);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Initialize physics
      physicsWorld = new CANNON.World();
      physicsWorld.gravity.set(0, -9.82, 0);
      physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);

      // Load scene objects
      loadSceneObjects();

      // Setup controls
      setupControls();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);

      // Start animation loop
      animate();
    }

    function loadSceneObjects() {
      SCENE_DATA.objects.forEach(objData => {
        let obj;

        // Create lights
        if (objData.isLight) {
          if (objData.name.includes('Point')) {
            obj = new THREE.PointLight(
              objData.lightColor,
              objData.lightIntensity,
              objData.lightDistance
            );
          } else if (objData.name.includes('Spot')) {
            obj = new THREE.SpotLight(
              objData.lightColor,
              objData.lightIntensity,
              objData.lightDistance
            );
          }
          obj.castShadow = true;
        }
        // Create meshes
        else if (objData.geometryType) {
          let geometry;
          const params = objData.geometryParams || {};

          switch (objData.geometryType) {
            case 'BoxGeometry':
              geometry = new THREE.BoxGeometry(
                params.width || 1,
                params.height || 1,
                params.depth || 1
              );
              break;
            case 'SphereGeometry':
              geometry = new THREE.SphereGeometry(
                params.radius || 0.5,
                params.widthSegments || 32,
                params.heightSegments || 32
              );
              break;
            case 'CylinderGeometry':
              geometry = new THREE.CylinderGeometry(
                params.radiusTop || 0.5,
                params.radiusBottom || 0.5,
                params.height || 1,
                params.radialSegments || 32
              );
              break;
            case 'PlaneGeometry':
              geometry = new THREE.PlaneGeometry(
                params.width || 1,
                params.height || 1
              );
              break;
            case 'ConeGeometry':
              geometry = new THREE.ConeGeometry(
                params.radius || 0.5,
                params.height || 1,
                params.radialSegments || 32
              );
              break;
            case 'TorusGeometry':
              geometry = new THREE.TorusGeometry(
                params.radius || 0.5,
                params.tube || 0.2,
                params.radialSegments || 16,
                params.tubularSegments || 100
              );
              break;
            default:
              geometry = new THREE.BoxGeometry(1, 1, 1);
          }

          const material = new THREE.MeshStandardMaterial({
            color: objData.material.color,
            roughness: objData.material.roughness,
            metalness: objData.material.metalness,
            side: objData.material.side
          });

          obj = new THREE.Mesh(geometry, material);
          obj.castShadow = true;
          obj.receiveShadow = true;
        }

        if (obj) {
          obj.name = objData.name;
          obj.position.fromArray(objData.position);
          obj.rotation.fromArray(objData.rotation);
          obj.scale.fromArray(objData.scale);
          obj.userData = objData.userData || {};

          scene.add(obj);
          sceneObjects.push(obj);

          // Add physics body if needed
          if (obj.userData.hasPhysics) {
            addPhysicsBody(obj);
          }
        }
      });

      // Execute "On Start" blueprints
      sceneObjects.forEach(obj => {
        if (obj.userData.blueprint && obj.userData.blueprint.enabled) {
          executeBlueprint(obj, "On Start", {});
        }
      });
    }

    function addPhysicsBody(obj) {
      let shape;

      if (obj.geometry) {
        if (obj.geometry.type === 'BoxGeometry') {
          const params = obj.geometry.parameters;
          shape = new CANNON.Box(new CANNON.Vec3(
            (params.width || 1) / 2,
            (params.height || 1) / 2,
            (params.depth || 1) / 2
          ));
        } else if (obj.geometry.type === 'SphereGeometry') {
          const params = obj.geometry.parameters;
          shape = new CANNON.Sphere(params.radius || 0.5);
        } else {
          // Default to box
          shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
        }
      } else {
        shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
      }

      const body = new CANNON.Body({
        mass: obj.userData.bodyType === 'dynamic' ? 1 : 0,
        shape: shape,
        position: new CANNON.Vec3(
          obj.position.x,
          obj.position.y,
          obj.position.z
        )
      });

      physicsWorld.addBody(body);
      physicsBodies.set(obj.uuid, body);
    }

    function setupControls() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = true; break;
          case 'KeyS': moveBackward = true; break;
          case 'KeyA': moveLeft = true; break;
          case 'KeyD': moveRight = true; break;
        }
      });

      document.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = false; break;
          case 'KeyS': moveBackward = false; break;
          case 'KeyA': moveLeft = false; break;
          case 'KeyD': moveRight = false; break;
        }
      });

      // Pointer lock
      const startBtn = document.getElementById('startBtn');
      const instructions = document.getElementById('instructions');

      startBtn.addEventListener('click', () => {
        document.body.requestPointerLock();
      });

      document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === document.body;
        instructions.classList.toggle('hidden', isLocked);
      });

      // Mouse movement
      document.addEventListener('mousemove', (e) => {
        if (!isLocked) return;

        const movementX = e.movementX || 0;
        const movementY = e.movementY || 0;

        camera.rotation.y -= movementX * 0.002;
        camera.rotation.x -= movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
      });
    }

    function executeBlueprint(obj, eventName, context) {
      if (!obj.userData.blueprint || !obj.userData.blueprint.enabled) return;

      const blueprint = obj.userData.blueprint;
      context.targetObject = obj;

      const eventNode = blueprint.nodes.find(node => node.name === eventName);
      if (!eventNode) return;

      executeNode(eventNode, context);
    }

    function executeNode(node, context) {
      if (!node) return;

      switch (node.name) {
        case "Change Color":
          if (context.targetObject && context.targetObject.material) {
            const color = node.params.color || "#FF0000";
            context.targetObject.material.color.setHex(
              parseInt(color.replace("#", "0x"))
            );
          }
          break;

        case "Move Object":
          if (context.targetObject) {
            const x = parseFloat(node.params.x) || 0;
            const y = parseFloat(node.params.y) || 0;
            const z = parseFloat(node.params.z) || 0;
            context.targetObject.position.set(x, y, z);
          }
          break;

        case "Destroy Object":
          if (context.targetObject) {
            scene.remove(context.targetObject);
            sceneObjects = sceneObjects.filter(o => o !== context.targetObject);
          }
          break;

        case "Log Message":
          const message = node.params.message || "Hello!";
          console.log("Blueprint:", message);
          break;

        case "Branch":
          const condition = node.params.condition || "Is Player";
          let result = false;
          const checkObj = context.otherObject || context.targetObject;

          if (checkObj) {
            switch (condition) {
              case "Is Player":
                result = checkObj.name === "Player" || checkObj.userData.isPlayer;
                break;
              case "Has Tag: Enemy":
                result = checkObj.userData.tag === "Enemy";
                break;
              case "Has Tag: Collectible":
                result = checkObj.userData.tag === "Collectible";
                break;
              case "Y Position > 0":
                result = checkObj.position.y > 0;
                break;
              case "Y Position < 0":
                result = checkObj.position.y < 0;
                break;
            }
          }

          const branchOutput = result ? "True" : "False";
          const nextNodes = findConnectedNodes(node.id, branchOutput);
          nextNodes.forEach(nextNode => executeNode(nextNode, context));
          return;

        case "Delay":
          const delay = parseFloat(node.params.delay) || 1.0;
          setTimeout(() => {
            const nextNodes = findConnectedNodes(node.id, "Execute");
            nextNodes.forEach(nextNode => executeNode(nextNode, context));
          }, delay * 1000);
          return;
      }

      // Continue to next connected node
      const nextNodes = findConnectedNodes(node.id, "Execute");
      nextNodes.forEach(nextNode => executeNode(nextNode, context));
    }

    function findConnectedNodes(nodeId, outputPin) {
      const blueprint = sceneObjects.find(obj =>
        obj.userData.blueprint &&
        obj.userData.blueprint.nodes.some(n => n.id === nodeId)
      )?.userData.blueprint;

      if (!blueprint) return [];

      const connections = blueprint.connections.filter(conn =>
        conn.from === nodeId + "." + outputPin
      );

      return connections.map(conn => {
        const targetNodeId = conn.to.split('.')[0];
        return blueprint.nodes.find(n => n.id === targetNodeId);
      }).filter(Boolean);
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = 0.016;

      if (isLocked) {
        // Movement
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveLeft) - Number(moveRight);
        direction.normalize();

        const speed = 50;
        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        camera.translateX(velocity.x * delta);
        camera.translateZ(velocity.z * delta);
      }

      // Update physics
      if (physicsWorld) {
        physicsWorld.step(1/60, delta, 3);

        physicsBodies.forEach((body, uuid) => {
          const obj = sceneObjects.find(o => o.uuid === uuid);
          if (obj && obj.userData.hasPhysics && obj.userData.bodyType === 'dynamic') {
            obj.position.copy(body.position);
            obj.quaternion.copy(body.quaternion);
          }
        });
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Start the game
    init();
  </script>
</body>
</html>`;
      }

      // ============================================
      // ANIMATION LOOP
      // ============================================
      function animate() {
        requestAnimationFrame(animate);

        const delta = 0.016; // ~60fps
        const time = performance.now() * 0.001; // Time in seconds

        if (isPlayMode && isLocked) {
          // Play mode movement
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveLeft) - Number(moveRight); // FIXED: was reversed
          direction.normalize();

          const speed = 50; // INCREASED: was 10, now much faster
          if (moveForward || moveBackward)
            velocity.z -= direction.z * speed * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

          camera.translateX(velocity.x * delta);
          camera.translateZ(velocity.z * delta);
        } else {
          if (orbitControls) orbitControls.update();
        }

        // Update physics simulation
        if (physicsWorld && physicsEnabled) {
          const physicsStep = delta * physicsTimeScale;
          physicsWorld.step(1 / 60, physicsStep, 3);

          // Sync THREE.js objects with physics bodies
          physicsBodies.forEach((body, uuid) => {
            const obj = sceneObjects.find((o) => o.uuid === uuid);
            if (
              obj &&
              obj.userData.hasPhysics &&
              obj.userData.bodyType === "dynamic"
            ) {
              // Update object position/rotation from physics
              obj.position.copy(body.position);
              obj.quaternion.copy(body.quaternion);
            }
          });

          // Handle collision exit events
          physicsBodies.forEach((body, uuid) => {
            const obj = sceneObjects.find((o) => o.uuid === uuid);
            if (obj && obj.userData.physicsCollisions) {
              // Check which collisions from last frame are no longer happening
              const previousCollisions = new Set(
                obj.userData.physicsCollisions
              );
              obj.userData.physicsCollisions.clear();

              // The 'collide' event adds back current collisions
              // After a frame, anything still in previousCollisions but not in current = exit

              // We need to defer this check until after collide events fire
              setTimeout(() => {
                previousCollisions.forEach((otherUuid) => {
                  if (!obj.userData.physicsCollisions.has(otherUuid)) {
                    // Collision ended
                    const otherObj = sceneObjects.find(
                      (o) => o.uuid === otherUuid
                    );
                    if (otherObj) {
                      executeCallback(obj, "exit", otherObj, null);
                    }
                  }
                });
              }, 0);
            }
          });
        }

        // Update collider helpers
        if (showColliderHelpers) {
          colliderHelpers.forEach((helper) => helper.update());
        }

        // Basic collision detection (respects layer/mask filtering)
        if (isPlayMode && colliderObjects.length > 0) {
          detectCollisions();
        }

        // Visual feedback for active triggers
        if (showColliderHelpers && isPlayMode) {
          colliderHelpers.forEach((helper, index) => {
            const obj = colliderObjects[index];
            if (
              obj &&
              obj.userData.isTrigger &&
              obj.userData.activeTriggers &&
              obj.userData.activeTriggers.size > 0
            ) {
              // Pulse active triggers
              const pulse = Math.sin(time * 5) * 0.3 + 0.7;
              helper.material.opacity = pulse;
              helper.material.transparent = true;
            } else if (helper.material) {
              helper.material.opacity = 1.0;
              helper.material.transparent = false;
            }
          });
        }

        // TEMPLATE ANIMATION SYSTEM
        // Animate objects with custom animation functions
        sceneObjects.forEach((obj) => {
          if (
            obj &&
            obj.userData &&
            obj.userData.animate &&
            typeof obj.userData.animate === "function"
          ) {
            obj.userData.animate.call(obj, time, delta);
          }
        });

        renderer.render(scene, camera);

        // Update performance monitoring
        updatePerformanceMonitor();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ============================================
      // MOBILE & TOOLTIP SYSTEM
      // ============================================

      // Mobile panel management
      let currentMobilePanel = null;

      function toggleHamburger() {
        const hamburger = document.getElementById("hamburger-btn");
        const leftSidebar = document.getElementById("left-sidebar");
        const overlay = document.getElementById("panel-overlay");

        hamburger.classList.toggle("active");
        leftSidebar.classList.toggle("mobile-open");
        overlay.classList.toggle("active");

        if (leftSidebar.classList.contains("mobile-open")) {
          currentMobilePanel = "left";
        } else {
          currentMobilePanel = null;
        }
      }

      function toggleMobilePanel(panel) {
        const leftSidebar = document.getElementById("left-sidebar");
        const rightSidebar = document.getElementById("right-sidebar");
        const overlay = document.getElementById("panel-overlay");
        const navItems = document.querySelectorAll(".mobile-nav-item");

        // Remove active class from all nav items
        navItems.forEach((item) => item.classList.remove("active"));

        if (panel === "assets") {
          event.currentTarget.classList.add("active");
          leftSidebar.classList.add("mobile-open");
          rightSidebar.classList.remove("mobile-open");
          overlay.classList.add("active");
          currentMobilePanel = "left";
          switchLeftTab("assets");
        } else if (panel === "tools") {
          event.currentTarget.classList.add("active");
          rightSidebar.classList.add("mobile-open");
          leftSidebar.classList.remove("mobile-open");
          overlay.classList.add("active");
          currentMobilePanel = "right";
          switchRightTab("properties");
        } else if (panel === "properties") {
          event.currentTarget.classList.add("active");
          rightSidebar.classList.add("mobile-open");
          leftSidebar.classList.remove("mobile-open");
          overlay.classList.add("active");
          currentMobilePanel = "right";
          switchRightTab("properties");
        } else if (panel === "menu") {
          event.currentTarget.classList.add("active");
          rightSidebar.classList.add("mobile-open");
          leftSidebar.classList.remove("mobile-open");
          overlay.classList.add("active");
          currentMobilePanel = "right";
          switchRightTab("scene");
        }
      }

      function togglePlayMode() {
        const playBtn = document.getElementById("mode-toggle");
        if (playBtn) {
          playBtn.click();
        }
        closeMobilePanels();
      }

      function closeMobilePanels() {
        const leftSidebar = document.getElementById("left-sidebar");
        const rightSidebar = document.getElementById("right-sidebar");
        const overlay = document.getElementById("panel-overlay");
        const hamburger = document.getElementById("hamburger-btn");

        leftSidebar.classList.remove("mobile-open");
        rightSidebar.classList.remove("mobile-open");
        overlay.classList.remove("active");
        hamburger.classList.remove("active");
        currentMobilePanel = null;
      }

      // Tooltip System
      const tooltipElement = document.getElementById("tooltip");
      let tooltipTimeout = null;

      function showTooltip(text, element, position = "top") {
        if (!text || !element || !tooltipElement) return;

        clearTimeout(tooltipTimeout);

        tooltipTimeout = setTimeout(() => {
          tooltipElement.textContent = text;
          tooltipElement.className = "tooltip " + position;

          const rect = element.getBoundingClientRect();
          let top, left;

          switch (position) {
            case "top":
              top = rect.top - tooltipElement.offsetHeight - 10;
              left =
                rect.left + rect.width / 2 - tooltipElement.offsetWidth / 2;
              break;
            case "bottom":
              top = rect.bottom + 10;
              left =
                rect.left + rect.width / 2 - tooltipElement.offsetWidth / 2;
              break;
            case "left":
              top =
                rect.top + rect.height / 2 - tooltipElement.offsetHeight / 2;
              left = rect.left - tooltipElement.offsetWidth - 10;
              break;
            case "right":
              top =
                rect.top + rect.height / 2 - tooltipElement.offsetHeight / 2;
              left = rect.right + 10;
              break;
          }

          // Keep tooltip in viewport
          if (top < 10) top = rect.bottom + 10;
          if (left < 10) left = 10;
          if (left + tooltipElement.offsetWidth > window.innerWidth - 10) {
            left = window.innerWidth - tooltipElement.offsetWidth - 10;
          }

          tooltipElement.style.top = top + "px";
          tooltipElement.style.left = left + "px";
          tooltipElement.classList.add("show");
        }, 500); // 500ms delay before showing
      }

      function hideTooltip() {
        clearTimeout(tooltipTimeout);
        if (tooltipElement) {
          tooltipElement.classList.remove("show");
        }
      }

      // Initialize tooltips on all elements with data-tooltip attribute
      function initTooltips() {
        document.querySelectorAll("[data-tooltip]").forEach((element) => {
          element.addEventListener("mouseenter", function (e) {
            const text = this.getAttribute("data-tooltip");
            const position =
              this.getAttribute("data-tooltip-position") || "top";
            showTooltip(text, this, position);
          });

          element.addEventListener("mouseleave", hideTooltip);
        });
      }

      // Touch gesture support
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isPinching = false;
      let initialPinchDistance = 0;

      function handleTouchStart(e) {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
        } else if (e.touches.length === 2) {
          isPinching = true;
          initialPinchDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
        }
      }

      function handleTouchMove(e) {
        if (isPinching && e.touches.length === 2) {
          const currentDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          const scale = currentDistance / initialPinchDistance;

          // Zoom camera based on pinch
          if (camera && !isPlayMode) {
            const newZ = Math.max(2, Math.min(50, camera.position.z / scale));
            camera.position.z = newZ;
          }

          initialPinchDistance = currentDistance;
          e.preventDefault();
        }
      }

      function handleTouchEnd(e) {
        if (e.touches.length < 2) {
          isPinching = false;
        }

        if (e.touches.length === 0) {
          const touchDuration = Date.now() - touchStartTime;
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const deltaX = touchEndX - touchStartX;
          const deltaY = touchEndY - touchStartY;

          // Detect swipe gestures
          if (Math.abs(deltaX) > 100 && touchDuration < 300) {
            if (deltaX > 0 && currentMobilePanel === null) {
              // Swipe right - open left panel
              toggleMobilePanel("assets");
            } else if (deltaX < 0 && currentMobilePanel !== null) {
              // Swipe left - close panel
              closeMobilePanels();
            }
          }
        }
      }

      // Add touch event listeners
      function initTouchGestures() {
        const canvas = document.getElementById("canvas");
        if (canvas) {
          canvas.addEventListener("touchstart", handleTouchStart, {
            passive: false,
          });
          canvas.addEventListener("touchmove", handleTouchMove, {
            passive: false,
          });
          canvas.addEventListener("touchend", handleTouchEnd, {
            passive: false,
          });
        }
      }

      // Close mobile panels when clicking outside
      document.addEventListener("click", function (e) {
        if (window.innerWidth <= 768) {
          const leftSidebar = document.getElementById("left-sidebar");
          const rightSidebar = document.getElementById("right-sidebar");
          const hamburger = document.getElementById("hamburger-btn");

          if (
            !leftSidebar.contains(e.target) &&
            !rightSidebar.contains(e.target) &&
            !hamburger.contains(e.target) &&
            !e.target.classList.contains("mobile-nav-item")
          ) {
            closeMobilePanels();
          }
        }
      });

      // ESC key to close mobile panels
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && currentMobilePanel !== null) {
          closeMobilePanels();
        }
      });

      // ============================================
      // PHASE 1.3: UI ORGANIZATION & ENHANCEMENT FUNCTIONS
      // ============================================

      // Search functionality
      let searchResults = [];

      function searchAssets(query) {
        const searchInput = document.getElementById("asset-search");
        const searchClear = document.getElementById("search-clear");
        const assetItems = document.querySelectorAll(".asset-item");

        // Show/hide clear button
        if (query.length > 0) {
          searchClear.classList.add("show");
        } else {
          searchClear.classList.remove("show");
        }

        // Filter assets
        query = query.toLowerCase();
        let visibleCount = 0;

        assetItems.forEach((item) => {
          const itemName = item.querySelector(".asset-item-name");
          if (itemName) {
            const text = itemName.textContent.toLowerCase();
            const tooltip = item.getAttribute("data-tooltip") || "";

            if (text.includes(query) || tooltip.toLowerCase().includes(query)) {
              item.style.display = "flex";
              visibleCount++;
            } else {
              item.style.display = "none";
            }
          }
        });

        // Show "no results" message if needed
        const assetPanels = document.querySelectorAll(".asset-grid");
        assetPanels.forEach((panel) => {
          let hasVisible = false;
          panel.querySelectorAll(".asset-item").forEach((item) => {
            if (item.style.display !== "none") {
              hasVisible = true;
            }
          });

          // Hide section title if no results
          const sectionTitle = panel.previousElementSibling;
          if (
            sectionTitle &&
            sectionTitle.classList.contains("section-title")
          ) {
            sectionTitle.style.display = hasVisible ? "block" : "none";
          }
        });
      }

      function clearSearch() {
        const searchInput = document.getElementById("asset-search");
        const searchClear = document.getElementById("search-clear");
        searchInput.value = "";
        searchClear.classList.remove("show");
        searchAssets("");
      }

      // UI Mode Toggle (Beginner / Advanced)
      let currentUIMode = "beginner";

      function setUIMode(mode) {
        currentUIMode = mode;
        const buttons = document.querySelectorAll(".ui-mode-btn");
        buttons.forEach((btn) => btn.classList.remove("active"));

        if (mode === "advanced") {
          document.body.classList.add("advanced-mode");
          buttons[1].classList.add("active");
        } else {
          document.body.classList.remove("advanced-mode");
          buttons[0].classList.add("active");
        }

        // Save preference
        localStorage.setItem("ui-mode", mode);
      }

      // Workspace Presets
      let currentWorkspace = "general";

      function setWorkspacePreset(preset) {
        currentWorkspace = preset;
        const buttons = document.querySelectorAll(".workspace-preset-btn");
        buttons.forEach((btn) => btn.classList.remove("active"));
        event.currentTarget.classList.add("active");

        // Apply workspace-specific layout changes
        switch (preset) {
          case "modeling":
            // Focus on assets and transform tools
            if (
              !document
                .getElementById("left-sidebar")
                .classList.contains("mobile-open")
            ) {
              document.getElementById("left-sidebar").style.display = "flex";
            }
            switchLeftTab("assets");
            break;
          case "lighting":
            // Focus on lights and materials
            switchRightTab("scene");
            break;
          case "animation":
            // Focus on timeline (future feature)
            console.log("Animation workspace selected (coming soon)");
            break;
          case "scripting":
            // Focus on code editor (future feature)
            console.log("Scripting workspace selected (coming soon)");
            break;
          default:
            // General layout
            break;
        }

        // Save preference
        localStorage.setItem("workspace-preset", preset);
      }

      // Keyboard Shortcuts Overlay
      function toggleShortcuts() {
        const overlay = document.getElementById("shortcuts-overlay");
        overlay.classList.toggle("show");
      }

      // Favorites System
      let favorites = JSON.parse(localStorage.getItem("favorites") || "[]");

      function toggleFavorite(assetType) {
        const index = favorites.indexOf(assetType);
        if (index > -1) {
          favorites.splice(index, 1);
        } else {
          favorites.push(assetType);
        }
        localStorage.setItem("favorites", JSON.stringify(favorites));
        updateFavoritesUI();
      }

      function updateFavoritesUI() {
        document.querySelectorAll(".favorite-star").forEach((star) => {
          const assetType = star.getAttribute("data-asset");
          if (favorites.includes(assetType)) {
            star.classList.add("active");
          } else {
            star.classList.remove("active");
          }
        });
      }

      // Recent Items System
      let recentItems = JSON.parse(localStorage.getItem("recentItems") || "[]");
      const MAX_RECENT = 10;

      function addToRecent(assetType, assetName) {
        const item = {
          type: assetType,
          name: assetName,
          timestamp: Date.now(),
        };

        // Remove if already exists
        recentItems = recentItems.filter((i) => i.type !== assetType);

        // Add to front
        recentItems.unshift(item);

        // Limit to MAX_RECENT
        if (recentItems.length > MAX_RECENT) {
          recentItems = recentItems.slice(0, MAX_RECENT);
        }

        localStorage.setItem("recentItems", JSON.stringify(recentItems));
      }

      function getTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        if (seconds < 60) return "Just now";
        if (seconds < 3600) return Math.floor(seconds / 60) + "m ago";
        if (seconds < 86400) return Math.floor(seconds / 3600) + "h ago";
        return Math.floor(seconds / 86400) + "d ago";
      }

      // Global keyboard shortcuts
      document.addEventListener("keydown", function (e) {
        // F1 - Show shortcuts
        if (e.key === "F1") {
          e.preventDefault();
          toggleShortcuts();
        }

        // Ctrl+S - Save
        if (e.ctrlKey && e.key === "s") {
          e.preventDefault();
          saveScene();
        }

        // Ctrl+Z - Undo
        if (e.ctrlKey && e.key === "z" && !e.shiftKey) {
          e.preventDefault();
          undo();
        }

        // Ctrl+Y or Ctrl+Shift+Z - Redo
        if (
          (e.ctrlKey && e.key === "y") ||
          (e.ctrlKey && e.shiftKey && e.key === "z")
        ) {
          e.preventDefault();
          redo();
        }

        // Ctrl+F - Search
        if (e.ctrlKey && e.key === "f") {
          e.preventDefault();
          const searchInput = document.getElementById("asset-search");
          if (searchInput) {
            searchInput.focus();
          }
        }

        // W - Move mode
        if (
          e.key === "w" &&
          !e.ctrlKey &&
          !e.altKey &&
          document.activeElement.tagName !== "INPUT"
        ) {
          setTransformMode("translate");
        }

        // E - Rotate mode
        if (
          e.key === "e" &&
          !e.ctrlKey &&
          !e.altKey &&
          document.activeElement.tagName !== "INPUT"
        ) {
          setTransformMode("rotate");
        }

        // R - Scale mode
        if (
          e.key === "r" &&
          !e.ctrlKey &&
          !e.altKey &&
          document.activeElement.tagName !== "INPUT"
        ) {
          setTransformMode("scale");
        }

        // Delete - Delete selected object
        if (e.key === "Delete" && selectedObject) {
          deleteSelectedObject();
        }

        // Ctrl+D - Duplicate (future feature)
        if (e.ctrlKey && e.key === "d") {
          e.preventDefault();
          console.log("Duplicate feature coming soon");
        }
      });

      // Load preferences on startup
      function loadPreferences() {
        // Load UI mode
        const savedMode = localStorage.getItem("ui-mode");
        if (savedMode) {
          setUIMode(savedMode);
        }

        // Load workspace preset
        const savedWorkspace = localStorage.getItem("workspace-preset");
        if (savedWorkspace) {
          const btn = document.querySelector(
            `[onclick="setWorkspacePreset('${savedWorkspace}')"]`
          );
          if (btn) {
            btn.click();
          }
        }

        // Update favorites UI
        updateFavoritesUI();
      }

      // ============================================
      // PHASE 1.4: PERFORMANCE OPTIMIZATION
      // ============================================

      // Performance monitoring
      let performanceStats = {
        fps: 60,
        frameTime: 16,
        drawCalls: 0,
        triangles: 0,
        lastTime: performance.now(),
        frames: 0,
        fpsHistory: [],
      };

      let performanceMonitorVisible = false;
      let qualityLevel = "high"; // high, medium, low

      // Object Pool System
      class ObjectPool {
        constructor(createFunc, resetFunc, initialSize = 10) {
          this.createFunc = createFunc;
          this.resetFunc = resetFunc;
          this.pool = [];
          this.active = [];

          // Pre-create initial objects
          for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFunc());
          }
        }

        get() {
          let obj;
          if (this.pool.length > 0) {
            obj = this.pool.pop();
          } else {
            obj = this.createFunc();
          }
          this.active.push(obj);
          return obj;
        }

        release(obj) {
          const index = this.active.indexOf(obj);
          if (index > -1) {
            this.active.splice(index, 1);
            this.resetFunc(obj);
            this.pool.push(obj);
          }
        }

        releaseAll() {
          while (this.active.length > 0) {
            this.release(this.active[0]);
          }
        }

        getPoolSize() {
          return this.pool.length;
        }

        getActiveCount() {
          return this.active.length;
        }
      }

      // Geometry pool for common shapes
      const geometryPools = {
        box: new ObjectPool(
          () => new THREE.BoxGeometry(1, 1, 1),
          (geo) => {},
          5
        ),
        sphere: new ObjectPool(
          () => new THREE.SphereGeometry(0.5, 32, 32),
          (geo) => {},
          5
        ),
        cylinder: new ObjectPool(
          () => new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
          (geo) => {},
          5
        ),
        plane: new ObjectPool(
          () => new THREE.PlaneGeometry(1, 1),
          (geo) => {},
          5
        ),
      };

      // LOD (Level of Detail) System
      function createLODObject(geometry, material, levels = 3) {
        const lod = new THREE.LOD();

        for (let i = 0; i < levels; i++) {
          const detail = Math.max(1, levels - i);
          let geo;

          if (geometry instanceof THREE.SphereGeometry) {
            const segments = Math.max(8, 32 / detail);
            geo = new THREE.SphereGeometry(0.5, segments, segments);
          } else if (geometry instanceof THREE.CylinderGeometry) {
            const segments = Math.max(8, 32 / detail);
            geo = new THREE.CylinderGeometry(0.5, 0.5, 1, segments);
          } else {
            geo = geometry.clone();
          }

          const mesh = new THREE.Mesh(geo, material);
          lod.addLevel(mesh, i * 10);
        }

        return lod;
      }

      // Frustum Culling Helper
      const frustum = new THREE.Frustum();
      const cameraViewProjectionMatrix = new THREE.Matrix4();

      function updateFrustumCulling() {
        if (!camera) return;

        camera.updateMatrixWorld();
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        cameraViewProjectionMatrix.multiplyMatrices(
          camera.projectionMatrix,
          camera.matrixWorldInverse
        );
        frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

        // Check all objects
        scene.traverse((object) => {
          if (object.isMesh && object.geometry) {
            if (!object.geometry.boundingSphere) {
              object.geometry.computeBoundingSphere();
            }

            const sphere = object.geometry.boundingSphere.clone();
            sphere.applyMatrix4(object.matrixWorld);

            object.visible = frustum.intersectsSphere(sphere);
          }
        });
      }

      // Quality Level Management
      function detectDeviceTier() {
        const canvas = document.createElement("canvas");
        const gl =
          canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (!gl) return "low";

        const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
        const renderer = debugInfo
          ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
          : "";

        // Mobile detection
        const isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );

        // Simple heuristic
        if (isMobile) {
          return "medium";
        } else if (renderer.includes("Intel")) {
          return "medium";
        } else {
          return "high";
        }
      }

      function setQualityLevel(level) {
        qualityLevel = level;

        const qualityDot = document.getElementById("quality-dot");
        const qualityText = document.getElementById("quality-text");
        const qualityValue = document.getElementById("perf-quality");

        if (!renderer) return;

        switch (level) {
          case "low":
            renderer.setPixelRatio(1);
            renderer.shadowMap.enabled = false;
            renderer.antialias = false;
            qualityDot.className = "quality-dot low";
            qualityText.textContent = "Low Quality";
            qualityValue.textContent = "Low";
            qualityValue.className = "perf-value bad";
            break;

          case "medium":
            renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            qualityDot.className = "quality-dot medium";
            qualityText.textContent = "Medium Quality";
            qualityValue.textContent = "Medium";
            qualityValue.className = "perf-value warning";
            break;

          case "high":
          default:
            renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            qualityDot.className = "quality-dot";
            qualityText.textContent = "High Quality";
            qualityValue.textContent = "High";
            qualityValue.className = "perf-value good";
            break;
        }

        // Show indicator briefly
        const indicator = document.getElementById("quality-indicator");
        indicator.classList.add("show");
        setTimeout(() => indicator.classList.remove("show"), 3000);
      }

      // Adaptive Quality System
      function updateAdaptiveQuality() {
        if (performanceStats.fps < 30 && qualityLevel === "high") {
          setQualityLevel("medium");
          console.log("Reduced quality to medium due to low FPS");
        } else if (performanceStats.fps < 20 && qualityLevel === "medium") {
          setQualityLevel("low");
          console.log("Reduced quality to low due to very low FPS");
        } else if (performanceStats.fps > 55 && qualityLevel === "medium") {
          setQualityLevel("high");
          console.log("Increased quality to high - performance allows it");
        } else if (performanceStats.fps > 45 && qualityLevel === "low") {
          setQualityLevel("medium");
          console.log("Increased quality to medium - performance improved");
        }
      }

      // Performance Monitoring
      function updatePerformanceMonitor() {
        const now = performance.now();
        const delta = now - performanceStats.lastTime;

        performanceStats.frames++;
        performanceStats.frameTime = delta;

        // Update FPS every second
        if (delta >= 1000) {
          performanceStats.fps = Math.round(
            (performanceStats.frames * 1000) / delta
          );
          performanceStats.frames = 0;
          performanceStats.lastTime = now;

          performanceStats.fpsHistory.push(performanceStats.fps);
          if (performanceStats.fpsHistory.length > 60) {
            performanceStats.fpsHistory.shift();
          }

          // Update adaptive quality every 5 seconds
          if (
            performanceStats.fpsHistory.length >= 5 &&
            performanceStats.fpsHistory.length % 5 === 0
          ) {
            updateAdaptiveQuality();
          }
        }

        if (!performanceMonitorVisible) return;

        // Update display
        const fpsEl = document.getElementById("perf-fps");
        const frameTimeEl = document.getElementById("perf-frame-time");
        const drawCallsEl = document.getElementById("perf-draw-calls");
        const trianglesEl = document.getElementById("perf-triangles");
        const geometriesEl = document.getElementById("perf-geometries");
        const texturesEl = document.getElementById("perf-textures");
        const memoryEl = document.getElementById("perf-memory");

        // FPS color coding
        if (performanceStats.fps >= 50) {
          fpsEl.className = "perf-value good";
        } else if (performanceStats.fps >= 30) {
          fpsEl.className = "perf-value warning";
        } else {
          fpsEl.className = "perf-value bad";
        }

        fpsEl.textContent = performanceStats.fps;
        frameTimeEl.textContent = Math.round(delta) + "ms";

        if (frameTimeEl) {
          if (delta <= 20) {
            frameTimeEl.className = "perf-value good";
          } else if (delta <= 33) {
            frameTimeEl.className = "perf-value warning";
          } else {
            frameTimeEl.className = "perf-value bad";
          }
        }

        if (renderer && renderer.info) {
          const info = renderer.info;
          drawCallsEl.textContent = info.render.calls;
          trianglesEl.textContent = info.render.triangles.toLocaleString();
          geometriesEl.textContent = info.memory.geometries;
          texturesEl.textContent = info.memory.textures;

          // Color code draw calls
          if (info.render.calls <= 50) {
            drawCallsEl.className = "perf-value good";
          } else if (info.render.calls <= 100) {
            drawCallsEl.className = "perf-value warning";
          } else {
            drawCallsEl.className = "perf-value bad";
          }
        }

        // Memory usage (approximate)
        if (performance.memory) {
          const memMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(
            1
          );
          memoryEl.textContent = memMB + " MB";
        }
      }

      function togglePerformanceMonitor() {
        performanceMonitorVisible = !performanceMonitorVisible;
        const monitor = document.getElementById("performance-monitor");
        if (performanceMonitorVisible) {
          monitor.classList.add("show");
        } else {
          monitor.classList.remove("show");
        }
      }

      // Progressive Loading
      function showLoadingBar() {
        const loadingBar = document.getElementById("loading-bar");
        loadingBar.classList.add("show");
      }

      function updateLoadingProgress(percent) {
        const progress = document.getElementById("loading-progress");
        progress.style.width = percent + "%";
      }

      function hideLoadingBar() {
        const loadingBar = document.getElementById("loading-bar");
        setTimeout(() => {
          loadingBar.classList.remove("show");
        }, 300);
      }

      // Debounce function for window resize
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Optimized window resize handler
      const optimizedResize = debounce(onWindowResize, 250);
      window.addEventListener("resize", optimizedResize);

      // P key to toggle performance monitor
      document.addEventListener("keydown", function (e) {
        if (
          e.key === "p" &&
          !e.ctrlKey &&
          !e.altKey &&
          document.activeElement.tagName !== "INPUT"
        ) {
          togglePerformanceMonitor();
        }
      });

      // Mobile-specific optimizations
      function applyMobileOptimizations() {
        const isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );

        if (isMobile) {
          // Reduce shadow map size
          if (directionalLight && directionalLight.shadow) {
            directionalLight.shadow.mapSize.width = 512;
            directionalLight.shadow.mapSize.height = 512;
          }

          // Limit max pixel ratio
          if (renderer) {
            renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
          }

          // Set to medium quality by default
          setQualityLevel("medium");

          console.log("Mobile optimizations applied");
        }
      }

      // Initialize performance optimizations
      function initPerformanceOptimizations() {
        // Detect and set initial quality
        const deviceTier = detectDeviceTier();
        setQualityLevel(deviceTier);

        // Apply mobile optimizations
        applyMobileOptimizations();

        // Start performance monitoring
        performanceStats.lastTime = performance.now();

        console.log(
          "Performance optimizations initialized - Quality:",
          deviceTier
        );
      }

      // ============================================
      // PHASE 2: TEMPLATE SYSTEM
      // ============================================

      // Template Library Database
      const templateLibrary = [
        // GAME TEMPLATES
        {
          id: "fps-arena",
          name: "FPS Arena",
          category: "game",
          description:
            "First-person shooter arena with spawn points, walls, and basic collision",
          tags: ["FPS", "Multiplayer", "Shooter"],
          difficulty: "beginner",
          badge: "popular",
          icon: "fa-crosshairs",
          setup: function () {
            // SIMPLE FPS ARENA - Clean and Organized
            // A basic but well-laid-out FPS arena perfect for game development

            // Arena Floor
            const floor = createAsset("floor");
            if (floor) {
              floor.position.set(0, -0.25, 0);
              floor.scale.set(30, 0.5, 30);
              floor.material.color.setHex(0x4a4a4a);
              floor.material.roughness = 0.9;
              floor.material.metalness = 0.1;
              floor.name = "Arena Floor";
            }

            // Perimeter Walls
            const walls = [
              { x: 0, z: -15 }, // North
              { x: 0, z: 15 }, // South
              { x: -15, z: 0 }, // West
              { x: 15, z: 0 }, // East
            ];

            walls.forEach((pos, i) => {
              const wall = createAsset("wall");
              if (wall) {
                wall.position.set(pos.x, 2.5, pos.z);
                if (i >= 2) wall.rotation.y = Math.PI / 2;
                wall.scale.set(30, 5, 1);
                wall.material.color.setHex(0x6b7280);
                wall.name = `Wall ${["North", "South", "West", "East"][i]}`;
              }
            });

            // Red Team Spawn (left side)
            const redSpawn = createAsset("cylinder");
            if (redSpawn) {
              redSpawn.position.set(-10, 0.05, 0);
              redSpawn.scale.set(2, 0.1, 2);
              redSpawn.material.color.setHex(0xff4444);
              redSpawn.material.emissive.setHex(0xff4444);
              redSpawn.material.emissiveIntensity = 0.3;
              redSpawn.name = "Red Team Spawn";

              redSpawn.userData.animate = function (time) {
                this.material.emissiveIntensity =
                  0.3 + Math.sin(time * 2) * 0.2;
              };
            }

            // Blue Team Spawn (right side)
            const blueSpawn = createAsset("cylinder");
            if (blueSpawn) {
              blueSpawn.position.set(10, 0.05, 0);
              blueSpawn.scale.set(2, 0.1, 2);
              blueSpawn.material.color.setHex(0x4444ff);
              blueSpawn.material.emissive.setHex(0x4444ff);
              blueSpawn.material.emissiveIntensity = 0.3;
              blueSpawn.name = "Blue Team Spawn";

              blueSpawn.userData.animate = function (time) {
                this.material.emissiveIntensity =
                  0.3 + Math.sin(time * 2) * 0.2;
              };
            }

            // Cover Crates (strategic positions)
            const crates = [
              { x: -5, z: -8 },
              { x: 5, z: -8 },
              { x: -5, z: 8 },
              { x: 5, z: 8 },
              { x: 0, z: 0 }, // Center
            ];

            crates.forEach((pos, i) => {
              const crate = createAsset("box");
              if (crate) {
                crate.position.set(pos.x, 0.75, pos.z);
                crate.scale.set(1.5, 1.5, 1.5);
                crate.material.color.setHex(0x8b7355);
                crate.material.roughness = 0.85;
                crate.name = `Crate ${i + 1}`;
              }
            });

            // Item Spawns (rotating markers)
            const items = [
              { x: 0, z: -10, color: 0x00ff88, name: "Health" },
              { x: 0, z: 10, color: 0xffaa00, name: "Ammo" },
            ];

            items.forEach((item) => {
              const marker = createAsset("torus");
              if (marker) {
                marker.position.set(item.x, 0.2, item.z);
                marker.scale.set(0.6, 0.6, 0.6);
                marker.rotation.x = Math.PI / 2;
                marker.material.color.setHex(item.color);
                marker.material.emissive.setHex(item.color);
                marker.material.emissiveIntensity = 0.5;
                marker.name = `${item.name} Pickup`;

                marker.userData.animate = function (time) {
                  this.rotation.z = time * 0.5;
                  this.material.emissiveIntensity =
                    0.5 + Math.sin(time * 3) * 0.3;
                };
              }
            });

            // Overhead Lights
            const lights = [
              { x: -8, z: -8 },
              { x: 8, z: -8 },
              { x: -8, z: 8 },
              { x: 8, z: 8 },
            ];

            lights.forEach((pos, i) => {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(pos.x, 8, pos.z);
                light.intensity = 1.2;
                light.distance = 18;
                light.name = `Light ${i + 1}`;
              }
            });

            console.log("âœ“ FPS Arena loaded!");
            console.log("- Red spawn (left) & Blue spawn (right)");
            console.log("- 5 cover crates & 2 item pickups");
          },
        },
        {
          id: "platformer",
          name: "Platformer Level",
          category: "game",
          description:
            "Classic platformer with platforms, collectibles, and hazards",
          tags: ["Platformer", "2D", "Side-Scrolling"],
          difficulty: "beginner",
          badge: "new",
          icon: "fa-running",
          setup: function () {
            // Ground
            const ground = createAsset("plane");
            if (ground) {
              ground.rotation.x = -Math.PI / 2;
              ground.scale.set(50, 50, 1);
              ground.position.y = -1;
            }

            // Platforms
            for (let i = 0; i < 8; i++) {
              const platform = createAsset("box");
              if (platform) {
                platform.scale.set(4, 0.3, 2);
                platform.position.set(i * 6 - 20, i * 1.5, 0);
                platform.userData.hasCollision = true;
              }
            }

            // Collectibles
            for (let i = 0; i < 10; i++) {
              const coin = createAsset("sphere");
              if (coin) {
                coin.scale.set(0.3, 0.3, 0.3);
                coin.position.set(
                  (i % 5) * 4 - 8,
                  (Math.floor(i / 5) + 1) * 3,
                  0
                );
              }
            }
          },
        },
        {
          id: "racing-track",
          name: "Racing Track",
          category: "game",
          description: "Circular racing track with checkpoints and barriers",
          tags: ["Racing", "Track", "Vehicles"],
          difficulty: "intermediate",
          icon: "fa-flag-checkered",
          setup: function () {
            // Track base
            const track = createAsset("cylinder");
            if (track) {
              track.scale.set(20, 0.2, 20);
              track.position.y = -0.1;
            }

            // Barriers
            for (let i = 0; i < 16; i++) {
              const angle = (Math.PI * 2 * i) / 16;
              const innerBarrier = createAsset("box");
              const outerBarrier = createAsset("box");

              if (innerBarrier) {
                innerBarrier.position.set(
                  Math.cos(angle) * 12,
                  0.5,
                  Math.sin(angle) * 12
                );
                innerBarrier.rotation.y = angle;
                innerBarrier.scale.set(3, 1, 0.3);
              }

              if (outerBarrier) {
                outerBarrier.position.set(
                  Math.cos(angle) * 18,
                  0.5,
                  Math.sin(angle) * 18
                );
                outerBarrier.rotation.y = angle;
                outerBarrier.scale.set(3, 1, 0.3);
              }
            }
          },
        },

        // VISUALIZATION TEMPLATES
        {
          id: "product-showcase",
          name: "Product Showcase",
          category: "visualization",
          description:
            "Rotating pedestal with lighting setup for product display",
          tags: ["Product", "Display", "E-commerce"],
          difficulty: "beginner",
          badge: "popular",
          icon: "fa-box-open",
          setup: function () {
            // ENHANCED PRODUCT SHOWCASE - E-commerce Ready
            // Professional product display with studio lighting, rotating platform,
            // and backdrop for perfect product visualization

            // Studio Background - Gradient backdrop
            const backdrop = createAsset("plane");
            if (backdrop) {
              backdrop.scale.set(15, 10, 1);
              backdrop.position.set(0, 5, -6);
              backdrop.material.color.setHex(0xf5f5f5); // Light gray
              backdrop.material.roughness = 1.0;
              backdrop.material.metalness = 0.0;
              backdrop.name = "Backdrop";
            }

            // Studio Floor - Reflective surface
            const studioFloor = createAsset("plane");
            if (studioFloor) {
              studioFloor.rotation.x = -Math.PI / 2;
              studioFloor.scale.set(15, 15, 1);
              studioFloor.position.y = -0.01;
              studioFloor.material.color.setHex(0xffffff);
              studioFloor.material.roughness = 0.3;
              studioFloor.material.metalness = 0.5;
              studioFloor.name = "Studio Floor";
              studioFloor.receiveShadow = true;
            }

            // Rotating Pedestal - Main platform
            const pedestal = createAsset("cylinder");
            if (pedestal) {
              pedestal.scale.set(2.5, 0.4, 2.5);
              pedestal.position.set(0, 0.2, 0);
              pedestal.material.color.setHex(0x1a1a1a); // Dark elegant
              pedestal.material.roughness = 0.2;
              pedestal.material.metalness = 0.8;
              pedestal.name = "Pedestal";
              pedestal.userData.rotatingPlatform = true;

              // Smooth rotation animation
              pedestal.userData.animate = function (time) {
                this.rotation.y = time * 0.3; // Slow elegant rotation
              };
            }

            // Pedestal accent ring
            const ring = createAsset("torus");
            if (ring) {
              ring.scale.set(2.6, 2.6, 2.6);
              ring.position.set(0, 0.4, 0);
              ring.rotation.x = Math.PI / 2;
              ring.material.color.setHex(0xffd700); // Gold
              ring.material.roughness = 0.3;
              ring.material.metalness = 0.9;
              ring.material.emissive.setHex(0xffd700);
              ring.material.emissiveIntensity = 0.2;
              ring.name = "Accent Ring";

              // Gentle pulsing effect
              ring.userData.animate = function (time) {
                this.rotation.z = time * 0.3;
                this.material.emissiveIntensity =
                  0.2 + Math.sin(time * 2) * 0.1;
              };
            }

            // Product Display - Premium box product
            const productBase = createAsset("box");
            if (productBase) {
              productBase.position.set(0, 1.5, 0);
              productBase.scale.set(1.5, 1.5, 1.5);
              productBase.material.color.setHex(0x4a90e2); // Premium blue
              productBase.material.roughness = 0.3;
              productBase.material.metalness = 0.7;
              productBase.material.emissive.setHex(0x2563eb);
              productBase.material.emissiveIntensity = 0.1;
              productBase.name = "Product";
              productBase.userData.product = true;
              productBase.castShadow = true;

              // Floating animation
              productBase.userData.animate = function (time) {
                this.position.y = 1.5 + Math.sin(time * 1.5) * 0.1;
                this.rotation.y = time * 0.5;
              };
            }

            // Product accent details
            for (let i = 0; i < 4; i++) {
              const accent = createAsset("sphere");
              if (accent) {
                const angle = (Math.PI * 2 * i) / 4;
                accent.scale.set(0.15, 0.15, 0.15);
                accent.material.color.setHex(0xffd700);
                accent.material.roughness = 0.2;
                accent.material.metalness = 0.9;
                accent.material.emissive.setHex(0xffd700);
                accent.material.emissiveIntensity = 0.3;
                accent.name = `Product Accent ${i + 1}`;

                accent.userData.orbitAngle = angle;
                accent.userData.animate = function (time) {
                  const orbitTime = time * 0.8;
                  this.position.x =
                    Math.cos(orbitTime + this.userData.orbitAngle) * 1.2;
                  this.position.y = 1.5 + Math.sin(time * 1.5) * 0.1;
                  this.position.z =
                    Math.sin(orbitTime + this.userData.orbitAngle) * 1.2;
                };
              }
            }

            // Studio Lighting Setup - Professional 3-point lighting

            // Key Light (main light)
            const keyLight = createAsset("spotLight");
            if (keyLight) {
              keyLight.position.set(5, 6, 5);
              keyLight.intensity = 1.5;
              keyLight.angle = Math.PI / 4;
              keyLight.penumbra = 0.3;
              keyLight.distance = 30;
              keyLight.color.setHex(0xffffff);
              keyLight.name = "Key Light";
              keyLight.target.position.set(0, 1, 0);
              scene.add(keyLight.target);
            }

            // Fill Light (softer, opposite side)
            const fillLight = createAsset("spotLight");
            if (fillLight) {
              fillLight.position.set(-4, 5, 3);
              fillLight.intensity = 0.8;
              fillLight.angle = Math.PI / 3;
              fillLight.penumbra = 0.5;
              fillLight.distance = 25;
              fillLight.color.setHex(0xe0e7ff); // Slight blue tint
              fillLight.name = "Fill Light";
              fillLight.target.position.set(0, 1, 0);
              scene.add(fillLight.target);
            }

            // Back Light (rim light for depth)
            const backLight = createAsset("spotLight");
            if (backLight) {
              backLight.position.set(0, 4, -4);
              backLight.intensity = 1.2;
              backLight.angle = Math.PI / 5;
              backLight.penumbra = 0.2;
              backLight.distance = 20;
              backLight.color.setHex(0xffffee);
              backLight.name = "Back Light";
              backLight.target.position.set(0, 1, 0);
              scene.add(backLight.target);
            }

            // Accent Rim Lights (colored highlights)
            const rimColors = [0xff6b6b, 0x4ecdc4];
            rimColors.forEach((color, i) => {
              const rimLight = createAsset("pointLight");
              if (rimLight) {
                rimLight.position.set(i === 0 ? 3 : -3, 3, -2);
                rimLight.intensity = 0.5;
                rimLight.distance = 12;
                rimLight.color.setHex(color);
                rimLight.name = `Rim Light ${i + 1}`;
              }
            });

            // Information Cards (for product details)
            const infoPositions = [
              { x: -4, z: 2, label: "Features" },
              { x: 4, z: 2, label: "Specs" },
              { x: 0, z: 4, label: "Price" },
            ];

            infoPositions.forEach((info) => {
              const card = createAsset("box");
              if (card) {
                card.scale.set(1.5, 1, 0.05);
                card.position.set(info.x, 2.5, info.z);
                card.material.color.setHex(0xffffff);
                card.material.roughness = 0.4;
                card.material.metalness = 0.1;
                card.material.emissive.setHex(0x3b82f6);
                card.material.emissiveIntensity = 0.05;
                card.name = `Info Card - ${info.label}`;
                card.userData.infoCard = true;

                // Subtle float animation
                card.userData.animate = function (time) {
                  this.position.y =
                    2.5 + Math.sin(time * 1.2 + this.position.x) * 0.05;
                };
              }
            });

            // Price tag (floating above product)
            const priceTag = createAsset("plane");
            if (priceTag) {
              priceTag.scale.set(1.2, 0.4, 1);
              priceTag.position.set(0, 3.5, 0);
              priceTag.material.color.setHex(0x10b981); // Green
              priceTag.material.roughness = 0.3;
              priceTag.material.metalness = 0.2;
              priceTag.material.side = THREE.DoubleSide;
              priceTag.material.emissive.setHex(0x10b981);
              priceTag.material.emissiveIntensity = 0.3;
              priceTag.name = "Price Tag";

              priceTag.userData.animate = function (time) {
                this.rotation.y = Math.sin(time) * 0.1;
                this.position.y = 3.5 + Math.sin(time * 2) * 0.05;
              };
            }

            console.log("âœ“ Product Showcase loaded - E-commerce ready!");
            console.log(
              "Features: Studio lighting, rotating platform, animated product, info cards"
            );
          },
        },
        {
          id: "gallery",
          name: "Virtual Gallery",
          category: "visualization",
          description: "Art gallery with frames and spotlights for exhibitions",
          tags: ["Gallery", "Museum", "Art"],
          difficulty: "intermediate",
          icon: "fa-images",
          setup: function () {
            // Floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(30, 20, 1);
            }

            // Walls
            for (let i = 0; i < 4; i++) {
              const wall = createAsset("wall");
              if (wall) {
                const angle = (Math.PI / 2) * i;
                wall.position.set(
                  Math.cos(angle) * 15,
                  2.5,
                  Math.sin(angle) * 10
                );
                wall.rotation.y = angle;
                wall.scale.set(20, 5, 0.5);
              }
            }

            // Art frames
            for (let i = 0; i < 6; i++) {
              const frame = createAsset("box");
              if (frame) {
                frame.scale.set(2, 1.5, 0.1);
                frame.position.set(-14, 2, -8 + i * 3);
              }
            }
          },
        },

        // WEBSITE INTEGRATION TEMPLATES
        {
          id: "hero-3d-bg",
          name: "3D Hero Background",
          category: "website",
          description:
            "Animated 3D background perfect for website hero sections",
          tags: ["Hero", "Background", "Landing"],
          difficulty: "beginner",
          badge: "popular",
          icon: "fa-layer-group",
          setup: function () {
            // ENHANCED 3D HERO BACKGROUND - Modern Website Design
            // Animated floating geometric shapes with gradient colors,
            // perfect for modern landing pages and hero sections

            // Color palette - Modern gradient colors
            const colorPalette = [
              0x667eea, // Purple
              0x764ba2, // Deep purple
              0xf093fb, // Pink
              0x4facfe, // Blue
              0x00f2fe, // Cyan
              0xa8edea, // Mint
            ];

            // Large floating shapes (background layer)
            const largeShapes = [
              { type: "sphere", pos: { x: -8, y: 3, z: -10 }, scale: 3 },
              { type: "torus", pos: { x: 10, y: -2, z: -12 }, scale: 4 },
              { type: "box", pos: { x: -5, y: -4, z: -8 }, scale: 2.5 },
            ];

            largeShapes.forEach((config, i) => {
              const shape = createAsset(config.type);
              if (shape) {
                shape.position.set(config.pos.x, config.pos.y, config.pos.z);
                shape.scale.setScalar(config.scale);
                shape.material.color.setHex(
                  colorPalette[i % colorPalette.length]
                );
                shape.material.roughness = 0.3;
                shape.material.metalness = 0.6;
                shape.material.emissive.setHex(
                  colorPalette[i % colorPalette.length]
                );
                shape.material.emissiveIntensity = 0.2;
                shape.material.transparent = true;
                shape.material.opacity = 0.7;
                shape.name = `BG Shape Large ${i + 1}`;

                // Slow rotation and float
                shape.userData.floatSpeed = 0.2 + Math.random() * 0.3;
                shape.userData.rotSpeed = (Math.random() - 0.5) * 0.2;
                shape.userData.initialY = config.pos.y;
                shape.userData.animate = function (time) {
                  this.rotation.x += this.userData.rotSpeed * 0.01;
                  this.rotation.y += this.userData.rotSpeed * 0.015;
                  this.position.y =
                    this.userData.initialY +
                    Math.sin(time * this.userData.floatSpeed) * 1.5;

                  // Pulsing glow
                  this.material.emissiveIntensity =
                    0.2 + Math.sin(time * 2) * 0.1;
                };
              }
            });

            // Medium floating shapes (mid layer) - More dynamic
            for (let i = 0; i < 8; i++) {
              const shapes = ["box", "sphere", "torus"];
              const shape = createAsset(shapes[i % shapes.length]);
              if (shape) {
                const angle = (Math.PI * 2 * i) / 8;
                const radius = 12 + Math.random() * 5;

                shape.position.set(
                  Math.cos(angle) * radius,
                  (Math.random() - 0.5) * 8,
                  Math.sin(angle) * radius - 5
                );

                const size = 0.8 + Math.random() * 1.2;
                shape.scale.setScalar(size);
                shape.material.color.setHex(
                  colorPalette[i % colorPalette.length]
                );
                shape.material.roughness = 0.4;
                shape.material.metalness = 0.5;
                shape.material.emissive.setHex(
                  colorPalette[i % colorPalette.length]
                );
                shape.material.emissiveIntensity = 0.15;
                shape.material.transparent = true;
                shape.material.opacity = 0.6;
                shape.name = `BG Shape Medium ${i + 1}`;

                // Orbital + rotation animation
                shape.userData.orbitRadius = radius;
                shape.userData.orbitSpeed = 0.1 + Math.random() * 0.1;
                shape.userData.orbitOffset = angle;
                shape.userData.initialY = shape.position.y;
                shape.userData.animate = function (time) {
                  const orbitAngle =
                    time * this.userData.orbitSpeed + this.userData.orbitOffset;
                  this.position.x =
                    Math.cos(orbitAngle) * this.userData.orbitRadius;
                  this.position.z =
                    Math.sin(orbitAngle) * this.userData.orbitRadius - 5;
                  this.position.y =
                    this.userData.initialY + Math.sin(time * 0.5) * 2;

                  this.rotation.x = time * 0.3;
                  this.rotation.y = time * 0.2;
                };
              }
            }

            // Small accent shapes (foreground) - Fast moving particles
            for (let i = 0; i < 15; i++) {
              const shape = createAsset("sphere");
              if (shape) {
                shape.position.set(
                  (Math.random() - 0.5) * 25,
                  (Math.random() - 0.5) * 12,
                  Math.random() * 8 - 2
                );

                const size = 0.2 + Math.random() * 0.4;
                shape.scale.setScalar(size);
                shape.material.color.setHex(
                  colorPalette[Math.floor(Math.random() * colorPalette.length)]
                );
                shape.material.roughness = 0.2;
                shape.material.metalness = 0.8;
                shape.material.emissive.setHex(shape.material.color.getHex());
                shape.material.emissiveIntensity = 0.5;
                shape.material.transparent = true;
                shape.material.opacity = 0.8;
                shape.name = `Particle ${i + 1}`;

                // Fast floating particle effect
                shape.userData.floatSpeed = 1 + Math.random() * 2;
                shape.userData.driftSpeed = {
                  x: (Math.random() - 0.5) * 0.5,
                  y: (Math.random() - 0.5) * 0.3,
                  z: (Math.random() - 0.5) * 0.2,
                };
                shape.userData.initialPos = shape.position.clone();
                shape.userData.animate = function (time) {
                  // Floating drift
                  this.position.x =
                    this.userData.initialPos.x +
                    Math.sin(time * this.userData.driftSpeed.x) * 3;
                  this.position.y =
                    this.userData.initialPos.y +
                    Math.sin(time * this.userData.floatSpeed) * 2;
                  this.position.z =
                    this.userData.initialPos.z +
                    Math.sin(time * this.userData.driftSpeed.z) * 2;

                  // Pulsing glow
                  const pulse = Math.sin(time * 3) * 0.3 + 0.7;
                  this.material.emissiveIntensity = 0.5 * pulse;
                  this.scale.setScalar(this.scale.x * (1 + pulse * 0.1));
                };
              }
            }

            // Connecting Lines - Network effect
            for (let i = 0; i < 5; i++) {
              const lineGeo = createAsset("cylinder");
              if (lineGeo) {
                const start = {
                  x: (Math.random() - 0.5) * 15,
                  y: (Math.random() - 0.5) * 8,
                  z: -8,
                };
                const end = {
                  x: (Math.random() - 0.5) * 15,
                  y: (Math.random() - 0.5) * 8,
                  z: -8,
                };

                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const dz = end.z - start.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                lineGeo.scale.set(0.02, distance / 2, 0.02);
                lineGeo.position.set(
                  (start.x + end.x) / 2,
                  (start.y + end.y) / 2,
                  (start.z + end.z) / 2
                );

                const angle = Math.atan2(dz, dx);
                const elevation = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));
                lineGeo.rotation.z = elevation;
                lineGeo.rotation.y = angle - Math.PI / 2;

                lineGeo.material.color.setHex(0x667eea);
                lineGeo.material.emissive.setHex(0x667eea);
                lineGeo.material.emissiveIntensity = 0.3;
                lineGeo.material.transparent = true;
                lineGeo.material.opacity = 0.3;
                lineGeo.name = `Connection Line ${i + 1}`;

                // Pulsing line effect
                lineGeo.userData.animate = function (time) {
                  this.material.emissiveIntensity =
                    0.3 + Math.sin(time * 2 + i) * 0.2;
                  this.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.15;
                };
              }
            }

            // Dynamic Lighting - Colored lights
            const lightColors = [
              { color: 0x667eea, pos: { x: -10, y: 8, z: 5 } },
              { color: 0xf093fb, pos: { x: 10, y: 6, z: 3 } },
              { color: 0x4facfe, pos: { x: 0, y: 10, z: 8 } },
            ];

            lightColors.forEach((config, i) => {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(config.pos.x, config.pos.y, config.pos.z);
                light.color.setHex(config.color);
                light.intensity = 0.8;
                light.distance = 25;
                light.name = `Accent Light ${i + 1}`;

                // Moving light effect
                light.userData.initialPos = light.position.clone();
                light.userData.moveSpeed = 0.5 + i * 0.2;
                light.userData.animate = function (time) {
                  this.position.x =
                    this.userData.initialPos.x +
                    Math.sin(time * this.userData.moveSpeed) * 3;
                  this.position.y =
                    this.userData.initialPos.y +
                    Math.cos(time * this.userData.moveSpeed * 0.7) * 2;
                  this.intensity = 0.8 + Math.sin(time * 2) * 0.3;
                };
              }
            });

            // Rim light for depth
            const rimLight = createAsset("pointLight");
            if (rimLight) {
              rimLight.position.set(0, 0, -15);
              rimLight.color.setHex(0xa8edea);
              rimLight.intensity = 1.2;
              rimLight.distance = 30;
              rimLight.name = "Rim Light";
            }

            console.log("âœ“ 3D Hero Background loaded - Modern & Animated!");
            console.log(
              "Features: Floating shapes, particle effects, dynamic lighting, network connections"
            );
          },
        },
        {
          id: "product-configurator",
          name: "Product Configurator",
          category: "website",
          description: "Interactive product with customizable colors and parts",
          tags: ["E-commerce", "Interactive", "Configurator"],
          difficulty: "advanced",
          badge: "advanced",
          icon: "fa-palette",
          setup: function () {
            // Main product
            const base = createAsset("box");
            if (base) {
              base.scale.set(2, 1, 1);
              base.position.y = 0.5;
            }

            const top = createAsset("box");
            if (top) {
              top.scale.set(1.8, 0.3, 0.9);
              top.position.y = 1.15;
            }

            // Pedestal
            const pedestal = createAsset("cylinder");
            if (pedestal) {
              pedestal.scale.set(1.5, 0.2, 1.5);
              pedestal.position.y = -0.1;
            }
          },
        },

        // ENVIRONMENT TEMPLATES
        {
          id: "nature-scene",
          name: "Nature Scene",
          category: "environment",
          description:
            "Outdoor environment with terrain, trees, and natural lighting",
          tags: ["Nature", "Outdoor", "Terrain"],
          difficulty: "intermediate",
          icon: "fa-tree",
          setup: function () {
            // Terrain
            const terrain = createAsset("plane");
            if (terrain) {
              terrain.rotation.x = -Math.PI / 2;
              terrain.scale.set(50, 50, 1);
              terrain.position.y = -0.5;
            }

            // "Trees" (simple cylinders with sphere tops)
            for (let i = 0; i < 8; i++) {
              const trunk = createAsset("cylinder");
              if (trunk) {
                trunk.scale.set(0.3, 2, 0.3);
                trunk.position.set(
                  (Math.random() - 0.5) * 20,
                  1,
                  (Math.random() - 0.5) * 20
                );
              }

              const foliage = createAsset("sphere");
              if (foliage) {
                foliage.scale.set(1.5, 1.5, 1.5);
                foliage.position.set(trunk.position.x, 3, trunk.position.z);
              }
            }
          },
        },
        {
          id: "scifi-corridor",
          name: "Sci-Fi Corridor",
          category: "environment",
          description: "Futuristic hallway with lighting and metallic surfaces",
          tags: ["Sci-Fi", "Corridor", "Futuristic"],
          difficulty: "advanced",
          badge: "new",
          icon: "fa-rocket",
          setup: function () {
            // Floor and ceiling
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(5, 20, 1);
            }

            const ceiling = createAsset("plane");
            if (ceiling) {
              ceiling.rotation.x = Math.PI / 2;
              ceiling.scale.set(5, 20, 1);
              ceiling.position.y = 4;
            }

            // Walls
            const wall1 = createAsset("plane");
            if (wall1) {
              wall1.rotation.y = Math.PI / 2;
              wall1.scale.set(20, 4, 1);
              wall1.position.set(-2.5, 2, 0);
            }

            const wall2 = createAsset("plane");
            if (wall2) {
              wall2.rotation.y = -Math.PI / 2;
              wall2.scale.set(20, 4, 1);
              wall2.position.set(2.5, 2, 0);
            }

            // Corridor lights
            for (let i = 0; i < 5; i++) {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(0, 3.5, i * 4 - 8);
              }
            }
          },
        },

        {
          id: "empty-scene",
          name: "Empty Scene",
          category: "game",
          description: "Blank canvas with just a floor and basic lighting",
          tags: ["Blank", "Starter", "Custom"],
          difficulty: "beginner",
          icon: "fa-file",
          setup: function () {
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(20, 20, 1);
            }
          },
        },
        {
          id: "puzzle-game",
          name: "Puzzle Game",
          category: "game",
          description:
            "Grid-based puzzle setup with movable blocks and goal areas",
          tags: ["Puzzle", "Logic", "Grid"],
          difficulty: "intermediate",
          icon: "fa-puzzle-piece",
          setup: function () {
            // Floor grid
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(15, 15, 1);
            }

            // Create grid of squares
            for (let x = 0; x < 5; x++) {
              for (let z = 0; z < 5; z++) {
                const tile = createAsset("box");
                if (tile) {
                  tile.scale.set(2.8, 0.1, 2.8);
                  tile.position.set(x * 3 - 6, 0.05, z * 3 - 6);
                }
              }
            }

            // Movable blocks
            for (let i = 0; i < 4; i++) {
              const block = createAsset("box");
              if (block) {
                block.position.set(
                  (i % 2) * 3 - 3,
                  0.5,
                  Math.floor(i / 2) * 3 - 3
                );
                block.userData.movable = true;
              }
            }

            // Goal areas (torus rings)
            for (let i = 0; i < 2; i++) {
              const goal = createAsset("torus");
              if (goal) {
                goal.scale.set(1.2, 1.2, 1.2);
                goal.position.set(3 + i * 3, 0.1, 3);
                goal.rotation.x = Math.PI / 2;
              }
            }
          },
        },
        {
          id: "tower-defense",
          name: "Tower Defense",
          category: "game",
          description: "Path with tower placement spots and enemy spawn/goal",
          tags: ["Tower Defense", "Strategy", "Path"],
          difficulty: "intermediate",
          badge: "popular",
          icon: "fa-chess-rook",
          setup: function () {
            // Ground
            const ground = createAsset("plane");
            if (ground) {
              ground.rotation.x = -Math.PI / 2;
              ground.scale.set(40, 40, 1);
            }

            // Enemy path
            const pathPoints = [
              { x: -15, z: -10 },
              { x: -5, z: -10 },
              { x: -5, z: 0 },
              { x: 5, z: 0 },
              { x: 5, z: 10 },
              { x: 15, z: 10 },
            ];

            for (let i = 0; i < pathPoints.length - 1; i++) {
              const p1 = pathPoints[i];
              const p2 = pathPoints[i + 1];
              const path = createAsset("box");
              if (path) {
                const length = Math.sqrt(
                  Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2)
                );
                path.scale.set(length, 0.1, 2);
                path.position.set((p1.x + p2.x) / 2, 0.05, (p1.z + p2.z) / 2);
                const angle = Math.atan2(p2.z - p1.z, p2.x - p1.x);
                path.rotation.y = angle;
              }
            }

            // Tower placement spots
            const towerSpots = [
              { x: -10, z: -5 },
              { x: 0, z: -5 },
              { x: 10, z: -5 },
              { x: -10, z: 5 },
              { x: 0, z: 5 },
              { x: 10, z: 5 },
            ];

            towerSpots.forEach((spot) => {
              const platform = createAsset("cylinder");
              if (platform) {
                platform.scale.set(1.5, 0.2, 1.5);
                platform.position.set(spot.x, 0.1, spot.z);
              }
            });

            // Spawn point
            const spawn = createAsset("cone");
            if (spawn) {
              spawn.position.set(-15, 1, -10);
              spawn.scale.set(1, 2, 1);
            }

            // Goal/Base
            const goal = createAsset("sphere");
            if (goal) {
              goal.position.set(15, 1, 10);
              goal.scale.set(2, 2, 2);
            }
          },
        },
        {
          id: "battle-royale",
          name: "Battle Royale Arena",
          category: "game",
          description:
            "Large outdoor arena with buildings, cover, and loot spawns",
          tags: ["Battle Royale", "Multiplayer", "Survival"],
          difficulty: "advanced",
          icon: "fa-crosshairs",
          setup: function () {
            // Large terrain
            const terrain = createAsset("plane");
            if (terrain) {
              terrain.rotation.x = -Math.PI / 2;
              terrain.scale.set(50, 50, 1);
            }

            // Buildings (simple box structures)
            const buildings = [
              { x: -15, z: -15, w: 5, h: 4, d: 5 },
              { x: 15, z: -15, w: 4, h: 3, d: 6 },
              { x: -15, z: 15, w: 6, h: 5, d: 4 },
              { x: 15, z: 15, w: 5, h: 3, d: 5 },
              { x: 0, z: 0, w: 8, h: 6, d: 8 },
            ];

            buildings.forEach((b) => {
              const building = createAsset("box");
              if (building) {
                building.scale.set(b.w, b.h, b.d);
                building.position.set(b.x, b.h / 2, b.z);
                building.userData.hasCollision = true;
              }
            });

            // Cover boxes scattered around
            for (let i = 0; i < 12; i++) {
              const cover = createAsset("box");
              if (cover) {
                cover.position.set(
                  (Math.random() - 0.5) * 40,
                  0.5,
                  (Math.random() - 0.5) * 40
                );
                cover.scale.set(1.5, 1, 1.5);
                cover.userData.hasCollision = true;
              }
            }

            // Loot spawn points (spheres)
            for (let i = 0; i < 8; i++) {
              const loot = createAsset("sphere");
              if (loot) {
                loot.position.set(
                  (Math.random() - 0.5) * 45,
                  0.3,
                  (Math.random() - 0.5) * 45
                );
                loot.scale.set(0.3, 0.3, 0.3);
              }
            }
          },
        },
        {
          id: "rpg-arena",
          name: "RPG Arena",
          category: "game",
          description:
            "Fantasy battle arena with pillars, altar, and circular design",
          tags: ["RPG", "Fantasy", "Arena"],
          difficulty: "intermediate",
          badge: "new",
          icon: "fa-dragon",
          setup: function () {
            // Circular floor
            const floor = createAsset("cylinder");
            if (floor) {
              floor.scale.set(15, 0.5, 15);
              floor.position.y = -0.25;
            }

            // Central altar
            const altar = createAsset("box");
            if (altar) {
              altar.scale.set(2, 1.5, 2);
              altar.position.y = 0.75;
            }

            const altarTop = createAsset("cylinder");
            if (altarTop) {
              altarTop.scale.set(1.5, 0.3, 1.5);
              altarTop.position.y = 1.65;
            }

            // Pillars around the arena
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 * i) / 8;
              const pillar = createAsset("cylinder");
              if (pillar) {
                pillar.scale.set(0.8, 4, 0.8);
                pillar.position.set(
                  Math.cos(angle) * 12,
                  2,
                  Math.sin(angle) * 12
                );
              }

              // Pillar top
              const capital = createAsset("box");
              if (capital) {
                capital.scale.set(1.2, 0.4, 1.2);
                capital.position.set(
                  Math.cos(angle) * 12,
                  4.2,
                  Math.sin(angle) * 12
                );
              }
            }

            // Torches/lights
            for (let i = 0; i < 4; i++) {
              const angle = (Math.PI * 2 * i) / 4;
              const torch = createAsset("pointLight");
              if (torch) {
                torch.position.set(Math.cos(angle) * 8, 3, Math.sin(angle) * 8);
              }
            }
          },
        },
        {
          id: "horror-scene",
          name: "Horror Scene",
          category: "game",
          description:
            "Dark atmospheric environment with eerie lighting and fog",
          tags: ["Horror", "Dark", "Atmospheric"],
          difficulty: "intermediate",
          icon: "fa-ghost",
          setup: function () {
            // Floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(25, 25, 1);
            }

            // Walls to create enclosed feeling
            for (let i = 0; i < 4; i++) {
              const wall = createAsset("box");
              if (wall) {
                const angle = (Math.PI / 2) * i;
                wall.position.set(
                  Math.cos(angle) * 12,
                  2.5,
                  Math.sin(angle) * 12
                );
                wall.rotation.y = angle;
                wall.scale.set(25, 5, 0.5);
              }
            }

            // Scattered debris
            for (let i = 0; i < 10; i++) {
              const debris = createAsset("box");
              if (debris) {
                debris.position.set(
                  (Math.random() - 0.5) * 20,
                  0.3,
                  (Math.random() - 0.5) * 20
                );
                debris.scale.set(
                  Math.random() * 0.5 + 0.3,
                  Math.random() * 0.5 + 0.3,
                  Math.random() * 0.5 + 0.3
                );
                debris.rotation.set(
                  Math.random() * Math.PI,
                  Math.random() * Math.PI,
                  Math.random() * Math.PI
                );
              }
            }

            // Flickering lights (point lights at low positions)
            const lightPositions = [
              { x: -8, z: -8 },
              { x: 8, z: -8 },
              { x: -8, z: 8 },
              { x: 8, z: 8 },
            ];
            lightPositions.forEach((pos) => {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(pos.x, 1.5, pos.z);
              }
            });
          },
        },
        {
          id: "adventure-start",
          name: "Adventure Starting Area",
          category: "game",
          description: "Peaceful starting village with houses and NPCs",
          tags: ["Adventure", "Village", "RPG"],
          difficulty: "beginner",
          icon: "fa-home",
          setup: function () {
            // Ground
            const ground = createAsset("plane");
            if (ground) {
              ground.rotation.x = -Math.PI / 2;
              ground.scale.set(40, 40, 1);
            }

            // Simple houses (box base + pyramid roof)
            const housePositions = [
              { x: -10, z: -10 },
              { x: 10, z: -10 },
              { x: -10, z: 10 },
            ];

            housePositions.forEach((pos) => {
              // House base
              const base = createAsset("box");
              if (base) {
                base.scale.set(4, 3, 4);
                base.position.set(pos.x, 1.5, pos.z);
                base.userData.hasCollision = true;
              }

              // Roof
              const roof = createAsset("cone");
              if (roof) {
                roof.scale.set(3, 2, 3);
                roof.position.set(pos.x, 4, pos.z);
              }
            });

            // Central fountain/well
            const well = createAsset("cylinder");
            if (well) {
              well.scale.set(1.5, 1, 1.5);
              well.position.set(0, 0.5, 0);
            }

            const wellTop = createAsset("torus");
            if (wellTop) {
              wellTop.scale.set(1.8, 1.8, 1.8);
              wellTop.position.set(0, 1.2, 0);
              wellTop.rotation.x = Math.PI / 2;
            }

            // Trees around the village
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI * 2 * i) / 6;
              const trunk = createAsset("cylinder");
              if (trunk) {
                trunk.scale.set(0.4, 3, 0.4);
                trunk.position.set(
                  Math.cos(angle) * 18,
                  1.5,
                  Math.sin(angle) * 18
                );
              }

              const leaves = createAsset("sphere");
              if (leaves) {
                leaves.scale.set(2, 2, 2);
                leaves.position.set(
                  Math.cos(angle) * 18,
                  4,
                  Math.sin(angle) * 18
                );
              }
            }
          },
        },
        {
          id: "dungeon-room",
          name: "Dungeon Room",
          category: "game",
          description:
            "Stone dungeon chamber with pillars, treasure, and torches",
          tags: ["Dungeon", "RPG", "Indoor"],
          difficulty: "intermediate",
          icon: "fa-dungeon",
          setup: function () {
            // Floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(20, 0.5, 20);
              floor.position.y = -0.25;
            }

            // Walls
            const walls = [
              { x: 0, z: -10, ry: 0, sx: 20 },
              { x: 0, z: 10, ry: 0, sx: 20 },
              { x: -10, z: 0, ry: Math.PI / 2, sx: 20 },
              { x: 10, z: 0, ry: Math.PI / 2, sx: 20 },
            ];

            walls.forEach((w) => {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(w.sx, 6, 0.5);
                wall.position.set(w.x, 3, w.z);
                wall.rotation.y = w.ry;
              }
            });

            // Ceiling
            const ceiling = createAsset("box");
            if (ceiling) {
              ceiling.scale.set(20, 0.5, 20);
              ceiling.position.y = 6.25;
            }

            // Stone pillars
            const pillarPositions = [
              { x: -6, z: -6 },
              { x: 6, z: -6 },
              { x: -6, z: 6 },
              { x: 6, z: 6 },
            ];

            pillarPositions.forEach((pos) => {
              const pillar = createAsset("box");
              if (pillar) {
                pillar.scale.set(1, 5, 1);
                pillar.position.set(pos.x, 2.5, pos.z);
              }
            });

            // Treasure chest (center)
            const chest = createAsset("box");
            if (chest) {
              chest.scale.set(1.5, 1, 1);
              chest.position.set(0, 0.5, 0);
            }

            // Wall torches
            const torchPositions = [
              { x: -8, z: -9.5 },
              { x: 8, z: -9.5 },
              { x: -8, z: 9.5 },
              { x: 8, z: 9.5 },
            ];

            torchPositions.forEach((pos) => {
              const torch = createAsset("pointLight");
              if (torch) {
                torch.position.set(pos.x, 3, pos.z);
              }
            });
          },
        },

        // MORE VISUALIZATION TEMPLATES
        {
          id: "data-dashboard",
          name: "Data Dashboard",
          category: "visualization",
          description:
            "3D data visualization with bars, graphs, and info panels",
          tags: ["Data", "Analytics", "Dashboard"],
          difficulty: "intermediate",
          badge: "popular",
          icon: "fa-chart-line",
          setup: function () {
            // Floor/base
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(20, 20, 1);
            }

            // Bar chart representation
            const barHeights = [2, 4, 3, 6, 5, 7, 4, 8];
            for (let i = 0; i < barHeights.length; i++) {
              const bar = createAsset("box");
              if (bar) {
                bar.scale.set(0.8, barHeights[i], 0.8);
                bar.position.set(i * 2 - 7, barHeights[i] / 2, -5);
              }
            }

            // Info panels (flat boxes as screens)
            for (let i = 0; i < 3; i++) {
              const panel = createAsset("box");
              if (panel) {
                panel.scale.set(4, 3, 0.1);
                panel.position.set(i * 5 - 5, 3, 5);
              }
            }

            // Pie chart representation (cylinder segments)
            for (let i = 0; i < 4; i++) {
              const segment = createAsset("box");
              if (segment) {
                const angle = (Math.PI * 2 * i) / 4;
                segment.scale.set(2, 0.2, 1);
                segment.position.set(
                  Math.cos(angle) * 1.5 + 5,
                  0.5,
                  Math.sin(angle) * 1.5
                );
                segment.rotation.y = angle;
              }
            }
          },
        },
        {
          id: "timeline-viz",
          name: "Timeline Visualization",
          category: "visualization",
          description:
            "Interactive timeline with events and milestones in 3D space",
          tags: ["Timeline", "History", "Events"],
          difficulty: "beginner",
          icon: "fa-stream",
          setup: function () {
            // Timeline path
            const path = createAsset("box");
            if (path) {
              path.scale.set(30, 0.2, 0.5);
              path.position.set(0, 1, 0);
            }

            // Timeline events (spheres with pillars)
            for (let i = 0; i < 8; i++) {
              const height = i % 2 === 0 ? 2 : 3;

              // Event pillar
              const pillar = createAsset("cylinder");
              if (pillar) {
                pillar.scale.set(0.15, height, 0.15);
                pillar.position.set(i * 4 - 14, 1 + height / 2, 0);
              }

              // Event marker
              const marker = createAsset("sphere");
              if (marker) {
                marker.scale.set(0.5, 0.5, 0.5);
                marker.position.set(i * 4 - 14, 1 + height, 0);
              }

              // Info card
              const card = createAsset("box");
              if (card) {
                card.scale.set(1.5, 1, 0.1);
                card.position.set(i * 4 - 14, 1 + height + 1, 0);
              }
            }
          },
        },
        {
          id: "network-graph",
          name: "Network Graph",
          category: "visualization",
          description: "3D network visualization with connected nodes",
          tags: ["Network", "Graph", "Connections"],
          difficulty: "advanced",
          icon: "fa-project-diagram",
          setup: function () {
            // Central node
            const center = createAsset("sphere");
            if (center) {
              center.position.set(0, 2, 0);
              center.scale.set(1.5, 1.5, 1.5);
            }

            // Surrounding nodes in a sphere pattern
            const nodeCount = 12;
            for (let i = 0; i < nodeCount; i++) {
              const phi = Math.acos(-1 + (2 * i) / nodeCount);
              const theta = Math.sqrt(nodeCount * Math.PI) * phi;

              const node = createAsset("sphere");
              if (node) {
                node.scale.set(0.6, 0.6, 0.6);
                node.position.set(
                  Math.cos(theta) * Math.sin(phi) * 8,
                  Math.cos(phi) * 8 + 2,
                  Math.sin(theta) * Math.sin(phi) * 8
                );
              }

              // Connection line (thin cylinder)
              const connection = createAsset("cylinder");
              if (connection) {
                const distance = node.position.distanceTo(center.position);
                connection.scale.set(0.05, distance / 2, 0.05);
                connection.position
                  .copy(center.position)
                  .lerp(node.position, 0.5);
                connection.lookAt(node.position);
                connection.rotation.x += Math.PI / 2;
              }
            }
          },
        },
        {
          id: "chart-scene",
          name: "3D Chart Scene",
          category: "visualization",
          description: "Multiple chart types displayed in 3D environment",
          tags: ["Charts", "Graphs", "Statistics"],
          difficulty: "intermediate",
          icon: "fa-chart-area",
          setup: function () {
            // Floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(30, 30, 1);
            }

            // Area chart (stepped boxes)
            const areaData = [1, 2.5, 2, 3.5, 3, 4, 3.5, 5];
            for (let i = 0; i < areaData.length; i++) {
              const bar = createAsset("box");
              if (bar) {
                bar.scale.set(1.2, areaData[i], 0.3);
                bar.position.set(i * 1.5 - 10, areaData[i] / 2, -8);
              }
            }

            // Donut chart (torus)
            const donut = createAsset("torus");
            if (donut) {
              donut.scale.set(3, 3, 3);
              donut.position.set(-8, 2, 5);
              donut.rotation.x = Math.PI / 2;
            }

            // Scatter plot (small spheres)
            for (let i = 0; i < 20; i++) {
              const point = createAsset("sphere");
              if (point) {
                point.scale.set(0.3, 0.3, 0.3);
                point.position.set(
                  Math.random() * 8 + 4,
                  Math.random() * 5 + 0.5,
                  Math.random() * 8
                );
              }
            }
          },
        },
        {
          id: "analytics-view",
          name: "Analytics Dashboard",
          category: "visualization",
          description: "Real-time analytics display with KPI cards and metrics",
          tags: ["Analytics", "KPI", "Metrics"],
          difficulty: "beginner",
          badge: "new",
          icon: "fa-tachometer-alt",
          setup: function () {
            // Background plane
            const bg = createAsset("plane");
            if (bg) {
              bg.rotation.x = -Math.PI / 2;
              bg.scale.set(25, 20, 1);
            }

            // KPI Cards (elevated boxes)
            const kpiPositions = [
              { x: -8, z: -6 },
              { x: 0, z: -6 },
              { x: 8, z: -6 },
              { x: -8, z: 0 },
              { x: 0, z: 0 },
              { x: 8, z: 0 },
            ];

            kpiPositions.forEach((pos) => {
              const card = createAsset("box");
              if (card) {
                card.scale.set(3, 2, 0.2);
                card.position.set(pos.x, 1.5, pos.z);
              }

              // Value indicator (small box on top)
              const indicator = createAsset("box");
              if (indicator) {
                indicator.scale.set(2, 0.5, 0.1);
                indicator.position.set(pos.x, 2.6, pos.z);
              }
            });

            // Growth arrows (cones)
            for (let i = 0; i < 3; i++) {
              const arrow = createAsset("cone");
              if (arrow) {
                arrow.scale.set(0.3, 1, 0.3);
                arrow.position.set(i * 8 - 8, 3.5, -6);
              }
            }
          },
        },
        {
          id: "infographic-3d",
          name: "3D Infographic",
          category: "visualization",
          description: "Layered information display with icons and stats",
          tags: ["Infographic", "Information", "Display"],
          difficulty: "intermediate",
          icon: "fa-info-circle",
          setup: function () {
            // Central pillar with segments
            const segments = [3, 2.5, 2, 1.5];
            let yPos = 0;

            segments.forEach((height, i) => {
              const segment = createAsset("cylinder");
              if (segment) {
                const radius = 2 - i * 0.3;
                segment.scale.set(radius, height, radius);
                segment.position.set(0, yPos + height / 2, 0);
              }

              // Info cards around each segment
              for (let j = 0; j < 4; j++) {
                const angle = (Math.PI * 2 * j) / 4;
                const card = createAsset("box");
                if (card) {
                  card.scale.set(1.5, 1, 0.1);
                  card.position.set(
                    Math.cos(angle) * 4,
                    yPos + height / 2,
                    Math.sin(angle) * 4
                  );
                  card.rotation.y = -angle + Math.PI / 2;
                }
              }

              yPos += height;
            });
          },
        },
        {
          id: "presentation-3d",
          name: "3D Presentation",
          category: "visualization",
          description: "Slide-style presentation setup with multiple panels",
          tags: ["Presentation", "Slides", "Display"],
          difficulty: "beginner",
          icon: "fa-presentation",
          setup: function () {
            // Main presentation screen
            const mainScreen = createAsset("box");
            if (mainScreen) {
              mainScreen.scale.set(12, 7, 0.2);
              mainScreen.position.set(0, 4, -8);
            }

            // Side panels
            const leftPanel = createAsset("box");
            if (leftPanel) {
              leftPanel.scale.set(4, 6, 0.1);
              leftPanel.position.set(-9, 3.5, -3);
              leftPanel.rotation.y = Math.PI / 6;
            }

            const rightPanel = createAsset("box");
            if (rightPanel) {
              rightPanel.scale.set(4, 6, 0.1);
              rightPanel.position.set(9, 3.5, -3);
              rightPanel.rotation.y = -Math.PI / 6;
            }

            // Stage/platform
            const stage = createAsset("box");
            if (stage) {
              stage.scale.set(20, 0.3, 12);
              stage.position.set(0, -0.15, -2);
            }

            // Spotlights
            for (let i = 0; i < 3; i++) {
              const light = createAsset("spotLight");
              if (light) {
                light.position.set(i * 8 - 8, 8, 5);
              }
            }
          },
        },
        {
          id: "portfolio-3d",
          name: "3D Portfolio",
          category: "visualization",
          description: "Rotating portfolio display with project showcases",
          tags: ["Portfolio", "Showcase", "Gallery"],
          difficulty: "intermediate",
          icon: "fa-folder-open",
          setup: function () {
            // Central pedestal
            const pedestal = createAsset("cylinder");
            if (pedestal) {
              pedestal.scale.set(1, 0.5, 1);
              pedestal.position.y = 0.25;
            }

            // Rotating project displays in circle
            const projectCount = 6;
            for (let i = 0; i < projectCount; i++) {
              const angle = (Math.PI * 2 * i) / projectCount;

              // Project frame
              const frame = createAsset("box");
              if (frame) {
                frame.scale.set(3, 4, 0.2);
                frame.position.set(
                  Math.cos(angle) * 8,
                  2.5,
                  Math.sin(angle) * 8
                );
                frame.rotation.y = -angle;
              }

              // Project title bar
              const titleBar = createAsset("box");
              if (titleBar) {
                titleBar.scale.set(3, 0.5, 0.1);
                titleBar.position.set(
                  Math.cos(angle) * 8,
                  4.75,
                  Math.sin(angle) * 8
                );
                titleBar.rotation.y = -angle;
              }

              // Support pole
              const pole = createAsset("cylinder");
              if (pole) {
                pole.scale.set(0.1, 2, 0.1);
                pole.position.set(Math.cos(angle) * 8, 1, Math.sin(angle) * 8);
              }
            }

            // Lighting
            const topLight = createAsset("pointLight");
            if (topLight) {
              topLight.position.set(0, 6, 0);
            }
          },
        },

        // MORE WEBSITE INTEGRATION TEMPLATES
        {
          id: "landing-hero-full",
          name: "Landing Page Hero",
          category: "website",
          description: "Full-screen hero section with animated elements",
          tags: ["Landing", "Hero", "Marketing"],
          difficulty: "beginner",
          badge: "popular",
          icon: "fa-window-maximize",
          setup: function () {
            // Background geometric shapes
            for (let i = 0; i < 8; i++) {
              const shape = createAsset(i % 2 === 0 ? "sphere" : "torus");
              if (shape) {
                shape.position.set(
                  (Math.random() - 0.5) * 25,
                  (Math.random() - 0.5) * 12,
                  (Math.random() - 0.5) * 20 - 5
                );
                shape.scale.setScalar(Math.random() * 1.5 + 0.5);
                shape.rotation.set(
                  Math.random() * Math.PI,
                  Math.random() * Math.PI,
                  Math.random() * Math.PI
                );
              }
            }

            // Accent lights
            const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d];
            colors.forEach((color, i) => {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set((i - 1) * 8, 5, 3);
              }
            });
          },
        },
        {
          id: "about-section-3d",
          name: "About Section",
          category: "website",
          description:
            "Interactive about section with team members or features",
          tags: ["About", "Team", "Features"],
          difficulty: "beginner",
          icon: "fa-users",
          setup: function () {
            // Feature/team cards arranged in a grid
            const positions = [
              { x: -6, z: -3 },
              { x: 0, z: -3 },
              { x: 6, z: -3 },
              { x: -6, z: 3 },
              { x: 0, z: 3 },
              { x: 6, z: 3 },
            ];

            positions.forEach((pos, i) => {
              // Card base
              const card = createAsset("box");
              if (card) {
                card.scale.set(3, 4, 0.3);
                card.position.set(pos.x, 2, pos.z);
              }

              // Avatar/icon (sphere on top)
              const avatar = createAsset("sphere");
              if (avatar) {
                avatar.scale.set(0.8, 0.8, 0.8);
                avatar.position.set(pos.x, 4.5, pos.z + 0.2);
              }

              // Info bars
              for (let j = 0; j < 3; j++) {
                const bar = createAsset("box");
                if (bar) {
                  bar.scale.set(2.5, 0.2, 0.1);
                  bar.position.set(pos.x, 2.8 - j * 0.6, pos.z + 0.25);
                }
              }
            });
          },
        },
        {
          id: "services-grid",
          name: "Services Grid",
          category: "website",
          description: "Grid layout showcasing services or features",
          tags: ["Services", "Features", "Grid"],
          difficulty: "beginner",
          icon: "fa-th",
          setup: function () {
            // Floor platform
            const platform = createAsset("plane");
            if (platform) {
              platform.rotation.x = -Math.PI / 2;
              platform.scale.set(25, 20, 1);
            }

            // Service blocks in grid
            for (let row = 0; row < 2; row++) {
              for (let col = 0; col < 4; col++) {
                // Service card
                const card = createAsset("box");
                if (card) {
                  card.scale.set(3, 3.5, 0.5);
                  card.position.set(col * 5 - 7.5, 2, row * 6 - 3);
                }

                // Icon (sphere floating above)
                const icon = createAsset("torus");
                if (icon) {
                  icon.scale.set(0.6, 0.6, 0.6);
                  icon.position.set(col * 5 - 7.5, 4.2, row * 6 - 3);
                  icon.rotation.x = Math.PI / 2;
                }
              }
            }
          },
        },
        {
          id: "team-showcase",
          name: "Team Showcase",
          category: "website",
          description: "Circular team member display with profiles",
          tags: ["Team", "People", "About"],
          difficulty: "intermediate",
          icon: "fa-user-friends",
          setup: function () {
            // Central logo/company symbol
            const logo = createAsset("torus");
            if (logo) {
              logo.scale.set(2, 2, 2);
              logo.position.set(0, 2, 0);
              logo.rotation.x = Math.PI / 2;
            }

            // Team members in circle
            const memberCount = 8;
            for (let i = 0; i < memberCount; i++) {
              const angle = (Math.PI * 2 * i) / memberCount;

              // Profile card
              const card = createAsset("box");
              if (card) {
                card.scale.set(2, 2.5, 0.2);
                card.position.set(Math.cos(angle) * 8, 2, Math.sin(angle) * 8);
                card.rotation.y = -angle + Math.PI;
              }

              // Avatar
              const avatar = createAsset("sphere");
              if (avatar) {
                avatar.scale.set(0.7, 0.7, 0.7);
                avatar.position.set(
                  Math.cos(angle) * 8,
                  3.5,
                  Math.sin(angle) * 8
                );
              }

              // Connection line to center
              const line = createAsset("cylinder");
              if (line) {
                line.scale.set(0.03, 4, 0.03);
                line.position.set(Math.cos(angle) * 4, 2, Math.sin(angle) * 4);
                line.rotation.z = Math.PI / 2;
                line.rotation.y = angle;
              }
            }
          },
        },
        {
          id: "testimonials-3d",
          name: "Testimonials Section",
          category: "website",
          description: "Rotating testimonial cards with quotes",
          tags: ["Testimonials", "Reviews", "Social Proof"],
          difficulty: "beginner",
          icon: "fa-quote-right",
          setup: function () {
            // Testimonial cards in a carousel layout
            for (let i = 0; i < 5; i++) {
              const offset = (i - 2) * 5;

              // Card
              const card = createAsset("box");
              if (card) {
                card.scale.set(4, 3, 0.3);
                card.position.set(offset, 2, i === 2 ? -2 : 0);
                if (i !== 2) {
                  card.rotation.y = ((i < 2 ? 1 : -1) * Math.PI) / 8;
                }
              }

              // Quote icon
              const quote = createAsset("torus");
              if (quote) {
                quote.scale.set(0.4, 0.4, 0.4);
                quote.position.set(offset - 1.5, 3.5, i === 2 ? -1.8 : 0.2);
              }

              // Avatar circle
              const avatar = createAsset("sphere");
              if (avatar) {
                avatar.scale.set(0.5, 0.5, 0.5);
                avatar.position.set(offset, 0.7, i === 2 ? -1.8 : 0.2);
              }

              // Rating stars (small spheres)
              for (let j = 0; j < 5; j++) {
                const star = createAsset("sphere");
                if (star) {
                  star.scale.set(0.15, 0.15, 0.15);
                  star.position.set(
                    offset - 1 + j * 0.5,
                    3.8,
                    i === 2 ? -1.7 : 0.3
                  );
                }
              }
            }
          },
        },
        {
          id: "pricing-cards",
          name: "Pricing Cards",
          category: "website",
          description: "Three-tier pricing display with features",
          tags: ["Pricing", "Plans", "E-commerce"],
          difficulty: "beginner",
          badge: "popular",
          icon: "fa-dollar-sign",
          setup: function () {
            // Three pricing tiers
            const tiers = [
              { x: -7, height: 4, name: "Basic" },
              { x: 0, height: 5, name: "Pro" },
              { x: 7, height: 4, name: "Enterprise" },
            ];

            tiers.forEach((tier, i) => {
              // Card base
              const card = createAsset("box");
              if (card) {
                card.scale.set(3.5, tier.height, 0.4);
                card.position.set(tier.x, tier.height / 2, 0);
              }

              // Header section
              const header = createAsset("box");
              if (header) {
                header.scale.set(3.5, 0.8, 0.45);
                header.position.set(tier.x, tier.height - 0.4, 0);
              }

              // Price badge (cylinder)
              const badge = createAsset("cylinder");
              if (badge) {
                badge.scale.set(0.8, 0.3, 0.8);
                badge.position.set(tier.x, tier.height / 2, 0.5);
              }

              // Feature list (small boxes)
              const features = i === 1 ? 6 : 4;
              for (let j = 0; j < features; j++) {
                const feature = createAsset("box");
                if (feature) {
                  feature.scale.set(2.8, 0.25, 0.1);
                  feature.position.set(
                    tier.x,
                    tier.height / 2 - 1 - j * 0.5,
                    0.45
                  );
                }
              }

              // CTA button
              const button = createAsset("box");
              if (button) {
                button.scale.set(2.5, 0.6, 0.3);
                button.position.set(tier.x, -tier.height / 2 + 0.8, 0.5);
              }
            });
          },
        },
        {
          id: "contact-form-3d",
          name: "Contact Form Section",
          category: "website",
          description: "Interactive contact section with form fields",
          tags: ["Contact", "Form", "CTA"],
          difficulty: "beginner",
          icon: "fa-envelope",
          setup: function () {
            // Background
            const bg = createAsset("plane");
            if (bg) {
              bg.rotation.x = -Math.PI / 2;
              bg.scale.set(20, 15, 1);
            }

            // Form container
            const formBg = createAsset("box");
            if (formBg) {
              formBg.scale.set(8, 6, 0.3);
              formBg.position.set(-3, 3, 0);
            }

            // Input fields
            const fields = ["Name", "Email", "Subject", "Message"];
            fields.forEach((field, i) => {
              const input = createAsset("box");
              if (input) {
                const height = field === "Message" ? 1.5 : 0.5;
                input.scale.set(6.5, height, 0.1);
                input.position.set(-3, 5 - i * 1.2, 0.2);
              }
            });

            // Submit button
            const submit = createAsset("box");
            if (submit) {
              submit.scale.set(3, 0.6, 0.15);
              submit.position.set(-3, 0.8, 0.25);
            }

            // Contact info cards (right side)
            const infoCards = [
              { icon: "phone", y: 4.5 },
              { icon: "email", y: 2.5 },
              { icon: "location", y: 0.5 },
            ];

            infoCards.forEach((card) => {
              const cardBox = createAsset("box");
              if (cardBox) {
                cardBox.scale.set(3.5, 1.2, 0.2);
                cardBox.position.set(5, card.y, 0);
              }

              const icon = createAsset("sphere");
              if (icon) {
                icon.scale.set(0.4, 0.4, 0.4);
                icon.position.set(3.5, card.y, 0.3);
              }
            });
          },
        },
        {
          id: "blog-hero",
          name: "Blog Hero Section",
          category: "website",
          description: "Blog header with featured posts and categories",
          tags: ["Blog", "Articles", "Content"],
          difficulty: "intermediate",
          icon: "fa-blog",
          setup: function () {
            // Featured post (large card)
            const featured = createAsset("box");
            if (featured) {
              featured.scale.set(8, 5, 0.3);
              featured.position.set(-4, 3, 0);
            }

            // Featured image area
            const featuredImg = createAsset("box");
            if (featuredImg) {
              featuredImg.scale.set(7.5, 3, 0.1);
              featuredImg.position.set(-4, 4, 0.2);
            }

            // Recent posts (smaller cards)
            for (let i = 0; i < 3; i++) {
              const card = createAsset("box");
              if (card) {
                card.scale.set(3.5, 2.5, 0.25);
                card.position.set(4, 4.5 - i * 3, 0);
              }

              // Thumbnail
              const thumb = createAsset("box");
              if (thumb) {
                thumb.scale.set(3, 1.5, 0.1);
                thumb.position.set(4, 5 - i * 3, 0.15);
              }

              // Category tag
              const tag = createAsset("box");
              if (tag) {
                tag.scale.set(1, 0.3, 0.08);
                tag.position.set(2.8, 5.8 - i * 3, 0.2);
              }
            }

            // Category pills at bottom
            const categories = ["Tech", "Design", "Business", "Life", "Travel"];
            categories.forEach((cat, i) => {
              const pill = createAsset("cylinder");
              if (pill) {
                pill.scale.set(0.8, 0.25, 0.8);
                pill.position.set(i * 2.5 - 5, 0.25, 1);
                pill.rotation.x = Math.PI / 2;
              }
            });
          },
        },

        // MORE ENVIRONMENT TEMPLATES
        {
          id: "urban-street",
          name: "Urban Street",
          category: "environment",
          description:
            "City street with buildings, sidewalks, and urban elements",
          tags: ["Urban", "City", "Street"],
          difficulty: "intermediate",
          badge: "popular",
          icon: "fa-city",
          setup: function () {
            // Street/road
            const road = createAsset("box");
            if (road) {
              road.scale.set(8, 0.1, 50);
              road.position.set(0, -0.05, 0);
            }

            // Sidewalks
            for (let side = 0; side < 2; side++) {
              const sidewalk = createAsset("box");
              if (sidewalk) {
                sidewalk.scale.set(3, 0.15, 50);
                sidewalk.position.set(side === 0 ? -5.5 : 5.5, 0, 0);
              }
            }

            // Buildings on both sides
            for (let i = 0; i < 6; i++) {
              for (let side = 0; side < 2; side++) {
                const height = Math.random() * 10 + 8;
                const building = createAsset("box");
                if (building) {
                  building.scale.set(5, height, 7);
                  building.position.set(
                    side === 0 ? -11 : 11,
                    height / 2,
                    i * 15 - 35
                  );
                  building.userData.hasCollision = true;
                }

                // Windows (small boxes)
                for (let w = 0; w < 3; w++) {
                  const window = createAsset("box");
                  if (window) {
                    window.scale.set(0.1, 0.8, 0.8);
                    window.position.set(
                      side === 0 ? -8.5 : 8.5,
                      height * 0.7,
                      i * 15 - 35 + w * 2
                    );
                  }
                }
              }
            }

            // Street lights
            for (let i = 0; i < 8; i++) {
              const pole = createAsset("cylinder");
              if (pole) {
                pole.scale.set(0.1, 4, 0.1);
                pole.position.set(-7.5, 2, i * 12 - 42);
              }

              const light = createAsset("pointLight");
              if (light) {
                light.position.set(-7.5, 4.5, i * 12 - 42);
              }
            }
          },
        },
        {
          id: "office-interior",
          name: "Office Interior",
          category: "environment",
          description:
            "Modern office space with desks, chairs, and meeting areas",
          tags: ["Office", "Interior", "Workspace"],
          difficulty: "intermediate",
          icon: "fa-briefcase",
          setup: function () {
            // Floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(25, 0.2, 20);
              floor.position.y = -0.1;
            }

            // Ceiling
            const ceiling = createAsset("box");
            if (ceiling) {
              ceiling.scale.set(25, 0.2, 20);
              ceiling.position.y = 4;
            }

            // Walls
            const walls = [
              { x: 0, z: -10, ry: 0, sx: 25, sz: 0.5 },
              { x: 0, z: 10, ry: 0, sx: 25, sz: 0.5 },
              { x: -12.5, z: 0, ry: Math.PI / 2, sx: 20, sz: 0.5 },
              { x: 12.5, z: 0, ry: Math.PI / 2, sx: 20, sz: 0.5 },
            ];

            walls.forEach((w) => {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(w.sx, 4, w.sz);
                wall.position.set(w.x, 2, w.z);
                wall.rotation.y = w.ry;
              }
            });

            // Desk workstations (4x3 grid)
            for (let row = 0; row < 3; row++) {
              for (let col = 0; col < 4; col++) {
                // Desk
                const desk = createAsset("box");
                if (desk) {
                  desk.scale.set(2.5, 0.1, 1.5);
                  desk.position.set(col * 5 - 7.5, 0.75, row * 4 - 4);
                }

                // Chair (cylinder)
                const chair = createAsset("cylinder");
                if (chair) {
                  chair.scale.set(0.4, 0.5, 0.4);
                  chair.position.set(col * 5 - 7.5, 0.5, row * 4 - 4 + 1.2);
                }

                // Monitor (small box)
                const monitor = createAsset("box");
                if (monitor) {
                  monitor.scale.set(0.8, 0.5, 0.1);
                  monitor.position.set(col * 5 - 7.5, 1.1, row * 4 - 4 - 0.5);
                }
              }
            }

            // Meeting table (center back)
            const table = createAsset("box");
            if (table) {
              table.scale.set(5, 0.1, 2.5);
              table.position.set(0, 0.75, 7);
            }

            // Meeting chairs around table
            for (let i = 0; i < 6; i++) {
              const chair = createAsset("cylinder");
              if (chair) {
                chair.scale.set(0.4, 0.5, 0.4);
                const x = i % 2 === 0 ? -2.5 : 2.5;
                const z = 6 + Math.floor(i / 2) * 1.5 - 1.5;
                chair.position.set(x, 0.5, z);
              }
            }
          },
        },
        {
          id: "warehouse",
          name: "Warehouse",
          category: "environment",
          description: "Industrial warehouse with storage racks and crates",
          tags: ["Warehouse", "Industrial", "Storage"],
          difficulty: "beginner",
          icon: "fa-warehouse",
          setup: function () {
            // Floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(40, 30, 1);
            }

            // Walls (high ceiling)
            for (let i = 0; i < 4; i++) {
              const wall = createAsset("box");
              if (wall) {
                const angle = (Math.PI / 2) * i;
                wall.position.set(
                  Math.cos(angle) * 20,
                  5,
                  Math.sin(angle) * 15
                );
                wall.rotation.y = angle;
                wall.scale.set(i % 2 === 0 ? 40 : 30, 10, 0.5);
              }
            }

            // Storage racks (3 rows)
            for (let rack = 0; rack < 3; rack++) {
              for (let section = 0; section < 6; section++) {
                // Vertical poles
                for (let pole = 0; pole < 2; pole++) {
                  const support = createAsset("box");
                  if (support) {
                    support.scale.set(0.2, 4, 0.2);
                    support.position.set(
                      rack * 10 - 10 + pole * 3,
                      2,
                      section * 4 - 12
                    );
                  }
                }

                // Shelves (3 levels)
                for (let level = 0; level < 3; level++) {
                  const shelf = createAsset("box");
                  if (shelf) {
                    shelf.scale.set(3, 0.1, 1);
                    shelf.position.set(
                      rack * 10 - 8.5,
                      level * 1.5 + 0.5,
                      section * 4 - 12
                    );
                  }
                }
              }
            }

            // Scattered crates on floor
            for (let i = 0; i < 12; i++) {
              const crate = createAsset("box");
              if (crate) {
                crate.scale.set(1, 1, 1);
                crate.position.set(
                  Math.random() * 30 - 15,
                  0.5,
                  Math.random() * 20 - 10
                );
                crate.rotation.y = Math.random() * Math.PI;
              }
            }

            // Overhead lights
            for (let i = 0; i < 12; i++) {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(
                  (i % 4) * 10 - 15,
                  8,
                  Math.floor(i / 4) * 10 - 10
                );
              }
            }
          },
        },
        {
          id: "retail-store",
          name: "Retail Store",
          category: "environment",
          description:
            "Shop interior with product displays and checkout counter",
          tags: ["Retail", "Store", "Shopping"],
          difficulty: "intermediate",
          icon: "fa-store",
          setup: function () {
            // Floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(20, 0.1, 15);
              floor.position.y = 0;
            }

            // Back wall
            const backWall = createAsset("box");
            if (backWall) {
              backWall.scale.set(20, 4, 0.3);
              backWall.position.set(0, 2, -7.5);
            }

            // Side walls
            for (let side = 0; side < 2; side++) {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(0.3, 4, 15);
                wall.position.set(side === 0 ? -10 : 10, 2, 0);
              }
            }

            // Product display shelves along walls
            for (let i = 0; i < 6; i++) {
              const shelf = createAsset("box");
              if (shelf) {
                shelf.scale.set(2.5, 2, 0.8);
                shelf.position.set(i * 3 - 7.5, 1, -6.5);
              }

              // Products on shelf (small boxes)
              for (let p = 0; p < 3; p++) {
                const product = createAsset("box");
                if (product) {
                  product.scale.set(0.4, 0.4, 0.4);
                  product.position.set(i * 3 - 7.5 + (p - 1) * 0.6, 1.8, -6.3);
                }
              }
            }

            // Center display tables
            for (let i = 0; i < 3; i++) {
              const table = createAsset("cylinder");
              if (table) {
                table.scale.set(1.5, 0.8, 1.5);
                table.position.set(i * 6 - 6, 0.8, 0);
              }

              // Display items
              for (let j = 0; j < 4; j++) {
                const item = createAsset("sphere");
                if (item) {
                  const angle = (Math.PI * 2 * j) / 4;
                  item.scale.set(0.3, 0.3, 0.3);
                  item.position.set(
                    Math.cos(angle) * 0.8 + i * 6 - 6,
                    1.4,
                    Math.sin(angle) * 0.8
                  );
                }
              }
            }

            // Checkout counter
            const counter = createAsset("box");
            if (counter) {
              counter.scale.set(4, 1, 1.5);
              counter.position.set(-7, 0.5, 6);
            }

            // Cash register
            const register = createAsset("box");
            if (register) {
              register.scale.set(0.5, 0.3, 0.4);
              register.position.set(-7, 1.15, 6);
            }
          },
        },
        {
          id: "museum-hall",
          name: "Museum Hall",
          category: "environment",
          description: "Grand museum gallery with exhibits and pedestals",
          tags: ["Museum", "Gallery", "Exhibition"],
          difficulty: "advanced",
          icon: "fa-landmark",
          setup: function () {
            // Floor (marble effect would be nice)
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(30, 0.2, 25);
              floor.position.y = -0.1;
            }

            // Ceiling
            const ceiling = createAsset("box");
            if (ceiling) {
              ceiling.scale.set(30, 0.3, 25);
              ceiling.position.y = 8;
            }

            // Columns (6 on each side)
            for (let i = 0; i < 6; i++) {
              for (let side = 0; side < 2; side++) {
                const column = createAsset("cylinder");
                if (column) {
                  column.scale.set(0.6, 7, 0.6);
                  column.position.set(side === 0 ? -12 : 12, 3.5, i * 8 - 20);
                }

                // Capital (top of column)
                const capital = createAsset("box");
                if (capital) {
                  capital.scale.set(1, 0.5, 1);
                  capital.position.set(side === 0 ? -12 : 12, 7.25, i * 8 - 20);
                }
              }
            }

            // Center exhibit pedestals
            for (let i = 0; i < 5; i++) {
              const pedestal = createAsset("cylinder");
              if (pedestal) {
                pedestal.scale.set(1, 1.5, 1);
                pedestal.position.set(0, 0.75, i * 8 - 16);
              }

              // Exhibit item (sphere or box)
              const exhibit = createAsset(i % 2 === 0 ? "sphere" : "box");
              if (exhibit) {
                exhibit.scale.set(0.8, 0.8, 0.8);
                exhibit.position.set(0, 2, i * 8 - 16);
              }

              // Info plaque
              const plaque = createAsset("box");
              if (plaque) {
                plaque.scale.set(0.8, 0.4, 0.05);
                plaque.position.set(0, 0.3, i * 8 - 16 + 1.2);
              }

              // Spotlights
              const spotlight = createAsset("spotLight");
              if (spotlight) {
                spotlight.position.set(0, 6, i * 8 - 16);
              }
            }

            // Wall exhibits (paintings/frames)
            for (let i = 0; i < 8; i++) {
              for (let side = 0; side < 2; side++) {
                const frame = createAsset("box");
                if (frame) {
                  frame.scale.set(2, 1.5, 0.1);
                  frame.position.set(side === 0 ? -14.5 : 14.5, 3, i * 6 - 21);
                }
              }
            }
          },
        },
        {
          id: "outdoor-park",
          name: "Outdoor Park",
          category: "environment",
          description: "Park with trees, benches, pathways, and grass",
          tags: ["Park", "Outdoor", "Nature"],
          difficulty: "beginner",
          badge: "new",
          icon: "fa-tree",
          setup: function () {
            // Grass ground
            const ground = createAsset("plane");
            if (ground) {
              ground.rotation.x = -Math.PI / 2;
              ground.scale.set(50, 50, 1);
            }

            // Walking paths (cross pattern)
            const path1 = createAsset("box");
            if (path1) {
              path1.scale.set(3, 0.05, 50);
              path1.position.set(0, 0.025, 0);
            }

            const path2 = createAsset("box");
            if (path2) {
              path2.scale.set(50, 0.05, 3);
              path2.position.set(0, 0.025, 0);
            }

            // Trees scattered around
            for (let i = 0; i < 16; i++) {
              const x = (Math.random() - 0.5) * 40;
              const z = (Math.random() - 0.5) * 40;

              // Skip if too close to paths
              if (Math.abs(x) < 2 || Math.abs(z) < 2) continue;

              // Tree trunk
              const trunk = createAsset("cylinder");
              if (trunk) {
                trunk.scale.set(0.4, 3, 0.4);
                trunk.position.set(x, 1.5, z);
              }

              // Tree foliage
              const foliage = createAsset("sphere");
              if (foliage) {
                foliage.scale.set(2, 2, 2);
                foliage.position.set(x, 4, z);
              }
            }

            // Benches along paths
            for (let i = 0; i < 8; i++) {
              const bench = createAsset("box");
              if (bench) {
                bench.scale.set(1.5, 0.3, 0.6);
                const side = i % 4;
                if (side < 2) {
                  bench.position.set(
                    side === 0 ? -4 : 4,
                    0.4,
                    (i - 0.5) * 8 - 12
                  );
                } else {
                  bench.position.set((i - 6.5) * 8, 0.4, side === 2 ? -4 : 4);
                  bench.rotation.y = Math.PI / 2;
                }
              }

              // Bench back
              const back = createAsset("box");
              if (back) {
                back.scale.set(1.5, 0.5, 0.1);
                const side = i % 4;
                if (side < 2) {
                  back.position.set(
                    side === 0 ? -4 : 4,
                    0.8,
                    (i - 0.5) * 8 - 12 + 0.35
                  );
                } else {
                  back.position.set(
                    (i - 6.5) * 8 + 0.35,
                    0.8,
                    side === 2 ? -4 : 4
                  );
                  back.rotation.y = Math.PI / 2;
                }
              }
            }

            // Fountain in center
            const fountainBase = createAsset("cylinder");
            if (fountainBase) {
              fountainBase.scale.set(3, 0.5, 3);
              fountainBase.position.set(0, 0.25, 0);
            }

            const fountain = createAsset("cylinder");
            if (fountain) {
              fountain.scale.set(0.5, 2, 0.5);
              fountain.position.set(0, 1.5, 0);
            }
          },
        },
        {
          id: "space-station",
          name: "Space Station",
          category: "environment",
          description:
            "Sci-fi space station interior with corridors and consoles",
          tags: ["Sci-Fi", "Space", "Futuristic"],
          difficulty: "advanced",
          badge: "popular",
          icon: "fa-space-shuttle",
          setup: function () {
            // Main corridor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(6, 0.3, 40);
              floor.position.set(0, -0.15, 0);
            }

            const ceiling = createAsset("box");
            if (ceiling) {
              ceiling.scale.set(6, 0.3, 40);
              ceiling.position.set(0, 4.15, 0);
            }

            // Walls with panels
            for (let side = 0; side < 2; side++) {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(0.3, 4, 40);
                wall.position.set(side === 0 ? -3 : 3, 2, 0);
              }

              // Wall panels (decorative)
              for (let i = 0; i < 8; i++) {
                const panel = createAsset("box");
                if (panel) {
                  panel.scale.set(0.1, 1.5, 2);
                  panel.position.set(side === 0 ? -2.9 : 2.9, 2, i * 9 - 28);
                }

                // Panel lights
                const light = createAsset("box");
                if (light) {
                  light.scale.set(0.05, 0.2, 1.5);
                  light.position.set(
                    side === 0 ? -2.85 : 2.85,
                    1.2,
                    i * 9 - 28
                  );
                }
              }
            }

            // Ceiling lights
            for (let i = 0; i < 10; i++) {
              const lightStrip = createAsset("box");
              if (lightStrip) {
                lightStrip.scale.set(0.5, 0.1, 2);
                lightStrip.position.set(0, 3.9, i * 7 - 31);
              }

              const pointLight = createAsset("pointLight");
              if (pointLight) {
                pointLight.position.set(0, 3.5, i * 7 - 31);
              }
            }

            // Control consoles
            for (let i = 0; i < 4; i++) {
              const console = createAsset("box");
              if (console) {
                console.scale.set(1.5, 1.2, 0.6);
                console.position.set(2, 0.6, i * 18 - 27);
                console.rotation.y = -Math.PI / 4;
              }

              // Console screen
              const screen = createAsset("box");
              if (screen) {
                screen.scale.set(1.2, 0.8, 0.05);
                screen.position.set(1.8, 1.3, i * 18 - 27.2);
                screen.rotation.y = -Math.PI / 4;
                screen.rotation.x = -Math.PI / 12;
              }
            }

            // Bulkhead doors
            for (let i = 0; i < 3; i++) {
              const doorFrame = createAsset("torus");
              if (doorFrame) {
                doorFrame.scale.set(1.5, 1.5, 1.5);
                doorFrame.position.set(0, 2, i * 16 - 16);
                doorFrame.rotation.x = Math.PI / 2;
              }
            }
          },
        },
        {
          id: "underground-cave",
          name: "Underground Cave",
          category: "environment",
          description:
            "Dark cave system with stalactites, stalagmites, and crystals",
          tags: ["Cave", "Underground", "Dark"],
          difficulty: "advanced",
          icon: "fa-mountain",
          setup: function () {
            // Cave floor (uneven)
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(30, 25, 1);
            }

            // Cave walls (rough boxes)
            for (let i = 0; i < 12; i++) {
              const wall = createAsset("box");
              if (wall) {
                const angle = (Math.PI * 2 * i) / 12;
                const distance = 12 + Math.random() * 3;
                wall.scale.set(3 + Math.random() * 2, 4 + Math.random() * 2, 1);
                wall.position.set(
                  Math.cos(angle) * distance,
                  2,
                  Math.sin(angle) * distance
                );
                wall.rotation.y = -angle + Math.PI / 2;
              }
            }

            // Stalactites (ceiling cones)
            for (let i = 0; i < 15; i++) {
              const stalactite = createAsset("cone");
              if (stalactite) {
                stalactite.scale.set(
                  0.3 + Math.random() * 0.4,
                  1 + Math.random() * 2,
                  0.3 + Math.random() * 0.4
                );
                stalactite.position.set(
                  (Math.random() - 0.5) * 20,
                  6,
                  (Math.random() - 0.5) * 20
                );
                stalactite.rotation.x = Math.PI;
              }
            }

            // Stalagmites (floor cones)
            for (let i = 0; i < 15; i++) {
              const stalagmite = createAsset("cone");
              if (stalagmite) {
                stalagmite.scale.set(
                  0.4 + Math.random() * 0.5,
                  1.5 + Math.random() * 2.5,
                  0.4 + Math.random() * 0.5
                );
                stalagmite.position.set(
                  (Math.random() - 0.5) * 22,
                  stalagmite.scale.y / 2,
                  (Math.random() - 0.5) * 22
                );
              }
            }

            // Crystal formations (glowing)
            const crystalPositions = [
              { x: -8, z: -8 },
              { x: 8, z: -8 },
              { x: -8, z: 8 },
              { x: 8, z: 8 },
              { x: 0, z: 0 },
            ];

            crystalPositions.forEach((pos) => {
              // Crystal cluster
              for (let i = 0; i < 5; i++) {
                const crystal = createAsset("cone");
                if (crystal) {
                  crystal.scale.set(0.3, 1.5, 0.3);
                  crystal.position.set(
                    pos.x + (Math.random() - 0.5) * 2,
                    0.75,
                    pos.z + (Math.random() - 0.5) * 2
                  );
                  crystal.rotation.z = ((Math.random() - 0.5) * Math.PI) / 4;
                }
              }

              // Crystal glow light
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(pos.x, 1.5, pos.z);
              }
            });

            // Rocks scattered on floor
            for (let i = 0; i < 20; i++) {
              const rock = createAsset("sphere");
              if (rock) {
                rock.scale.set(
                  0.5 + Math.random() * 0.8,
                  0.4 + Math.random() * 0.6,
                  0.5 + Math.random() * 0.8
                );
                rock.position.set(
                  (Math.random() - 0.5) * 25,
                  rock.scale.y / 2,
                  (Math.random() - 0.5) * 25
                );
              }
            }
          },
        },

        // SPECIALTY TEMPLATES
        {
          id: "particle-system",
          name: "Particle System Demo",
          category: "specialty",
          description: "Interactive particle effects and emitters",
          tags: ["Particles", "Effects", "Demo"],
          difficulty: "advanced",
          badge: "advanced",
          icon: "fa-star",
          setup: function () {
            // Emitter sources
            for (let i = 0; i < 4; i++) {
              const emitter = createAsset("sphere");
              if (emitter) {
                const angle = (Math.PI * 2 * i) / 4;
                emitter.scale.set(0.5, 0.5, 0.5);
                emitter.position.set(
                  Math.cos(angle) * 8,
                  3,
                  Math.sin(angle) * 8
                );
              }

              // Simulated particles (small spheres)
              for (let j = 0; j < 8; j++) {
                const particle = createAsset("sphere");
                if (particle) {
                  particle.scale.set(0.1, 0.1, 0.1);
                  particle.position.set(
                    Math.cos(angle) * 8 + (Math.random() - 0.5) * 3,
                    3 + Math.random() * 4,
                    Math.sin(angle) * 8 + (Math.random() - 0.5) * 3
                  );
                }
              }

              // Light for glow effect
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(Math.cos(angle) * 8, 3, Math.sin(angle) * 8);
              }
            }

            // Floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(25, 25, 1);
            }
          },
        },
        {
          id: "physics-playground",
          name: "Physics Playground",
          category: "specialty",
          description: "Interactive physics demonstration with various shapes",
          tags: ["Physics", "Simulation", "Interactive"],
          difficulty: "advanced",
          icon: "fa-bowling-ball",
          setup: function () {
            // Ground plane
            const ground = createAsset("box");
            if (ground) {
              ground.scale.set(30, 0.5, 30);
              ground.position.y = -0.25;
              ground.userData.hasCollision = true;
            }

            // Ramp
            const ramp = createAsset("box");
            if (ramp) {
              ramp.scale.set(6, 0.5, 10);
              ramp.position.set(-10, 3, 0);
              ramp.rotation.z = -Math.PI / 6;
              ramp.userData.hasCollision = true;
            }

            // Stacked boxes (tower)
            for (let i = 0; i < 6; i++) {
              const box = createAsset("box");
              if (box) {
                box.scale.set(1.5, 1, 1.5);
                box.position.set(5, 0.5 + i * 1, 0);
                box.userData.hasPhysics = true;
              }
            }

            // Balls/spheres
            for (let i = 0; i < 5; i++) {
              const ball = createAsset("sphere");
              if (ball) {
                ball.scale.set(0.7, 0.7, 0.7);
                ball.position.set(-5 + i * 2, 6 + Math.random() * 2, -5);
                ball.userData.hasPhysics = true;
              }
            }

            // Pendulum
            const anchor = createAsset("sphere");
            if (anchor) {
              anchor.scale.set(0.3, 0.3, 0.3);
              anchor.position.set(0, 8, -8);
            }

            const pendulumBall = createAsset("sphere");
            if (pendulumBall) {
              pendulumBall.scale.set(1, 1, 1);
              pendulumBall.position.set(3, 3, -8);
            }

            // Rope (cylinder)
            const rope = createAsset("cylinder");
            if (rope) {
              rope.scale.set(0.05, 2.5, 0.05);
              rope.position.set(1.5, 5.5, -8);
              rope.rotation.z = Math.PI / 6;
            }
          },
        },
        {
          id: "ar-preview",
          name: "AR Preview Scene",
          category: "specialty",
          description: "AR-ready product placement scene",
          tags: ["AR", "Mobile", "Preview"],
          difficulty: "intermediate",
          badge: "new",
          icon: "fa-mobile-alt",
          setup: function () {
            // Reference grid floor
            for (let x = -5; x <= 5; x++) {
              for (let z = -5; z <= 5; z++) {
                const gridCell = createAsset("box");
                if (gridCell) {
                  gridCell.scale.set(0.95, 0.05, 0.95);
                  gridCell.position.set(x, 0.025, z);
                }
              }
            }

            // AR marker (center)
            const marker = createAsset("torus");
            if (marker) {
              marker.scale.set(2, 2, 2);
              marker.position.set(0, 0.1, 0);
              marker.rotation.x = Math.PI / 2;
            }

            // Product pedestal
            const pedestal = createAsset("cylinder");
            if (pedestal) {
              pedestal.scale.set(1.5, 1, 1.5);
              pedestal.position.set(0, 0.5, 0);
            }

            // Sample product (box)
            const product = createAsset("box");
            if (product) {
              product.scale.set(1.2, 1.5, 1.2);
              product.position.set(0, 1.75, 0);
              product.rotation.y = Math.PI / 4;
            }

            // Info cards floating around
            const cardPositions = [
              { x: 3, z: 0 },
              { x: -3, z: 0 },
              { x: 0, z: 3 },
              { x: 0, z: -3 },
            ];

            cardPositions.forEach((pos) => {
              const card = createAsset("box");
              if (card) {
                card.scale.set(1, 0.7, 0.05);
                card.position.set(pos.x, 2, pos.z);
              }
            });

            // Directional lights
            for (let i = 0; i < 3; i++) {
              const light = createAsset("pointLight");
              if (light) {
                const angle = (Math.PI * 2 * i) / 3;
                light.position.set(Math.cos(angle) * 5, 4, Math.sin(angle) * 5);
              }
            }
          },
        },
        {
          id: "vr-room",
          name: "VR Room Template",
          category: "specialty",
          description: "VR-ready room with interactive elements",
          tags: ["VR", "Virtual Reality", "Interactive"],
          difficulty: "advanced",
          badge: "popular",
          icon: "fa-vr-cardboard",
          setup: function () {
            // Room floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(10, 0.2, 10);
              floor.position.y = -0.1;
            }

            // Walls
            const walls = [
              { x: 0, z: -5, ry: 0 },
              { x: 0, z: 5, ry: 0 },
              { x: -5, z: 0, ry: Math.PI / 2 },
              { x: 5, z: 0, ry: Math.PI / 2 },
            ];

            walls.forEach((w) => {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(10, 4, 0.3);
                wall.position.set(w.x, 2, w.z);
                wall.rotation.y = w.ry;
              }
            });

            // Ceiling
            const ceiling = createAsset("box");
            if (ceiling) {
              ceiling.scale.set(10, 0.2, 10);
              ceiling.position.y = 4.1;
            }

            // Interactive objects floating in space
            const objects = [
              { type: "sphere", pos: { x: -2, y: 2, z: -2 } },
              { type: "box", pos: { x: 2, y: 2, z: -2 } },
              { type: "torus", pos: { x: -2, y: 2, z: 2 } },
              { type: "cone", pos: { x: 2, y: 2, z: 2 } },
              { type: "cylinder", pos: { x: 0, y: 2.5, z: 0 } },
            ];

            objects.forEach((obj) => {
              const object = createAsset(obj.type);
              if (object) {
                object.scale.set(0.8, 0.8, 0.8);
                object.position.set(obj.pos.x, obj.pos.y, obj.pos.z);
                object.userData.isInteractive = true;
              }
            });

            // Teleport markers (floor positions)
            const markers = [
              { x: -3, z: -3 },
              { x: 3, z: -3 },
              { x: -3, z: 3 },
              { x: 3, z: 3 },
            ];

            markers.forEach((m) => {
              const marker = createAsset("cylinder");
              if (marker) {
                marker.scale.set(0.5, 0.05, 0.5);
                marker.position.set(m.x, 0.05, m.z);
              }
            });
          },
        },
        {
          id: "education-lab",
          name: "Education Lab",
          category: "specialty",
          description:
            "Interactive educational environment with demonstrations",
          tags: ["Education", "Learning", "Science"],
          difficulty: "intermediate",
          icon: "fa-graduation-cap",
          setup: function () {
            // Floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(20, 0.2, 15);
              floor.position.y = 0;
            }

            // Experiment stations (tables with equipment)
            for (let i = 0; i < 4; i++) {
              // Table
              const table = createAsset("box");
              if (table) {
                table.scale.set(3, 0.1, 2);
                table.position.set(i * 5 - 7.5, 0.8, -4);
              }

              // Equipment (beakers, apparatus)
              for (let j = 0; j < 3; j++) {
                const equipment = createAsset(j === 1 ? "cylinder" : "cone");
                if (equipment) {
                  equipment.scale.set(0.3, 0.5, 0.3);
                  equipment.position.set(i * 5 - 7.5 + (j - 1) * 0.8, 1.2, -4);
                }
              }
            }

            // Whiteboard
            const board = createAsset("box");
            if (board) {
              board.scale.set(6, 3, 0.1);
              board.position.set(0, 2.5, -7.4);
            }

            // Molecular model (atoms and bonds)
            const modelCenter = { x: 0, y: 2, z: 4 };

            // Central atom
            const centerAtom = createAsset("sphere");
            if (centerAtom) {
              centerAtom.scale.set(0.6, 0.6, 0.6);
              centerAtom.position.set(
                modelCenter.x,
                modelCenter.y,
                modelCenter.z
              );
            }

            // Surrounding atoms
            for (let i = 0; i < 4; i++) {
              const angle = (Math.PI * 2 * i) / 4;
              const atom = createAsset("sphere");
              if (atom) {
                atom.scale.set(0.4, 0.4, 0.4);
                atom.position.set(
                  modelCenter.x + Math.cos(angle) * 2,
                  modelCenter.y,
                  modelCenter.z + Math.sin(angle) * 2
                );
              }

              // Bond (cylinder)
              const bond = createAsset("cylinder");
              if (bond) {
                bond.scale.set(0.05, 1, 0.05);
                bond.position.set(
                  modelCenter.x + Math.cos(angle) * 1,
                  modelCenter.y,
                  modelCenter.z + Math.sin(angle) * 1
                );
                bond.rotation.z = Math.PI / 2;
                bond.rotation.y = angle;
              }
            }

            // Display screens on walls
            for (let i = 0; i < 3; i++) {
              const screen = createAsset("box");
              if (screen) {
                screen.scale.set(2.5, 1.5, 0.05);
                screen.position.set(i * 4 - 4, 2.5, 7.4);
              }
            }
          },
        },
        {
          id: "medical-viz",
          name: "Medical Visualization",
          category: "specialty",
          description: "Medical/anatomy visualization environment",
          tags: ["Medical", "Healthcare", "Science"],
          difficulty: "advanced",
          icon: "fa-heartbeat",
          setup: function () {
            // Clean room floor
            const floor = createAsset("plane");
            if (floor) {
              floor.rotation.x = -Math.PI / 2;
              floor.scale.set(20, 20, 1);
            }

            // Central anatomy display (simplified skeleton)
            // Spine
            for (let i = 0; i < 8; i++) {
              const vertebra = createAsset("sphere");
              if (vertebra) {
                vertebra.scale.set(0.3, 0.4, 0.3);
                vertebra.position.set(0, 1 + i * 0.4, 0);
              }
            }

            // Skull
            const skull = createAsset("sphere");
            if (skull) {
              skull.scale.set(0.6, 0.7, 0.6);
              skull.position.set(0, 4.5, 0);
            }

            // Ribcage simulation
            for (let i = 0; i < 6; i++) {
              for (let side = 0; side < 2; side++) {
                const rib = createAsset("torus");
                if (rib) {
                  rib.scale.set(0.4 + i * 0.1, 0.4 + i * 0.1, 0.4 + i * 0.1);
                  rib.position.set(side === 0 ? -0.3 : 0.3, 3.5 - i * 0.3, 0);
                  rib.rotation.y = ((side === 0 ? 1 : -1) * Math.PI) / 6;
                  rib.rotation.x = Math.PI / 2;
                }
              }
            }

            // Organ displays (abstract representations)
            const organs = [
              { name: "Heart", pos: { x: -4, z: -4 } },
              { name: "Lungs", pos: { x: 4, z: -4 } },
              { name: "Brain", pos: { x: -4, z: 4 } },
              { name: "Liver", pos: { x: 4, z: 4 } },
            ];

            organs.forEach((organ) => {
              // Pedestal
              const pedestal = createAsset("cylinder");
              if (pedestal) {
                pedestal.scale.set(0.8, 1, 0.8);
                pedestal.position.set(organ.pos.x, 0.5, organ.pos.z);
              }

              // Organ model (sphere)
              const model = createAsset("sphere");
              if (model) {
                model.scale.set(0.6, 0.6, 0.6);
                model.position.set(organ.pos.x, 1.5, organ.pos.z);
              }

              // Label
              const label = createAsset("box");
              if (label) {
                label.scale.set(1.2, 0.3, 0.05);
                label.position.set(organ.pos.x, 0.2, organ.pos.z + 1);
              }
            });

            // Information panels
            for (let i = 0; i < 4; i++) {
              const panel = createAsset("box");
              if (panel) {
                const angle = (Math.PI * 2 * i) / 4;
                panel.scale.set(2, 3, 0.1);
                panel.position.set(Math.cos(angle) * 8, 2, Math.sin(angle) * 8);
                panel.rotation.y = -angle;
              }
            }
          },
        },
        {
          id: "architectural",
          name: "Architectural Walkthrough",
          category: "specialty",
          description: "Building interior for architectural visualization",
          tags: ["Architecture", "Building", "Real Estate"],
          difficulty: "intermediate",
          badge: "popular",
          icon: "fa-building",
          setup: function () {
            // Main floor plan
            const mainFloor = createAsset("box");
            if (mainFloor) {
              mainFloor.scale.set(20, 0.2, 15);
              mainFloor.position.y = 0;
            }

            // Exterior walls
            const exteriorWalls = [
              { x: 0, z: -7.5, sx: 20, sz: 0.5 },
              { x: 0, z: 7.5, sx: 20, sz: 0.5 },
              { x: -10, z: 0, sx: 0.5, sz: 15 },
              { x: 10, z: 0, sx: 0.5, sz: 15 },
            ];

            exteriorWalls.forEach((wall) => {
              const w = createAsset("box");
              if (w) {
                w.scale.set(wall.sx, 4, wall.sz);
                w.position.set(wall.x, 2, wall.z);
              }
            });

            // Interior partition walls
            const partitions = [
              { x: 0, z: 0, sx: 0.2, sz: 12 },
              { x: -4, z: 0, sx: 0.2, sz: 6 },
            ];

            partitions.forEach((part) => {
              const wall = createAsset("box");
              if (wall) {
                wall.scale.set(part.sx, 4, part.sz);
                wall.position.set(part.x, 2, part.z);
              }
            });

            // Windows (transparent boxes)
            for (let i = 0; i < 5; i++) {
              const window = createAsset("box");
              if (window) {
                window.scale.set(1.5, 1.2, 0.1);
                window.position.set(i * 4 - 8, 2, -7.4);
              }
            }

            // Doorways (arches)
            const doorways = [
              { x: -4, z: -3 },
              { x: -4, z: 3 },
              { x: 0, z: -4 },
            ];

            doorways.forEach((door) => {
              const frame = createAsset("box");
              if (frame) {
                frame.scale.set(1.2, 2.5, 0.2);
                frame.position.set(door.x, 1.25, door.z);
              }
            });

            // Furniture
            // Living room sofa
            const sofa = createAsset("box");
            if (sofa) {
              sofa.scale.set(3, 0.8, 1.2);
              sofa.position.set(-6, 0.4, -4);
            }

            // Dining table
            const table = createAsset("box");
            if (table) {
              table.scale.set(2.5, 0.1, 1.5);
              table.position.set(6, 0.75, -4);
            }

            // Chairs around table
            for (let i = 0; i < 4; i++) {
              const chair = createAsset("box");
              if (chair) {
                chair.scale.set(0.5, 0.5, 0.5);
                const offset = i < 2 ? -1.2 : 1.2;
                chair.position.set(
                  6 + (i % 2 === 0 ? -1.5 : 1.5),
                  0.25,
                  -4 + offset
                );
              }
            }

            // Ceiling lights
            for (let i = 0; i < 4; i++) {
              const light = createAsset("pointLight");
              if (light) {
                light.position.set(i % 2 === 0 ? -5 : 5, 3.5, i < 2 ? -3 : 3);
              }
            }
          },
        },
        {
          id: "automotive",
          name: "Automotive Showcase",
          category: "specialty",
          description: "Car showroom environment with turntable",
          tags: ["Automotive", "Car", "Showroom"],
          difficulty: "intermediate",
          icon: "fa-car",
          setup: function () {
            // Showroom floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(25, 0.1, 20);
              floor.position.y = 0;
            }

            // Rotating platform/turntable
            const platform = createAsset("cylinder");
            if (platform) {
              platform.scale.set(5, 0.3, 5);
              platform.position.set(0, 0.15, 0);
            }

            // Simple car model (abstract)
            // Car body
            const carBody = createAsset("box");
            if (carBody) {
              carBody.scale.set(3, 1, 1.5);
              carBody.position.set(0, 0.8, 0);
            }

            // Car roof/cabin
            const cabin = createAsset("box");
            if (cabin) {
              cabin.scale.set(1.8, 0.8, 1.3);
              cabin.position.set(-0.2, 1.6, 0);
            }

            // Wheels
            const wheelPositions = [
              { x: 1, z: 1 },
              { x: 1, z: -1 },
              { x: -1, z: 1 },
              { x: -1, z: -1 },
            ];

            wheelPositions.forEach((pos) => {
              const wheel = createAsset("cylinder");
              if (wheel) {
                wheel.scale.set(0.4, 0.2, 0.4);
                wheel.position.set(pos.x, 0.4, pos.z);
                wheel.rotation.z = Math.PI / 2;
              }
            });

            // Spotlights focused on car
            for (let i = 0; i < 4; i++) {
              const angle = (Math.PI * 2 * i) / 4;
              const light = createAsset("spotLight");
              if (light) {
                light.position.set(Math.cos(angle) * 8, 5, Math.sin(angle) * 8);
              }
            }

            // Info displays around the room
            const displays = [
              { x: -10, z: -8 },
              { x: 10, z: -8 },
              { x: -10, z: 8 },
              { x: 10, z: 8 },
            ];

            displays.forEach((disp) => {
              // Display stand
              const stand = createAsset("box");
              if (stand) {
                stand.scale.set(0.5, 1.5, 0.5);
                stand.position.set(disp.x, 0.75, disp.z);
              }

              // Screen
              const screen = createAsset("box");
              if (screen) {
                screen.scale.set(2, 1.5, 0.1);
                screen.position.set(disp.x, 2, disp.z);
              }
            });

            // Velvet ropes/barriers
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 * i) / 8;
              const post = createAsset("cylinder");
              if (post) {
                post.scale.set(0.1, 1, 0.1);
                post.position.set(
                  Math.cos(angle) * 6,
                  0.5,
                  Math.sin(angle) * 6
                );
              }
            }
          },
        },
        {
          id: "fashion-show",
          name: "Fashion Runway",
          category: "specialty",
          description: "Fashion show runway with lighting and seating",
          tags: ["Fashion", "Runway", "Event"],
          difficulty: "intermediate",
          icon: "fa-tshirt",
          setup: function () {
            // Main floor
            const floor = createAsset("box");
            if (floor) {
              floor.scale.set(30, 0.1, 25);
              floor.position.y = 0;
            }

            // Runway
            const runway = createAsset("box");
            if (runway) {
              runway.scale.set(4, 0.15, 20);
              runway.position.set(0, 0.08, 0);
            }

            // Stage (T-shape end)
            const stage = createAsset("box");
            if (stage) {
              stage.scale.set(8, 0.15, 4);
              stage.position.set(0, 0.08, -10);
            }

            // Seating (both sides)
            for (let side = 0; side < 2; side++) {
              for (let row = 0; row < 3; row++) {
                for (let seat = 0; seat < 8; seat++) {
                  const chair = createAsset("box");
                  if (chair) {
                    chair.scale.set(0.6, 0.4, 0.6);
                    chair.position.set(
                      (side === 0 ? -4 : 4) - row * 1.2,
                      0.2,
                      seat * 2.5 - 8.75
                    );
                  }

                  // Chair back
                  const back = createAsset("box");
                  if (back) {
                    back.scale.set(0.6, 0.6, 0.1);
                    back.position.set(
                      (side === 0 ? -4 : 4) - row * 1.2,
                      0.5,
                      seat * 2.5 - 8.75 + (side === 0 ? -0.35 : 0.35)
                    );
                  }
                }
              }
            }

            // Runway edge lights
            for (let i = 0; i < 10; i++) {
              for (let side = 0; side < 2; side++) {
                const light = createAsset("cylinder");
                if (light) {
                  light.scale.set(0.15, 0.2, 0.15);
                  light.position.set(side === 0 ? -2.2 : 2.2, 0.1, i * 2 - 9);
                }

                const pointLight = createAsset("pointLight");
                if (pointLight) {
                  pointLight.position.set(
                    side === 0 ? -2.2 : 2.2,
                    0.3,
                    i * 2 - 9
                  );
                }
              }
            }

            // Overhead lighting rig
            for (let i = 0; i < 6; i++) {
              const rigLight = createAsset("spotLight");
              if (rigLight) {
                rigLight.position.set(
                  i % 2 === 0 ? -2 : 2,
                  6,
                  Math.floor(i / 2) * 6 - 6
                );
              }
            }

            // Backdrop at stage
            const backdrop = createAsset("box");
            if (backdrop) {
              backdrop.scale.set(10, 5, 0.2);
              backdrop.position.set(0, 2.5, -12);
            }

            // Logo/brand display
            const logo = createAsset("box");
            if (logo) {
              logo.scale.set(3, 1, 0.1);
              logo.position.set(0, 4, -11.95);
            }
          },
        },
        {
          id: "event-stage",
          name: "Event Stage",
          category: "specialty",
          description: "Concert/event stage with lighting and equipment",
          tags: ["Event", "Concert", "Stage"],
          difficulty: "advanced",
          badge: "new",
          icon: "fa-microphone",
          setup: function () {
            // Stage platform
            const stage = createAsset("box");
            if (stage) {
              stage.scale.set(15, 1, 10);
              stage.position.set(0, 0.5, -8);
            }

            // Stage riser (elevated section)
            const riser = createAsset("box");
            if (riser) {
              riser.scale.set(10, 0.5, 6);
              riser.position.set(0, 1.25, -10);
            }

            // Backdrop/LED wall
            const backdrop = createAsset("box");
            if (backdrop) {
              backdrop.scale.set(14, 8, 0.5);
              backdrop.position.set(0, 4, -13);
            }

            // Speaker stacks (both sides)
            for (let side = 0; side < 2; side++) {
              for (let i = 0; i < 3; i++) {
                const speaker = createAsset("box");
                if (speaker) {
                  speaker.scale.set(1.5, 1, 1.2);
                  speaker.position.set(side === 0 ? -7 : 7, 0.5 + i * 1, -8);
                }

                // Speaker cones (cylinders)
                for (let c = 0; c < 2; c++) {
                  const cone = createAsset("cylinder");
                  if (cone) {
                    cone.scale.set(0.3, 0.1, 0.3);
                    cone.position.set(
                      side === 0 ? -7 : 7,
                      0.5 + i * 1 + (c === 0 ? -0.2 : 0.2),
                      -7.4
                    );
                    cone.rotation.x = Math.PI / 2;
                  }
                }
              }
            }

            // Lighting truss
            const truss = createAsset("box");
            if (truss) {
              truss.scale.set(16, 0.3, 0.3);
              truss.position.set(0, 8, -8);
            }

            // Stage lights on truss
            for (let i = 0; i < 8; i++) {
              const lightFixture = createAsset("box");
              if (lightFixture) {
                lightFixture.scale.set(0.4, 0.6, 0.4);
                lightFixture.position.set(i * 2 - 7, 7.7, -8);
              }

              const light = createAsset("spotLight");
              if (light) {
                light.position.set(i * 2 - 7, 7.5, -8);
              }
            }

            // Equipment/gear on stage
            // Drum kit
            const drumPlatform = createAsset("cylinder");
            if (drumPlatform) {
              drumPlatform.scale.set(2, 0.2, 2);
              drumPlatform.position.set(0, 1.6, -11);
            }

            for (let i = 0; i < 5; i++) {
              const drum = createAsset("cylinder");
              if (drum) {
                const angle = (Math.PI * 2 * i) / 5;
                drum.scale.set(0.3, 0.4, 0.3);
                drum.position.set(
                  Math.cos(angle) * 1.2,
                  1.9,
                  -11 + Math.sin(angle) * 1.2
                );
              }
            }

            // Microphone stands
            for (let i = 0; i < 3; i++) {
              const stand = createAsset("cylinder");
              if (stand) {
                stand.scale.set(0.05, 2, 0.05);
                stand.position.set(i * 3 - 3, 2, -8);
              }

              const mic = createAsset("sphere");
              if (mic) {
                mic.scale.set(0.2, 0.2, 0.2);
                mic.position.set(i * 3 - 3, 3, -8);
              }
            }

            // Amplifiers
            for (let i = 0; i < 4; i++) {
              const amp = createAsset("box");
              if (amp) {
                amp.scale.set(0.8, 1, 0.6);
                amp.position.set((i - 1.5) * 2, 1.5, -6);
              }
            }

            // Audience floor area
            const audienceFloor = createAsset("box");
            if (audienceFloor) {
              audienceFloor.scale.set(20, 0.1, 15);
              audienceFloor.position.set(0, 0, 5);
            }
          },
        },
      ];

      let currentFilter = "all";

      // Template Manager Functions
      function showTemplateLibrary() {
        const modal = document.getElementById("template-modal");
        modal.classList.add("show");
        renderTemplates();
      }

      function hideTemplateLibrary() {
        const modal = document.getElementById("template-modal");
        modal.classList.remove("show");
      }

      function filterTemplates(category) {
        currentFilter = category;

        // Update active filter button
        document.querySelectorAll(".template-filter-btn").forEach((btn) => {
          btn.classList.remove("active");
          if (btn.getAttribute("data-category") === category) {
            btn.classList.add("active");
          }
        });

        renderTemplates();
      }

      function renderTemplates() {
        const container = document.getElementById("template-grid-container");
        container.innerHTML = "";

        // Filter templates
        let filtered =
          currentFilter === "all"
            ? templateLibrary
            : templateLibrary.filter((t) => t.category === currentFilter);

        // Group by category
        const categories = {
          game: { title: "Game Templates", icon: "fa-gamepad" },
          visualization: {
            title: "Visualization Templates",
            icon: "fa-chart-bar",
          },
          website: { title: "Website Integration", icon: "fa-globe" },
          environment: { title: "Environment Templates", icon: "fa-tree" },
          specialty: { title: "Specialty Templates", icon: "fa-magic" },
        };

        Object.keys(categories).forEach((cat) => {
          const categoryTemplates = filtered.filter((t) => t.category === cat);
          if (categoryTemplates.length === 0) return;

          const categoryDiv = document.createElement("div");

          const titleDiv = document.createElement("div");
          titleDiv.className = "template-category-title";
          titleDiv.innerHTML = `<i class="fas ${categories[cat].icon}"></i> ${categories[cat].title}`;
          categoryDiv.appendChild(titleDiv);

          const gridDiv = document.createElement("div");
          gridDiv.className = "template-grid";

          categoryTemplates.forEach((template) => {
            const card = createTemplateCard(template);
            gridDiv.appendChild(card);
          });

          categoryDiv.appendChild(gridDiv);
          container.appendChild(categoryDiv);
        });
      }

      function createTemplateCard(template) {
        const card = document.createElement("div");
        card.className = "template-card";

        card.innerHTML = `
                <div class="template-preview">
                    <i class="fas ${template.icon}"></i>
                    ${
                      template.badge
                        ? `<div class="template-badge ${template.badge}">${template.badge}</div>`
                        : ""
                    }
                </div>
                <div class="template-info">
                    <div class="template-name">${template.name}</div>
                    <div class="template-description">${
                      template.description
                    }</div>
                    <div class="template-tags">
                        ${template.tags
                          .map(
                            (tag) => `<span class="template-tag">${tag}</span>`
                          )
                          .join("")}
                    </div>
                    <div class="template-actions">
                        <button type="button" class="template-btn" onclick="applyTemplate('${
                          template.id
                        }')">
                            <i class="fas fa-check"></i> Use Template
                        </button>
                        <button type="button" class="template-btn template-btn-secondary" onclick="previewTemplate('${
                          template.id
                        }')">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                </div>
            `;

        return card;
      }

      function applyTemplate(templateId) {
        const template = templateLibrary.find((t) => t.id === templateId);
        if (!template) return;

        // Clear current scene (except camera, lights, etc)
        clearScene();

        // Show loading
        showLoadingBar();
        updateLoadingProgress(0);

        // Apply template setup
        setTimeout(() => {
          updateLoadingProgress(50);
          if (template.setup) {
            template.setup();
          }

          updateLoadingProgress(100);
          setTimeout(() => {
            hideLoadingBar();
            hideTemplateLibrary();

            // Show success message
            console.log(`Template "${template.name}" applied successfully!`);
          }, 300);
        }, 500);
      }

      function previewTemplate(templateId) {
        // Future: Show preview/details modal
        console.log("Preview template:", templateId);
      }

      function clearScene() {
        // Remove all user-created objects
        const objectsToRemove = [];
        scene.traverse((object) => {
          if (object.userData && object.userData.isUserObject) {
            objectsToRemove.push(object);
          }
        });

        objectsToRemove.forEach((obj) => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach((mat) => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });

        sceneObjects = [];
        selectedObject = null;
      }

      // Ctrl+N shortcut for new project
      document.addEventListener("keydown", function (e) {
        if (e.ctrlKey && e.key === "n") {
          e.preventDefault();
          showTemplateLibrary();
        }
      });

      // ============================================
      // START
      // ============================================
      init();
      initTooltips();
      initTouchGestures();
      loadPreferences();

      // Initialize performance optimizations after scene is ready
      setTimeout(() => {
        initPerformanceOptimizations();
      }, 100);

      // ============================================
      // GAME BUILDER SYSTEM
      // ============================================

      let currentGameTemplate = null;
      let activeBlueprints = [];
      let availableBlueprints = [];

      // Blueprint definitions for each game type
      const gameBlueprintLibrary = {
        fps: {
          name: 'First-Person Shooter',
          starter: ['movement', 'camera', 'shooting'],
          available: ['enemies', 'health', 'weapons', 'crosshair', 'ammo', 'powerups']
        },
        platformer: {
          name: 'Platformer',
          starter: ['movement', 'jump', 'gravity'],
          available: ['collectibles', 'score', 'double-jump', 'enemies', 'hazards', 'checkpoints']
        },
        adventure: {
          name: 'Adventure/Exploration',
          starter: ['movement', 'camera', 'interaction'],
          available: ['inventory', 'dialogue', 'quests', 'npcs', 'pickups', 'map']
        },
        racing: {
          name: 'Racing Game',
          starter: ['vehicle', 'physics', 'steering'],
          available: ['checkpoints', 'timer', 'boost-pads', 'ai-racers', 'laps', 'minimap']
        },
        puzzle: {
          name: 'Puzzle Game',
          starter: ['grid-movement', 'object-placement'],
          available: ['push-pull', 'switches', 'win-condition', 'undo', 'hints', 'levels']
        },
        custom: {
          name: 'Custom Game',
          starter: [],
          available: ['movement', 'camera', 'physics', 'collision', 'input', 'audio']
        }
      };

      // Full blueprint registry with descriptions and implementations
      const blueprintRegistry = {
        // FPS Blueprints
        movement: {
          name: 'Player Movement',
          description: 'WASD controls for player movement',
          category: 'core',
          implementation: function() {
            console.log('âœ“ Movement system activated');
            showNotification('Player Movement enabled!');
          }
        },
        camera: {
          name: 'FPS Camera',
          description: 'First-person camera controls',
          category: 'core',
          implementation: function() {
            console.log('âœ“ FPS Camera activated');
            showNotification('FPS Camera enabled!');
          }
        },
        shooting: {
          name: 'Shooting System',
          description: 'Click to shoot projectiles',
          category: 'gameplay',
          implementation: function() {
            console.log('âœ“ Shooting system activated');
            showNotification('Shooting System enabled!');
          }
        },
        enemies: {
          name: 'Enemy AI',
          description: 'Spawn enemies that chase the player',
          category: 'gameplay',
          implementation: function() {
            // Create 3 enemy cubes
            for (let i = 0; i < 3; i++) {
              const enemy = createAsset('box');
              if (enemy) {
                enemy.position.set(
                  Math.random() * 20 - 10,
                  1,
                  Math.random() * 20 - 10
                );
                enemy.material.color.setHex(0xff0000);
                enemy.name = `Enemy ${i + 1}`;
                enemy.userData.isEnemy = true;
              }
            }
            console.log('âœ“ Enemies spawned');
            showNotification('3 Enemies added to scene!');
          }
        },
        health: {
          name: 'Health System',
          description: 'Player health with damage and healing',
          category: 'gameplay',
          implementation: function() {
            console.log('âœ“ Health system activated');
            showNotification('Health System enabled!');
          }
        },
        weapons: {
          name: 'Weapon System',
          description: 'Multiple weapons with different stats',
          category: 'gameplay',
          implementation: function() {
            console.log('âœ“ Weapon system activated');
            showNotification('Weapon System enabled!');
          }
        },
        crosshair: {
          name: 'Crosshair UI',
          description: 'Aiming crosshair overlay',
          category: 'ui',
          implementation: function() {
            console.log('âœ“ Crosshair activated');
            showNotification('Crosshair enabled!');
          }
        },

        // Platformer Blueprints
        jump: {
          name: 'Jump Mechanic',
          description: 'Press Space to jump',
          category: 'core',
          implementation: function() {
            console.log('âœ“ Jump mechanic activated');
            showNotification('Jump enabled!');
          }
        },
        gravity: {
          name: 'Gravity Physics',
          description: 'Realistic gravity and falling',
          category: 'core',
          implementation: function() {
            console.log('âœ“ Gravity activated');
            showNotification('Gravity Physics enabled!');
          }
        },
        collectibles: {
          name: 'Collectible Coins',
          description: 'Coins that rotate and can be collected',
          category: 'gameplay',
          implementation: function() {
            // Create 5 rotating golden coins
            for (let i = 0; i < 5; i++) {
              const coin = createAsset('cylinder');
              if (coin) {
                coin.position.set(i * 3 - 6, 2, 0);
                coin.scale.set(0.5, 0.1, 0.5);
                coin.rotation.x = Math.PI / 2;
                coin.material.color.setHex(0xffdd00);
                coin.material.emissive.setHex(0xffdd00);
                coin.material.emissiveIntensity = 0.5;
                coin.name = `Coin ${i + 1}`;
                coin.userData.isCollectible = true;
                coin.userData.animate = function(time) {
                  this.rotation.z = time;
                };
              }
            }
            console.log('âœ“ Collectible coins created');
            showNotification('5 Golden Coins added to scene!');
          }
        },
        score: {
          name: 'Score System',
          description: 'Track and display player score',
          category: 'ui',
          implementation: function() {
            console.log('âœ“ Score system activated');
            showNotification('Score System enabled!');
          }
        },
        'double-jump': {
          name: 'Double Jump',
          description: 'Jump again while in the air',
          category: 'gameplay',
          implementation: function() {
            console.log('âœ“ Double jump activated');
            showNotification('Double Jump enabled!');
          }
        },

        // Shared Blueprints
        interaction: {
          name: 'Interaction System',
          description: 'Press E to interact with objects',
          category: 'core',
          implementation: function() {
            console.log('âœ“ Interaction system activated');
            showNotification('Interaction System enabled!');
          }
        },
        inventory: {
          name: 'Inventory',
          description: 'Collect and manage items',
          category: 'gameplay',
          implementation: function() {
            console.log('âœ“ Inventory activated');
            showNotification('Inventory System enabled!');
          }
        },
        physics: {
          name: 'Physics Engine',
          description: 'Realistic physics simulation',
          category: 'core',
          implementation: function() {
            console.log('âœ“ Physics engine activated');
            showNotification('Physics Engine enabled!');
          }
        }
      };

      function selectGameTemplate(templateId) {
        currentGameTemplate = templateId;
        const template = gameBlueprintLibrary[templateId];

        // Update button states
        document.querySelectorAll('.game-template-btn').forEach(btn => {
          btn.classList.remove('selected');
        });
        event.target.closest('.game-template-btn').classList.add('selected');

        // Initialize blueprints
        activeBlueprints = [...template.starter];
        availableBlueprints = [...template.available];

        // Show blueprints section
        document.getElementById('game-template-selector').style.display = 'none';
        document.getElementById('active-blueprints-section').style.display = 'block';

        // Render blueprints
        renderActiveBlueprints();
        renderSmartSuggestions();
        renderAvailableBlueprints();

        showNotification(`${template.name} template selected!`);
      }

      function renderActiveBlueprints() {
        const container = document.getElementById('active-blueprints-list');
        container.innerHTML = '';

        activeBlueprints.forEach(blueprintId => {
          const blueprint = blueprintRegistry[blueprintId];
          if (!blueprint) return;

          const card = createBlueprintCard(blueprint, blueprintId, 'active');
          container.appendChild(card);
        });
      }

      function renderSmartSuggestions() {
        const container = document.getElementById('smart-suggestions-list');
        container.innerHTML = '';

        // Smart suggestion logic based on active blueprints
        const suggestions = getSmartSuggestions();

        suggestions.forEach(blueprintId => {
          const blueprint = blueprintRegistry[blueprintId];
          if (!blueprint) return;

          const card = createBlueprintCard(blueprint, blueprintId, 'suggestion');
          container.appendChild(card);
        });
      }

      function renderAvailableBlueprints() {
        const container = document.getElementById('inactive-blueprints-list');
        container.innerHTML = '';

        availableBlueprints.forEach(blueprintId => {
          if (activeBlueprints.includes(blueprintId)) return;

          const blueprint = blueprintRegistry[blueprintId];
          if (!blueprint) return;

          const card = createBlueprintCard(blueprint, blueprintId, 'available');
          container.appendChild(card);
        });
      }

      function getSmartSuggestions() {
        const suggestions = [];

        // Context-aware suggestions
        if (activeBlueprints.includes('movement') && !activeBlueprints.includes('enemies')) {
          if (availableBlueprints.includes('enemies')) suggestions.push('enemies');
        }

        if (activeBlueprints.includes('shooting') && !activeBlueprints.includes('crosshair')) {
          if (availableBlueprints.includes('crosshair')) suggestions.push('crosshair');
        }

        if (activeBlueprints.includes('jump') && !activeBlueprints.includes('collectibles')) {
          if (availableBlueprints.includes('collectibles')) suggestions.push('collectibles');
        }

        if (activeBlueprints.includes('collectibles') && !activeBlueprints.includes('score')) {
          if (availableBlueprints.includes('score')) suggestions.push('score');
        }

        return suggestions.slice(0, 3); // Show top 3 suggestions
      }

      function createBlueprintCard(blueprint, blueprintId, type) {
        const card = document.createElement('div');
        card.className = `blueprint-card ${type}`;

        const isActive = type === 'active';
        const isSuggestion = type === 'suggestion';

        card.innerHTML = `
          <div class="blueprint-card-header">
            <div class="blueprint-card-title">${blueprint.name}</div>
            ${isActive ? '<div class="blueprint-card-badge active">Active</div>' : ''}
            ${isSuggestion ? '<div class="blueprint-card-badge suggestion">Suggested</div>' : ''}
          </div>
          <div class="blueprint-card-description">${blueprint.description}</div>
          <div class="blueprint-card-actions">
            ${isActive ?
              `<button type="button" class="blueprint-card-btn" onclick="editBlueprint('${blueprintId}')">
                <i class="fas fa-edit"></i> Edit
              </button>
              <button type="button" class="blueprint-card-btn danger" onclick="deactivateBlueprint('${blueprintId}')">
                <i class="fas fa-times"></i> Remove
              </button>` :
              `<button type="button" class="blueprint-card-btn primary" onclick="activateBlueprint('${blueprintId}')">
                <i class="fas fa-plus"></i> ${isSuggestion ? 'Add (Suggested)' : 'Activate'}
              </button>`
            }
          </div>
        `;

        return card;
      }

      function activateBlueprint(blueprintId) {
        if (!activeBlueprints.includes(blueprintId)) {
          activeBlueprints.push(blueprintId);

          // Execute implementation
          const blueprint = blueprintRegistry[blueprintId];
          if (blueprint && blueprint.implementation) {
            blueprint.implementation();
          }

          // Create blueprint nodes for this feature
          createBlueprintNodesForFeature(blueprintId);

          // Re-render all sections
          renderActiveBlueprints();
          renderSmartSuggestions();
          renderAvailableBlueprints();
        }
      }

      // Create visual blueprint nodes for a game feature
      function createBlueprintNodesForFeature(blueprintId) {
        // Ensure Game Controller exists
        if (!window.gameControllerObject) {
          createGameController();
        }

        const obj = window.gameControllerObject;
        if (!obj || !obj.userData.blueprint) return;

        // Blueprint node templates for each feature
        const blueprintTemplates = {
          movement: [
            { name: 'On Start', x: 50, y: 50 },
            { name: 'Branch', x: 300, y: 50, params: { condition: 'Is Player' } },
            { name: 'Move Object', x: 550, y: 30, params: { x: 0, y: 0, z: 1 } }
          ],
          collectibles: [
            { name: 'On Trigger Enter', x: 50, y: 150 },
            { name: 'Branch', x: 300, y: 150, params: { condition: 'Has Tag: Collectible' } },
            { name: 'Destroy Object', x: 550, y: 130 },
            { name: 'Log Message', x: 550, y: 190, params: { message: 'Collected!' } }
          ],
          enemies: [
            { name: 'On Start', x: 50, y: 280 },
            { name: 'Log Message', x: 300, y: 280, params: { message: 'Enemy spawned!' } }
          ],
          jump: [
            { name: 'On Click', x: 50, y: 400 },
            { name: 'Move Object', x: 300, y: 400, params: { x: 0, y: 2, z: 0 } }
          ],
          shooting: [
            { name: 'On Click', x: 50, y: 500 },
            { name: 'Log Message', x: 300, y: 500, params: { message: 'Pew pew!' } }
          ]
        };

        const template = blueprintTemplates[blueprintId];
        if (!template) return;

        // Add nodes
        template.forEach(nodeTemplate => {
          const nodeDefinition = blueprintNodeRegistry[nodeTemplate.name];
          if (!nodeDefinition) return;

          const nodeId = 'node_' + (blueprintNodeId++);
          const newNode = {
            id: nodeId,
            name: nodeTemplate.name,
            type: nodeDefinition.type,
            icon: nodeDefinition.icon,
            position: { x: nodeTemplate.x, y: nodeTemplate.y },
            inputs: nodeDefinition.inputs || [],
            outputs: nodeDefinition.outputs || [],
            params: {}
          };

          // Initialize parameters
          if (nodeDefinition.params) {
            nodeDefinition.params.forEach(param => {
              newNode.params[param.name] = nodeTemplate.params && nodeTemplate.params[param.name] !== undefined
                ? nodeTemplate.params[param.name]
                : param.default;
            });
          }

          obj.userData.blueprint.nodes.push(newNode);
        });

        // Auto-connect nodes in sequence
        if (template.length > 1) {
          for (let i = 0; i < template.length - 1; i++) {
            const fromNode = obj.userData.blueprint.nodes[obj.userData.blueprint.nodes.length - template.length + i];
            const toNode = obj.userData.blueprint.nodes[obj.userData.blueprint.nodes.length - template.length + i + 1];

            if (fromNode.outputs.length > 0 && toNode.inputs.length > 0) {
              obj.userData.blueprint.connections.push({
                from: fromNode.id,
                fromPin: fromNode.outputs[0].name,
                to: toNode.id,
                toPin: toNode.inputs[0].name,
                type: fromNode.outputs[0].type
              });
            }
          }
        }

        // Re-render blueprint if selected
        if (selectedObject === obj) {
          renderBlueprintCanvas();
        }
      }

      // Create a Game Controller object to hold all game blueprints
      function createGameController() {
        const controller = createAsset('sphere');
        if (!controller) return;

        controller.scale.set(0.5, 0.5, 0.5);
        controller.position.set(0, 5, 0);
        controller.material.color.setHex(0x00ffaa);
        controller.material.emissive.setHex(0x00ffaa);
        controller.material.emissiveIntensity = 0.5;
        controller.name = 'ðŸŽ® Game Controller';

        // Enable blueprint
        controller.userData.blueprint = {
          enabled: true,
          nodes: [],
          connections: []
        };

        window.gameControllerObject = controller;
        selectObject(controller);

        showNotification('Game Controller created! Click Blueprint tab to see logic.');
      }

      function deactivateBlueprint(blueprintId) {
        const index = activeBlueprints.indexOf(blueprintId);
        if (index > -1) {
          activeBlueprints.splice(index, 1);

          // Re-render all sections
          renderActiveBlueprints();
          renderSmartSuggestions();
          renderAvailableBlueprints();

          showNotification(`${blueprintRegistry[blueprintId].name} deactivated`);
        }
      }

      function editBlueprint(blueprintId) {
        showNotification(`Editing ${blueprintRegistry[blueprintId].name}...`);
        // Future: Open blueprint editor
      }

      // ============================================
      // GAME HUB SUB-TAB SYSTEM
      // ============================================

      function switchGameSubTab(subtab) {
        // Update tab buttons
        document.querySelectorAll('.game-subtab').forEach(btn => {
          btn.classList.remove('active');
        });
        event.target.closest('.game-subtab').classList.add('active');

        // Update panels
        document.querySelectorAll('.game-subpanel').forEach(panel => {
          panel.classList.remove('active');
        });
        document.getElementById('game-subpanel-' + subtab).classList.add('active');

        // If switching to blueprints tab, render the game blueprints
        if (subtab === 'blueprints') {
          renderGameBlueprints();
          updateGameControllerStatus();
        }
      }

      function renderGameBlueprints() {
        const obj = window.gameControllerObject;
        if (!obj || !obj.userData.blueprint) {
          // Show empty state
          const canvas = document.querySelector('#game-blueprint-nodes > div');
          if (canvas) {
            canvas.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;"><i class="fas fa-project-diagram" style="font-size: 48px; margin-bottom: 15px; display: block;"></i>No blueprints yet.<br>Add a feature from the Features tab to get started.</div>';
          }
          return;
        }

        const blueprint = obj.userData.blueprint;
        const canvas = document.querySelector('#game-blueprint-nodes > div');
        const connectionsGroup = document.getElementById('game-blueprint-connections');

        if (!canvas || !connectionsGroup) return;

        // Clear canvas
        canvas.innerHTML = '';
        connectionsGroup.innerHTML = '';

        // Render nodes
        blueprint.nodes.forEach(node => {
          const nodeEl = createNodeElement(node);
          canvas.appendChild(nodeEl);
        });

        // Render connections
        blueprint.connections.forEach(conn => {
          const line = createConnectionLine(conn);
          if (line) connectionsGroup.appendChild(line);
        });
      }

      function updateGameControllerStatus() {
        const statusEl = document.getElementById('game-controller-status');
        if (!statusEl) return;

        const obj = window.gameControllerObject;
        if (!obj || !obj.userData.blueprint) {
          statusEl.innerHTML = '<i class="fas fa-info-circle" style="color: #ffaa00;"></i> No game controller. Add a feature to create one.';
          statusEl.style.color = '#888';
        } else {
          const nodeCount = obj.userData.blueprint.nodes.length;
          const connCount = obj.userData.blueprint.connections.length;
          statusEl.innerHTML = `<i class="fas fa-check-circle" style="color: #00ff88;"></i> Active - ${nodeCount} nodes, ${connCount} connections`;
          statusEl.style.color = '#00ff88';
        }
      }

      function addGameBlueprintNode(nodeName) {
        const obj = window.gameControllerObject;
        if (!obj || !obj.userData.blueprint) {
          showNotification('Please add a game feature first to create the Game Controller');
          return;
        }

        const nodeDefinition = blueprintNodeRegistry[nodeName];
        if (!nodeDefinition) return;

        const nodeId = 'node_' + (blueprintNodeId++);
        const newNode = {
          id: nodeId,
          name: nodeName,
          type: nodeDefinition.type,
          icon: nodeDefinition.icon,
          position: { x: 100 + Math.random() * 300, y: 100 + Math.random() * 200 },
          inputs: nodeDefinition.inputs || [],
          outputs: nodeDefinition.outputs || [],
          params: {}
        };

        // Initialize parameters
        if (nodeDefinition.params) {
          nodeDefinition.params.forEach(param => {
            newNode.params[param.name] = param.default;
          });
        }

        obj.userData.blueprint.nodes.push(newNode);
        renderGameBlueprints();
        showNotification(`Added ${nodeName} node`);
      }

      function testGameBlueprints() {
        const obj = window.gameControllerObject;
        if (!obj || !obj.userData.blueprint) {
          showNotification('No game controller to test');
          return;
        }

        console.log('ðŸŽ® Testing Game Blueprints');
        console.log('Nodes:', obj.userData.blueprint.nodes);
        console.log('Connections:', obj.userData.blueprint.connections);

        // Find all "On Start" nodes and execute them
        const startNodes = obj.userData.blueprint.nodes.filter(n => n.name === 'On Start');
        startNodes.forEach(node => {
          console.log('â–¶ Executing:', node.name);
          executeBlueprint(obj, 'On Start', {});
        });

        showNotification('Blueprints tested! Check console for details.');
      }

    </script>

    <!-- Hamburger Menu Button -->
    <div class="hamburger-btn" id="hamburger-btn" onclick="toggleHamburger()">
      <span></span>
      <span></span>
      <span></span>
    </div>

    <!-- Panel Overlay (for mobile) -->
    <div
      class="panel-overlay"
      id="panel-overlay"
      onclick="closeMobilePanels()"
    ></div>

    <!-- Mobile Bottom Navigation -->
    <div class="mobile-bottom-nav" id="mobile-bottom-nav">
      <div class="mobile-nav-items">
        <div
          class="mobile-nav-item active"
          onclick="toggleMobilePanel('assets')"
          data-tooltip="Assets & Objects"
        >
          <i class="fas fa-box"></i>
          <span>Assets</span>
        </div>
        <div
          class="mobile-nav-item"
          onclick="toggleMobilePanel('tools')"
          data-tooltip="Transform Tools"
        >
          <i class="fas fa-tools"></i>
          <span>Tools</span>
        </div>
        <div
          class="mobile-nav-item"
          onclick="togglePlayMode()"
          data-tooltip="Play/Test Mode"
        >
          <i class="fas fa-play"></i>
          <span>Play</span>
        </div>
        <div
          class="mobile-nav-item"
          onclick="toggleMobilePanel('properties')"
          data-tooltip="Properties"
        >
          <i class="fas fa-sliders-h"></i>
          <span>Props</span>
        </div>
        <div
          class="mobile-nav-item"
          onclick="toggleMobilePanel('menu')"
          data-tooltip="Menu"
        >
          <i class="fas fa-bars"></i>
          <span>Menu</span>
        </div>
      </div>
    </div>

    <!-- Tooltip Container -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Keyboard Shortcuts Overlay -->
    <div class="shortcuts-overlay" id="shortcuts-overlay">
      <div class="shortcuts-panel">
        <div class="shortcuts-header">
          <div class="shortcuts-title">
            <i class="fas fa-keyboard"></i> Keyboard Shortcuts
          </div>
          <div class="shortcuts-close" onclick="toggleShortcuts()">
            <i class="fas fa-times"></i>
          </div>
        </div>
        <div class="shortcuts-grid">
          <div class="shortcuts-category">
            <div class="shortcuts-category-title">General</div>
            <div class="shortcut-item">
              <div class="shortcut-action">Show Shortcuts</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">F1</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Save Scene</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Ctrl</span>
                <span class="shortcut-key">S</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Undo</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Ctrl</span>
                <span class="shortcut-key">Z</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Redo</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Ctrl</span>
                <span class="shortcut-key">Y</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Toggle Grid</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">G</span>
              </div>
            </div>
          </div>

          <div class="shortcuts-category">
            <div class="shortcuts-category-title">Transform</div>
            <div class="shortcut-item">
              <div class="shortcut-action">Move Mode</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">W</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Rotate Mode</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">E</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Scale Mode</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">R</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Delete Object</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Del</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Duplicate</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Ctrl</span>
                <span class="shortcut-key">D</span>
              </div>
            </div>
          </div>

          <div class="shortcuts-category">
            <div class="shortcuts-category-title">View</div>
            <div class="shortcut-item">
              <div class="shortcut-action">Focus Object</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">F</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Frame All</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">A</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Search Assets</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Ctrl</span>
                <span class="shortcut-key">F</span>
              </div>
            </div>
          </div>

          <div class="shortcuts-category">
            <div class="shortcuts-category-title">Camera</div>
            <div class="shortcut-item">
              <div class="shortcut-action">Orbit View</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Left Click + Drag</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Pan View</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Middle Click + Drag</span>
              </div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-action">Zoom</div>
              <div class="shortcut-keys">
                <span class="shortcut-key">Scroll Wheel</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Settings Button -->
    <button
      type="button"
      class="settings-btn"
      onclick="toggleShortcuts()"
      data-tooltip="Keyboard shortcuts (F1)"
    >
      <i class="fas fa-keyboard"></i>
    </button>

    <!-- Performance Monitor -->
    <div
      class="perf-toggle-btn"
      onclick="togglePerformanceMonitor()"
      data-tooltip="Toggle performance monitor (P)"
    >
      <i class="fas fa-tachometer-alt"></i>
    </div>

    <div class="performance-monitor" id="performance-monitor">
      <div class="perf-stat">
        <span class="perf-label">FPS:</span>
        <span class="perf-value good" id="perf-fps">60</span>
      </div>
      <div class="perf-stat">
        <span class="perf-label">Frame Time:</span>
        <span class="perf-value good" id="perf-frame-time">16ms</span>
      </div>
      <div class="perf-divider"></div>
      <div class="perf-stat">
        <span class="perf-label">Draw Calls:</span>
        <span class="perf-value" id="perf-draw-calls">0</span>
      </div>
      <div class="perf-stat">
        <span class="perf-label">Triangles:</span>
        <span class="perf-value" id="perf-triangles">0</span>
      </div>
      <div class="perf-stat">
        <span class="perf-label">Geometries:</span>
        <span class="perf-value" id="perf-geometries">0</span>
      </div>
      <div class="perf-stat">
        <span class="perf-label">Textures:</span>
        <span class="perf-value" id="perf-textures">0</span>
      </div>
      <div class="perf-divider"></div>
      <div class="perf-stat">
        <span class="perf-label">Memory:</span>
        <span class="perf-value" id="perf-memory">0 MB</span>
      </div>
      <div class="perf-stat">
        <span class="perf-label">Quality:</span>
        <span class="perf-value good" id="perf-quality">High</span>
      </div>
    </div>

    <!-- Loading Progress Bar -->
    <div class="loading-bar" id="loading-bar">
      <div class="loading-progress" id="loading-progress"></div>
    </div>

    <!-- Quality Indicator -->
    <div class="quality-indicator" id="quality-indicator">
      <div class="quality-dot" id="quality-dot"></div>
      <span id="quality-text">High Quality</span>
    </div>

    <!-- Template Library Modal -->
    <div class="template-modal" id="template-modal">
      <div class="template-modal-content">
        <div class="template-modal-header">
          <div class="template-modal-title">
            <i class="fas fa-th-large"></i>
            Template Library
          </div>
          <div class="template-modal-close" onclick="hideTemplateLibrary()">
            <i class="fas fa-times"></i>
          </div>
        </div>

        <div class="template-filters">
          <div
            class="template-filter-btn active"
            onclick="filterTemplates('all')"
            data-category="all"
          >
            <i class="fas fa-th"></i> All Templates
          </div>
          <div
            class="template-filter-btn"
            onclick="filterTemplates('game')"
            data-category="game"
          >
            <i class="fas fa-gamepad"></i> Games
          </div>
          <div
            class="template-filter-btn"
            onclick="filterTemplates('visualization')"
            data-category="visualization"
          >
            <i class="fas fa-chart-bar"></i> Visualization
          </div>
          <div
            class="template-filter-btn"
            onclick="filterTemplates('website')"
            data-category="website"
          >
            <i class="fas fa-globe"></i> Website
          </div>
          <div
            class="template-filter-btn"
            onclick="filterTemplates('environment')"
            data-category="environment"
          >
            <i class="fas fa-tree"></i> Environment
          </div>
          <div
            class="template-filter-btn"
            onclick="filterTemplates('specialty')"
            data-category="specialty"
          >
            <i class="fas fa-magic"></i> Specialty
          </div>
        </div>

        <div class="template-grid-container" id="template-grid-container">
          <!-- Templates will be dynamically generated here -->
        </div>
      </div>
    </div>
  </body>
</html>
