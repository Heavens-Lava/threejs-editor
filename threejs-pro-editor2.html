<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Professional World Builder</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Top Toolbar */
        .top-toolbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
            border-bottom: 1px solid #404040;
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 20px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-divider {
            width: 1px;
            height: 30px;
            background: #404040;
        }

        .toolbar-btn {
            padding: 8px 16px;
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: #454545;
            border-color: #606060;
        }

        .toolbar-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .toolbar-btn i {
            font-size: 14px;
        }

        .toolbar-title {
            font-size: 16px;
            font-weight: 600;
            color: #fbbf24;
            margin-right: 10px;
        }

        /* Left Sidebar - Asset Library */
        .left-sidebar {
            position: absolute;
            left: 0;
            top: 50px;
            bottom: 0;
            width: 280px;
            background: rgba(30, 30, 30, 0.98);
            border-right: 1px solid #404040;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }

        .sidebar-tabs {
            display: flex;
            background: #252525;
            border-bottom: 1px solid #404040;
        }

        .sidebar-tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: #999;
        }

        .sidebar-tab:hover {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .sidebar-tab.active {
            border-bottom-color: #0066cc;
            color: #0066cc;
            background: #2a2a2a;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .sidebar-panel {
            display: none;
        }

        .sidebar-panel.active {
            display: block;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: #888;
            margin: 15px 0 10px 0;
            letter-spacing: 0.5px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .asset-item {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .asset-item:hover {
            background: #333;
            border-color: #0066cc;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
        }

        .asset-item i {
            font-size: 24px;
            color: #0066cc;
            margin-bottom: 8px;
            display: block;
        }

        .asset-item-name {
            font-size: 11px;
            color: #ccc;
            font-weight: 500;
        }

        /* Right Sidebar - Properties & Tools */
        .right-sidebar {
            position: absolute;
            right: 0;
            top: 50px;
            bottom: 0;
            width: 320px;
            background: rgba(30, 30, 30, 0.98);
            border-left: 1px solid #404040;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
        }

        .panel-header {
            padding: 12px 15px;
            background: #252525;
            border-bottom: 1px solid #404040;
            font-size: 13px;
            font-weight: 600;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-header i {
            color: #0066cc;
            font-size: 14px;
        }

        .property-group {
            padding: 15px;
            border-bottom: 1px solid #2a2a2a;
        }

        .property-label {
            font-size: 11px;
            color: #999;
            margin-bottom: 6px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .property-input {
            width: 100%;
            padding: 8px 10px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
            transition: border-color 0.2s;
        }

        .property-input:focus {
            outline: none;
            border-color: #0066cc;
        }

        .vector-inputs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .vector-input {
            padding: 8px 6px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            text-align: center;
        }

        .vector-input:focus {
            outline: none;
            border-color: #0066cc;
        }

        .vector-labels {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 4px;
        }

        .vector-label {
            font-size: 10px;
            color: #666;
            text-align: center;
            font-weight: 600;
        }

        .btn {
            width: 100%;
            padding: 10px;
            background: #0066cc;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .btn:hover {
            background: #0052a3;
        }

        .btn.btn-danger {
            background: #dc2626;
        }

        .btn.btn-danger:hover {
            background: #b91c1c;
        }

        .btn.btn-secondary {
            background: #3a3a3a;
            border: 1px solid #505050;
        }

        .btn.btn-secondary:hover {
            background: #454545;
        }

        .transform-mode-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #999;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .mode-btn:hover {
            background: #333;
            border-color: #0066cc;
            color: #e0e0e0;
        }

        .mode-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .hierarchy-item {
            padding: 8px 10px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .hierarchy-item:hover {
            background: #333;
            border-color: #505050;
        }

        .hierarchy-item.selected {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .hierarchy-item i {
            font-size: 12px;
            color: #0066cc;
            width: 16px;
        }

        .hierarchy-item.selected i {
            color: white;
        }

        .color-picker-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-preview {
            width: 40px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid #404040;
            cursor: pointer;
        }

        input[type="color"] {
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }

        .no-selection {
            padding: 20px;
            text-align: center;
            color: #666;
            font-size: 13px;
        }

        /* Collision Items */
        .collision-item {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .collision-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .collision-toggle {
            padding: 4px 8px;
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 3px;
            color: #999;
            font-size: 11px;
            cursor: pointer;
        }

        .collision-toggle.enabled {
            background: #16a34a;
            border-color: #16a34a;
            color: white;
        }

        /* File input styling */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px;
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .file-input-label:hover {
            background: #454545;
            border-color: #0066cc;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        /* Scene Settings */
        .scene-setting {
            margin-bottom: 15px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-wrapper label {
            font-size: 12px;
            color: #ccc;
            cursor: pointer;
        }

        /* Play Mode Overlay */
        .play-mode-overlay {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 102, 204, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .play-mode-overlay.active {
            display: block;
        }

        /* Spawn Point Visual */
        .spawn-point-info {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: #999;
        }

        /* ============================================ */
        /* MOBILE-FIRST RESPONSIVE SYSTEM */
        /* ============================================ */

        /* Mobile Bottom Navigation Bar */
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
            border-top: 1px solid #404040;
            z-index: 2000;
            padding: 0;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
        }

        .mobile-nav-items {
            display: flex;
            height: 100%;
            justify-content: space-around;
            align-items: center;
        }

        .mobile-nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #999;
            cursor: pointer;
            transition: all 0.2s;
            padding: 8px;
            min-height: 44px;
            min-width: 44px;
        }

        .mobile-nav-item:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .mobile-nav-item.active {
            color: #0066cc;
        }

        .mobile-nav-item i {
            font-size: 20px;
        }

        .mobile-nav-item span {
            font-size: 10px;
            font-weight: 500;
        }

        /* Hamburger Menu */
        .hamburger-btn {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 44px;
            height: 44px;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 6px;
            cursor: pointer;
            z-index: 1500;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .hamburger-btn span {
            width: 20px;
            height: 2px;
            background: #e0e0e0;
            transition: all 0.3s;
        }

        .hamburger-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Panel Overlay for Mobile */
        .panel-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 500;
        }

        .panel-overlay.active {
            display: block;
        }

        /* Tooltip System */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
            max-width: 250px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            border: 6px solid transparent;
        }

        .tooltip.top::before {
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: rgba(0, 0, 0, 0.95);
        }

        .tooltip.bottom::before {
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: rgba(0, 0, 0, 0.95);
        }

        .tooltip.left::before {
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            border-left-color: rgba(0, 0, 0, 0.95);
        }

        .tooltip.right::before {
            left: -12px;
            top: 50%;
            transform: translateY(-50%);
            border-right-color: rgba(0, 0, 0, 0.95);
        }

        /* Touch-optimized controls */
        .touch-optimized {
            min-height: 44px;
            min-width: 44px;
        }

        /* ============================================ */
        /* PHASE 1.3: UI ORGANIZATION & ENHANCEMENT */
        /* ============================================ */

        /* Search Bar */
        .search-container {
            padding: 12px 15px;
            border-bottom: 1px solid #404040;
            background: #252525;
        }

        .search-box {
            position: relative;
            width: 100%;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 36px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #0066cc;
            background: #2d2d2d;
        }

        .search-input::placeholder {
            color: #666;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            font-size: 14px;
            pointer-events: none;
        }

        .search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            cursor: pointer;
            padding: 4px;
            display: none;
            transition: color 0.2s;
        }

        .search-clear:hover {
            color: #e0e0e0;
        }

        .search-clear.show {
            display: block;
        }

        /* Quick Access Toolbar */
        .quick-access-bar {
            display: flex;
            gap: 4px;
            padding: 8px 15px;
            background: #252525;
            border-bottom: 1px solid #404040;
            flex-wrap: wrap;
        }

        .quick-access-btn {
            width: 36px;
            height: 36px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 16px;
        }

        .quick-access-btn:hover {
            background: #333;
            border-color: #0066cc;
            color: #0066cc;
        }

        .quick-access-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .quick-access-btn.favorite {
            color: #fbbf24;
        }

        /* Workspace Presets */
        .workspace-presets {
            display: flex;
            gap: 6px;
            padding: 10px 15px;
            background: #1f1f1f;
            border-bottom: 1px solid #404040;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .workspace-preset-btn {
            padding: 8px 14px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 6px;
            color: #999;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .workspace-preset-btn:hover {
            background: #333;
            border-color: #505050;
            color: #e0e0e0;
        }

        .workspace-preset-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .workspace-preset-btn i {
            font-size: 12px;
        }

        /* Favorites System */
        .favorite-star {
            position: absolute;
            top: 4px;
            right: 4px;
            color: #666;
            cursor: pointer;
            font-size: 12px;
            z-index: 10;
            transition: all 0.2s;
            padding: 4px;
        }

        .favorite-star:hover {
            color: #fbbf24;
            transform: scale(1.2);
        }

        .favorite-star.active {
            color: #fbbf24;
        }

        .asset-item {
            position: relative;
        }

        /* Recent Items */
        .recent-items-section {
            margin-bottom: 15px;
        }

        .recent-item {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 8px 10px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }

        .recent-item:hover {
            background: #333;
            border-color: #0066cc;
        }

        .recent-item i {
            color: #0066cc;
            font-size: 14px;
            width: 20px;
        }

        .recent-item-name {
            flex: 1;
            color: #ccc;
        }

        .recent-item-time {
            color: #666;
            font-size: 10px;
        }

        /* Keyboard Shortcut Overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

        .shortcuts-overlay.show {
            display: flex;
        }

        .shortcuts-panel {
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 12px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .shortcuts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .shortcuts-title {
            font-size: 24px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .shortcuts-close {
            width: 32px;
            height: 32px;
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 6px;
            color: #999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .shortcuts-close:hover {
            background: #454545;
            color: #e0e0e0;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
        }

        .shortcuts-category {
            background: #252525;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 16px;
        }

        .shortcuts-category-title {
            font-size: 14px;
            font-weight: 600;
            color: #0066cc;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .shortcut-item:last-child {
            border-bottom: none;
        }

        .shortcut-action {
            color: #ccc;
            font-size: 13px;
        }

        .shortcut-keys {
            display: flex;
            gap: 4px;
        }

        .shortcut-key {
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 600;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-width: 24px;
            text-align: center;
        }

        /* UI Mode Toggle */
        .ui-mode-toggle {
            display: flex;
            gap: 0;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 2px;
            margin: 10px 15px;
        }

        .ui-mode-btn {
            flex: 1;
            padding: 8px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #999;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .ui-mode-btn:hover {
            color: #e0e0e0;
        }

        .ui-mode-btn.active {
            background: #0066cc;
            color: white;
        }

        /* Advanced Mode Indicators */
        .advanced-only {
            display: none;
        }

        body.advanced-mode .advanced-only {
            display: block;
        }

        /* Settings Button */
        .settings-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: #0066cc;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.4);
            transition: all 0.2s;
            z-index: 1500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: #0052a3;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 102, 204, 0.6);
        }

        .settings-btn:active {
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .settings-btn {
                bottom: 70px;
                right: 15px;
                width: 44px;
                height: 44px;
                font-size: 18px;
            }
        }

        /* ============================================ */
        /* RESPONSIVE BREAKPOINTS */
        /* ============================================ */

        /* Mobile Portrait: 320px - 480px */
        @media (max-width: 480px) {
            .mobile-bottom-nav {
                display: block;
            }

            .hamburger-btn {
                display: flex;
            }

            .top-toolbar {
                padding: 0 50px;
                height: 50px;
            }

            .toolbar-title {
                font-size: 14px;
            }

            .toolbar-section {
                display: none;
            }

            .left-sidebar {
                left: -100%;
                width: 85%;
                max-width: 320px;
                transition: left 0.3s ease;
                z-index: 1000;
            }

            .left-sidebar.mobile-open {
                left: 0;
            }

            .right-sidebar {
                right: -100%;
                width: 85%;
                max-width: 320px;
                transition: right 0.3s ease;
                z-index: 1000;
            }

            .right-sidebar.mobile-open {
                right: 0;
            }

            .asset-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            .sidebar-tab {
                font-size: 10px;
                padding: 10px 4px;
            }

            .property-group {
                padding: 12px;
            }

            .vector-inputs,
            .vector-labels {
                gap: 4px;
            }

            /* Enlarge touch targets */
            .toolbar-btn,
            .btn,
            .mode-btn,
            .asset-item,
            .hierarchy-item {
                min-height: 44px;
                touch-action: manipulation;
            }

            .property-input,
            .vector-input {
                min-height: 44px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Mobile Landscape: 481px - 767px */
        @media (min-width: 481px) and (max-width: 767px) {
            .mobile-bottom-nav {
                display: block;
            }

            .hamburger-btn {
                display: flex;
            }

            .top-toolbar {
                padding: 0 50px;
            }

            .left-sidebar {
                width: 280px;
                left: -100%;
                transition: left 0.3s ease;
                z-index: 1000;
            }

            .left-sidebar.mobile-open {
                left: 0;
            }

            .right-sidebar {
                width: 300px;
                right: -100%;
                transition: right 0.3s ease;
                z-index: 1000;
            }

            .right-sidebar.mobile-open {
                right: 0;
            }

            .asset-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            /* Touch targets */
            .toolbar-btn,
            .btn,
            .mode-btn {
                min-height: 44px;
            }
        }

        /* Tablet Portrait: 768px - 1024px */
        @media (min-width: 768px) and (max-width: 1024px) {
            .left-sidebar {
                width: 260px;
            }

            .right-sidebar {
                width: 280px;
            }

            .asset-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .top-toolbar {
                padding: 0 15px;
            }

            .toolbar-section {
                gap: 6px;
            }

            .toolbar-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        /* Tablet Landscape: 1025px - 1366px */
        @media (min-width: 1025px) and (max-width: 1366px) {
            .left-sidebar {
                width: 280px;
            }

            .right-sidebar {
                width: 300px;
            }

            .asset-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Desktop: 1367px+ */
        @media (min-width: 1367px) {
            .left-sidebar {
                width: 320px;
            }

            .right-sidebar {
                width: 340px;
            }

            .asset-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }

        /* Landscape orientation adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .top-toolbar {
                height: 40px;
            }

            .mobile-bottom-nav {
                height: 50px;
            }

            .left-sidebar,
            .right-sidebar {
                top: 40px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* Sharper rendering for high-DPI displays */
            .toolbar-btn,
            .btn,
            .asset-item {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Dark mode support (system preference) */
        @media (prefers-color-scheme: light) {
            /* Future: Light theme support */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Workspace Presets Bar -->
    <div class="workspace-presets" id="workspace-presets">
        <div class="workspace-preset-btn active" onclick="setWorkspacePreset('general')" data-tooltip="General workspace - balanced layout for all tasks">
            <i class="fas fa-th-large"></i>
            <span>General</span>
        </div>
        <div class="workspace-preset-btn" onclick="setWorkspacePreset('modeling')" data-tooltip="Modeling workspace - optimized for creating 3D objects">
            <i class="fas fa-cube"></i>
            <span>Modeling</span>
        </div>
        <div class="workspace-preset-btn" onclick="setWorkspacePreset('lighting')" data-tooltip="Lighting workspace - focus on lights and materials">
            <i class="fas fa-lightbulb"></i>
            <span>Lighting</span>
        </div>
        <div class="workspace-preset-btn advanced-only" onclick="setWorkspacePreset('animation')" data-tooltip="Animation workspace - timeline and keyframe tools">
            <i class="fas fa-film"></i>
            <span>Animation</span>
        </div>
        <div class="workspace-preset-btn advanced-only" onclick="setWorkspacePreset('scripting')" data-tooltip="Scripting workspace - code editor and console">
            <i class="fas fa-code"></i>
            <span>Scripting</span>
        </div>
    </div>

    <!-- Top Toolbar -->
    <div class="top-toolbar">
        <div class="toolbar-title" data-tooltip="Three.js Professional World Builder">
            <i class="fas fa-cube"></i> World Builder
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-section">
            <button class="toolbar-btn" id="mode-toggle" data-tooltip="Switch between edit and play mode to test your scene">
                <i class="fas fa-gamepad"></i>
                <span id="mode-text">Play Mode</span>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-section">
            <button class="toolbar-btn" onclick="undo()" data-tooltip="Undo the last action (Ctrl+Z)">
                <i class="fas fa-undo"></i> Undo
            </button>
            <button class="toolbar-btn" onclick="redo()" data-tooltip="Redo the last undone action (Ctrl+Y)">
                <i class="fas fa-redo"></i> Redo
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-section">
            <button class="toolbar-btn" onclick="saveScene()" data-tooltip="Save your scene to a JSON file">
                <i class="fas fa-save"></i> Save
            </button>
            <button class="toolbar-btn" onclick="loadScene()" data-tooltip="Load a previously saved scene from JSON">
                <i class="fas fa-folder-open"></i> Load
            </button>
            <button class="toolbar-btn" onclick="exportCode()" data-tooltip="Export your scene as standalone HTML code">
                <i class="fas fa-code"></i> Export
            </button>
        </div>
    </div>

    <!-- Play Mode Overlay -->
    <div class="play-mode-overlay" id="play-mode-overlay">
        <i class="fas fa-gamepad"></i> PLAY MODE - Click to control | ESC to return to editor
    </div>

    <!-- Left Sidebar - Asset Library -->
    <div class="left-sidebar" id="left-sidebar">
        <div class="sidebar-tabs">
            <div class="sidebar-tab active" onclick="switchLeftTab('assets')">
                <i class="fas fa-box"></i><br>Assets
            </div>
            <div class="sidebar-tab" onclick="switchLeftTab('library')">
                <i class="fas fa-book"></i><br>Library
            </div>
            <div class="sidebar-tab" onclick="switchLeftTab('objects')">
                <i class="fas fa-layer-group"></i><br>Objects
            </div>
            <div class="sidebar-tab" onclick="switchLeftTab('collisions')">
                <i class="fas fa-shield-alt"></i><br>Collision
            </div>
        </div>

        <!-- Search Bar -->
        <div class="search-container">
            <div class="search-box">
                <i class="fas fa-search search-icon"></i>
                <input type="text" class="search-input" id="asset-search" placeholder="Search assets..." oninput="searchAssets(this.value)">
                <i class="fas fa-times search-clear" id="search-clear" onclick="clearSearch()"></i>
            </div>
        </div>

        <!-- UI Mode Toggle -->
        <div class="ui-mode-toggle">
            <button class="ui-mode-btn active" onclick="setUIMode('beginner')" data-tooltip="Beginner mode - simplified interface">
                <i class="fas fa-user"></i> Beginner
            </button>
            <button class="ui-mode-btn" onclick="setUIMode('advanced')" data-tooltip="Advanced mode - all features unlocked">
                <i class="fas fa-user-cog"></i> Advanced
            </button>
        </div>

        <div class="sidebar-content">
            <!-- Assets Panel -->
            <div class="sidebar-panel active" id="panel-assets">
                <div class="section-title">Primitives</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createAsset('box')" data-tooltip="Add a cube - perfect for building blocks, walls, and boxes">
                        <i class="fas fa-cube"></i>
                        <div class="asset-item-name">Cube</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('sphere')" data-tooltip="Add a sphere - great for balls, planets, and rounded objects">
                        <i class="fas fa-circle"></i>
                        <div class="asset-item-name">Sphere</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('cylinder')" data-tooltip="Add a cylinder - useful for columns, pipes, and containers">
                        <i class="fas fa-database"></i>
                        <div class="asset-item-name">Cylinder</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('plane')" data-tooltip="Add a flat plane - ideal for floors, walls, and flat surfaces">
                        <i class="fas fa-square"></i>
                        <div class="asset-item-name">Plane</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('cone')" data-tooltip="Add a cone - perfect for pyramids, arrows, and pointed objects">
                        <i class="fas fa-play"></i>
                        <div class="asset-item-name">Cone</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('torus')" data-tooltip="Add a torus (donut shape) - great for rings and decorative elements">
                        <i class="fas fa-circle-notch"></i>
                        <div class="asset-item-name">Torus</div>
                    </div>
                </div>

                <div class="section-title">Environment</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createAsset('wall')" data-tooltip="Create a wall - vertical barrier for rooms and boundaries">
                        <i class="fas fa-bars"></i>
                        <div class="asset-item-name">Wall</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('floor')" data-tooltip="Create a floor - large horizontal surface for walking">
                        <i class="fas fa-border-all"></i>
                        <div class="asset-item-name">Floor</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('stairs')" data-tooltip="Add stairs - for connecting different levels">
                        <i class="fas fa-stairs"></i>
                        <div class="asset-item-name">Stairs</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('door')" data-tooltip="Add a door - entrance or exit point">
                        <i class="fas fa-door-open"></i>
                        <div class="asset-item-name">Door</div>
                    </div>
                </div>

                <div class="section-title">Lights</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createAsset('pointLight')" data-tooltip="Point light - emits light in all directions from a single point">
                        <i class="fas fa-lightbulb"></i>
                        <div class="asset-item-name">Point Light</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('spotLight')" data-tooltip="Spot light - focused beam of light like a flashlight">
                        <i class="fas fa-circle-notch"></i>
                        <div class="asset-item-name">Spot Light</div>
                    </div>
                </div>

                <div class="section-title">Special</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createAsset('spawnPoint')" data-tooltip="Spawn point - where the player starts in play mode">
                        <i class="fas fa-user"></i>
                        <div class="asset-item-name">Spawn Point</div>
                    </div>
                    <div class="asset-item" onclick="createAsset('group')" data-tooltip="Empty group - organize multiple objects together">
                        <i class="fas fa-object-group"></i>
                        <div class="asset-item-name">Group</div>
                    </div>
                </div>

                <div class="section-title">3D Models</div>
                <div class="file-input-wrapper">
                    <input type="file" id="model-file-input" accept=".glb,.gltf" onchange="loadModel(event)">
                    <label for="model-file-input" class="file-input-label">
                        <i class="fas fa-upload"></i> Load GLB/GLTF
                    </label>
                </div>
            </div>

            <!-- Library Panel -->
            <div class="sidebar-panel" id="panel-library">
                <div class="section-title">Default Assets</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createDefaultAsset('grass')">
                        <i class="fas fa-seedling"></i>
                        <div class="asset-item-name">Grass Plane</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('pedestal')">
                        <i class="fas fa-th-large"></i>
                        <div class="asset-item-name">Pedestal</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('wall')">
                        <i class="fas fa-border-all"></i>
                        <div class="asset-item-name">Wall</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('frame')">
                        <i class="fas fa-image"></i>
                        <div class="asset-item-name">Art Frame</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('floor')">
                        <i class="fas fa-square"></i>
                        <div class="asset-item-name">Floor Tile</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('ceiling')">
                        <i class="fas fa-minus"></i>
                        <div class="asset-item-name">Ceiling</div>
                    </div>
                </div>

                <div class="section-title">Environment</div>
                <div class="asset-grid">
                    <div class="asset-item" onclick="createDefaultAsset('skybox')">
                        <i class="fas fa-cloud"></i>
                        <div class="asset-item-name">Sky</div>
                    </div>
                    <div class="asset-item" onclick="createDefaultAsset('ambientlight')">
                        <i class="fas fa-sun"></i>
                        <div class="asset-item-name">Ambient Light</div>
                    </div>
                </div>
            </div>

            <!-- Objects Panel -->
            <div class="sidebar-panel" id="panel-objects">
                <div class="section-title">Scene Hierarchy</div>
                <div id="hierarchy-list"></div>
            </div>

            <!-- Collisions Panel -->
            <div class="sidebar-panel" id="panel-collisions">
                <div class="section-title">Collision Objects</div>
                <div id="collision-list"></div>
                <button class="btn btn-secondary" onclick="toggleAllColliders()">
                    <i class="fas fa-eye"></i> Toggle Helpers
                </button>
                <button class="btn" onclick="rebuildColliders()">
                    <i class="fas fa-sync"></i> Rebuild All
                </button>
            </div>
        </div>
    </div>

    <!-- Right Sidebar - Properties -->
    <div class="right-sidebar" id="right-sidebar">
        <div class="sidebar-tabs">
            <div class="sidebar-tab active" onclick="switchRightTab('properties')">
                <i class="fas fa-sliders-h"></i><br>Properties
            </div>
            <div class="sidebar-tab" onclick="switchRightTab('scene')">
                <i class="fas fa-globe"></i><br>Scene
            </div>
        </div>

        <div class="sidebar-content">
            <!-- Properties Panel -->
            <div class="sidebar-panel active" id="panel-properties">
                <div class="no-selection" id="no-selection">
                    <i class="fas fa-mouse-pointer" style="font-size: 32px; color: #444; margin-bottom: 10px; display: block;"></i>
                    Select an object to edit properties
                </div>

                <div id="properties-content" style="display: none;">
                    <div class="property-group">
                        <div class="property-label">Object Name</div>
                        <input type="text" class="property-input" id="obj-name" oninput="updateObjectName()">
                    </div>

                    <div class="property-group">
                        <div class="property-label">Transform Mode</div>
                        <div class="transform-mode-group">
                            <button class="mode-btn active" id="mode-translate" onclick="setTransformMode('translate')">
                                <i class="fas fa-arrows-alt"></i> Move
                            </button>
                            <button class="mode-btn" id="mode-rotate" onclick="setTransformMode('rotate')">
                                <i class="fas fa-redo"></i> Rotate
                            </button>
                            <button class="mode-btn" id="mode-scale" onclick="setTransformMode('scale')">
                                <i class="fas fa-expand"></i> Scale
                            </button>
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-label">Position</div>
                        <div class="vector-labels">
                            <div class="vector-label">X</div>
                            <div class="vector-label">Y</div>
                            <div class="vector-label">Z</div>
                        </div>
                        <div class="vector-inputs">
                            <input type="number" class="vector-input" id="pos-x" step="0.1" oninput="updatePosition('x', this.value)">
                            <input type="number" class="vector-input" id="pos-y" step="0.1" oninput="updatePosition('y', this.value)">
                            <input type="number" class="vector-input" id="pos-z" step="0.1" oninput="updatePosition('z', this.value)">
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-label">Rotation (degrees)</div>
                        <div class="vector-labels">
                            <div class="vector-label">X</div>
                            <div class="vector-label">Y</div>
                            <div class="vector-label">Z</div>
                        </div>
                        <div class="vector-inputs">
                            <input type="number" class="vector-input" id="rot-x" step="1" oninput="updateRotation('x', this.value)">
                            <input type="number" class="vector-input" id="rot-y" step="1" oninput="updateRotation('y', this.value)">
                            <input type="number" class="vector-input" id="rot-z" step="1" oninput="updateRotation('z', this.value)">
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-label">Scale</div>
                        <div class="vector-labels">
                            <div class="vector-label">X</div>
                            <div class="vector-label">Y</div>
                            <div class="vector-label">Z</div>
                        </div>
                        <div class="vector-inputs">
                            <input type="number" class="vector-input" id="scale-x" step="0.1" oninput="updateScale('x', this.value)">
                            <input type="number" class="vector-input" id="scale-y" step="0.1" oninput="updateScale('y', this.value)">
                            <input type="number" class="vector-input" id="scale-z" step="0.1" oninput="updateScale('z', this.value)">
                        </div>
                    </div>

                    <div class="property-group" id="material-section">
                        <div class="property-label">Material</div>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" id="color-preview" onclick="document.getElementById('obj-color').click()"></div>
                            <input type="color" id="obj-color" oninput="updateColor()">
                            <input type="text" class="property-input" id="color-hex" style="flex: 1;" oninput="updateColorFromHex()" placeholder="#ffffff">
                        </div>

                        <div class="property-label" style="margin-top: 12px;">Roughness</div>
                        <input type="range" min="0" max="1" step="0.01" value="0.5" id="obj-roughness" oninput="updateMaterial()" style="width: 100%;">

                        <div class="property-label" style="margin-top: 12px;">Metalness</div>
                        <input type="range" min="0" max="1" step="0.01" value="0.5" id="obj-metalness" oninput="updateMaterial()" style="width: 100%;">
                    </div>

                    <div class="property-group" id="light-section" style="display: none;">
                        <div class="property-label">Light Color</div>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" id="light-color-preview" onclick="document.getElementById('light-color').click()"></div>
                            <input type="color" id="light-color" oninput="updateLightColor()">
                        </div>

                        <div class="property-label" style="margin-top: 12px;">Intensity</div>
                        <input type="number" class="property-input" id="light-intensity" min="0" step="0.1" value="1" oninput="updateLightIntensity()">

                        <div class="property-label">Distance (0 = infinite)</div>
                        <input type="number" class="property-input" id="light-distance" min="0" step="1" value="0" oninput="updateLightDistance()">
                    </div>

                    <div class="property-group" id="collision-section">
                        <div class="property-label">Collision</div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="has-collision" onchange="toggleObjectCollision()">
                            <label for="has-collision">Enable Collision</label>
                        </div>
                    </div>

                    <div class="property-group">
                        <button class="btn btn-danger" onclick="deleteSelectedObject()">
                            <i class="fas fa-trash"></i> Delete Object
                        </button>
                    </div>
                </div>
            </div>

            <!-- Scene Settings Panel -->
            <div class="sidebar-panel" id="panel-scene">
                <div class="property-group">
                    <div class="property-label">Background Color</div>
                    <div class="color-picker-wrapper">
                        <div class="color-preview" id="bg-color-preview" onclick="document.getElementById('bg-color').click()"></div>
                        <input type="color" id="bg-color" value="#2a2a2a" oninput="updateBackgroundColor()">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Fog</div>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="fog-enabled" checked onchange="updateFog()">
                        <label for="fog-enabled">Enable Fog</label>
                    </div>
                    <div class="property-label" style="margin-top: 10px;">Fog Distance</div>
                    <input type="number" class="property-input" id="fog-distance" value="200" oninput="updateFog()">
                </div>

                <div class="property-group">
                    <div class="property-label">Grid (Press G to toggle)</div>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="show-grid-checkbox" checked onchange="toggleGrid()">
                        <label for="show-grid-checkbox">Show Grid</label>
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Ambient Light Intensity</div>
                    <input type="range" min="0" max="2" step="0.1" value="0.4" id="ambient-intensity" oninput="updateAmbientLight()" style="width: 100%;">
                </div>

                <div class="property-group">
                    <div class="property-label">Sun Light Intensity</div>
                    <input type="range" min="0" max="2" step="0.1" value="0.8" id="sun-intensity" oninput="updateSunLight()" style="width: 100%;">
                </div>

                <div class="property-group">
                    <div class="property-label">Spawn Point Info</div>
                    <div class="spawn-point-info" id="spawn-info">
                        No spawn point in scene. Add one from the Assets panel.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <script>
        // ============================================
        // GLOBAL VARIABLES
        // ============================================
        let scene, camera, renderer;
        let orbitControls, transformControls;
        let selectedObject = null;
        let objectHighlight = null;
        let sceneObjects = [];
        let colliderObjects = [];
        let colliderHelpers = [];
        let showColliderHelpers = false;

        // Scene elements
        let gridHelper, ambientLight, directionalLight;
        let spawnPoint = null;

        // Undo/Redo
        const MAX_UNDO_HISTORY = 50;
        let undoStack = [];
        let redoStack = [];

        // Raycasting
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Play mode
        let isPlayMode = false;
        let playModeCamera, editorCamera;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isLocked = false;

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            scene.fog = new THREE.Fog(0x2a2a2a, 0, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            editorCamera = camera;

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            setupLighting();
            setupGround();
            loadEditorControls();

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onCanvasClick);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('mode-toggle').addEventListener('click', togglePlayMode);

            animate();
        }

        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            ambientLight.name = '_AmbientLight';
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.name = '_DirectionalLight';
            scene.add(directionalLight);
        }

        function setupGround() {
            gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x2a2a2a);
            gridHelper.name = '_GridHelper';
            gridHelper.visible = true;
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.name = '_AxesHelper';
            scene.add(axesHelper);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            ground.name = '_Ground';
            scene.add(ground);

            // Add ground to colliders
            addCollider(ground);
        }

        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                const checkbox = document.getElementById('show-grid-checkbox');
                if (checkbox) {
                    checkbox.checked = gridHelper.visible;
                }
                showNotification(gridHelper.visible ? 'Grid shown' : 'Grid hidden');
            }
        }

        function loadEditorControls() {
            const orbitScript = document.createElement('script');
            orbitScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
            orbitScript.onload = () => {
                orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
                orbitControls.enableDamping = true;
                orbitControls.dampingFactor = 0.15;
                orbitControls.screenSpacePanning = true;
                orbitControls.minDistance = 1;
                orbitControls.maxDistance = 200;
                loadTransformControls();
            };
            document.head.appendChild(orbitScript);

            // Load GLTF Loader
            const gltfScript = document.createElement('script');
            gltfScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
            document.head.appendChild(gltfScript);
        }

        function loadTransformControls() {
            const transformScript = document.createElement('script');
            transformScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js';
            transformScript.onload = () => {
                transformControls = new THREE.TransformControls(camera, renderer.domElement);
                transformControls.setMode('translate');
                transformControls.setSize(1.2);
                scene.add(transformControls);

                transformControls.addEventListener('dragging-changed', (event) => {
                    orbitControls.enabled = !event.value;
                    if (!event.value && selectedObject) {
                        saveUndoState(selectedObject, 'transform');
                        updatePropertiesPanel();
                    }
                });

                transformControls.addEventListener('change', () => {
                    if (objectHighlight && selectedObject) {
                        objectHighlight.update();
                    }
                    if (selectedObject && selectedObject.userData.isSpawnPoint) {
                        updateSpawnInfo();
                    }
                });
            };
            document.head.appendChild(transformScript);
        }

        // ============================================
        // ASSET CREATION
        // ============================================
        function createAsset(type) {
            let geometry, material, object;

            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Cube';
                    break;

                case 'sphere':
                    geometry = new THREE.SphereGeometry(1, 32, 32);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Sphere';
                    break;

                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Cylinder';
                    break;

                case 'plane':
                    geometry = new THREE.PlaneGeometry(4, 4);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5,
                        side: THREE.DoubleSide
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.receiveShadow = true;
                    object.castShadow = true;
                    object.name = 'Plane';
                    break;

                case 'cone':
                    geometry = new THREE.ConeGeometry(1, 2, 32);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Cone';
                    break;

                case 'torus':
                    geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
                    material = new THREE.MeshStandardMaterial({
                        color: Math.random() * 0xffffff,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Torus';
                    break;

                case 'wall':
                    geometry = new THREE.BoxGeometry(10, 5, 0.5);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xcccccc,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Wall';
                    addCollider(object);
                    break;

                case 'floor':
                    geometry = new THREE.BoxGeometry(10, 0.5, 10);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x8b7355,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    object = new THREE.Mesh(geometry, material);
                    object.receiveShadow = true;
                    object.castShadow = true;
                    object.name = 'Floor';
                    addCollider(object);
                    break;

                case 'stairs':
                    object = createStairs();
                    break;

                case 'door':
                    object = createDoor();
                    break;

                case 'pointLight':
                    object = new THREE.PointLight(0xffffff, 1, 20);
                    object.castShadow = true;
                    object.name = 'Point Light';
                    const sphereGeom = new THREE.SphereGeometry(0.2, 8, 8);
                    const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    object.add(sphere);
                    break;

                case 'spotLight':
                    object = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5);
                    object.castShadow = true;
                    object.name = 'Spot Light';
                    const coneGeom = new THREE.ConeGeometry(0.3, 0.6, 8);
                    const coneMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const cone = new THREE.Mesh(coneGeom, coneMat);
                    cone.rotation.x = Math.PI;
                    object.add(cone);
                    break;

                case 'spawnPoint':
                    if (spawnPoint) {
                        alert('Spawn point already exists! Select it to move it.');
                        selectObject(spawnPoint);
                        return;
                    }
                    object = createSpawnPoint();
                    spawnPoint = object;
                    updateSpawnInfo();
                    break;

                case 'group':
                    object = new THREE.Group();
                    object.name = 'Group';
                    break;
            }

            if (object) {
                object.position.set(
                    (Math.random() - 0.5) * 8,
                    type === 'floor' ? 0.25 : (type === 'wall' ? 2.5 : 2),
                    (Math.random() - 0.5) * 8
                );

                scene.add(object);
                sceneObjects.push(object);
                updateHierarchy();
                updateCollisionList();
                selectObject(object);
                saveUndoState(object, 'create');
            }
        }

        // Create default assets from Library tab
        function createDefaultAsset(type) {
            let object;

            switch(type) {
                case 'grass':
                    object = createGrassPlane();
                    break;

                case 'pedestal':
                    object = createPedestal();
                    break;

                case 'wall':
                    const wallGeometry = new THREE.BoxGeometry(10, 5, 0.5);
                    const wallMaterial = new THREE.MeshStandardMaterial({
                        color: 0xe8d5c4,
                        roughness: 0.85,
                        metalness: 0.1
                    });
                    object = new THREE.Mesh(wallGeometry, wallMaterial);
                    object.castShadow = true;
                    object.receiveShadow = true;
                    object.name = 'Museum Wall';
                    object.position.set(0, 2.5, 0);
                    break;

                case 'frame':
                    object = createArtFrame();
                    break;

                case 'floor':
                    const floorGeometry = new THREE.PlaneGeometry(20, 20);
                    const floorMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8b7355,
                        roughness: 0.9,
                        metalness: 0.05
                    });
                    object = new THREE.Mesh(floorGeometry, floorMaterial);
                    object.rotation.x = -Math.PI / 2;
                    object.receiveShadow = true;
                    object.name = 'Floor Tile';
                    object.position.set(0, 0, 0);
                    break;

                case 'ceiling':
                    const ceilingGeometry = new THREE.PlaneGeometry(20, 20);
                    const ceilingMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf5f5f5,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    object = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                    object.rotation.x = Math.PI / 2;
                    object.receiveShadow = true;
                    object.name = 'Ceiling';
                    object.position.set(0, 8, 0);
                    break;

                case 'skybox':
                    scene.background = new THREE.Color(0x87ceeb);
                    showNotification('Sky color applied to scene');
                    return;

                case 'ambientlight':
                    object = new THREE.AmbientLight(0xffffff, 0.6);
                    object.name = 'Ambient Light';
                    break;
            }

            if (object) {
                scene.add(object);
                sceneObjects.push(object);
                updateHierarchy();
                updateCollisionList();
                selectObject(object);
                saveUndoState(object, 'create');
                showNotification('Added ' + object.name + ' to scene');
            }
        }

        // Create enhanced grass plane with instanced blades
        function createGrassPlane() {
            const group = new THREE.Group();
            group.name = 'Grass Plane';

            // Canvas texture for broad grass color/variation
            const cvs = document.createElement("canvas");
            cvs.width = 1024;
            cvs.height = 1024;
            const ctx = cvs.getContext("2d");

            // Base gradient - natural grass tones
            const g = ctx.createLinearGradient(0, 0, 0, cvs.height);
            g.addColorStop(0, "#2e5f2a");
            g.addColorStop(0.6, "#274f22");
            g.addColorStop(1, "#1f451b");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, cvs.width, cvs.height);

            // Add random blade strokes for micro-variation
            ctx.strokeStyle = "rgba(30,70,30,0.16)";
            for (let i = 0; i < 1400; i++) {
                const x = Math.random() * cvs.width;
                const y = Math.random() * cvs.height;
                const h = 6 + Math.random() * 30;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(
                    x + (Math.random() - 0.5) * 8,
                    y - h / 2,
                    x + (Math.random() - 0.5) * 6,
                    y - h
                );
                ctx.stroke();
            }

            const grassTex = new THREE.CanvasTexture(cvs);
            grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
            grassTex.repeat.set(8, 4);
            try {
                grassTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            } catch (e) {}

            // Main grass plane
            const grassPlaneGeom = new THREE.PlaneGeometry(30, 30);
            const grassPlaneMat = new THREE.MeshStandardMaterial({
                map: grassTex,
                roughness: 0.9,
                metalness: 0.05,
            });
            const grassPlane = new THREE.Mesh(grassPlaneGeom, grassPlaneMat);
            grassPlane.rotation.x = -Math.PI / 2;
            grassPlane.receiveShadow = true;
            group.add(grassPlane);

            // Add instanced thin blades for depth and parallax
            try {
                // Create blade texture with alpha
                const bladeCanvas = document.createElement("canvas");
                bladeCanvas.width = 64;
                bladeCanvas.height = 256;
                const bctx = bladeCanvas.getContext("2d");

                // Blade gradient
                const g2 = bctx.createLinearGradient(0, 0, 0, bladeCanvas.height);
                g2.addColorStop(0, "#66b86a");
                g2.addColorStop(1, "#2f7a2f");
                bctx.fillStyle = g2;
                bctx.fillRect(0, 0, bladeCanvas.width, bladeCanvas.height);

                // Alpha mask: triangular taper
                bctx.globalCompositeOperation = "destination-in";
                bctx.beginPath();
                bctx.moveTo(bladeCanvas.width / 2, 0);
                bctx.lineTo(bladeCanvas.width, bladeCanvas.height);
                bctx.lineTo(0, bladeCanvas.height);
                bctx.closePath();
                bctx.fillStyle = "rgba(0,0,0,1)";
                bctx.fill();

                // Add subtle vein lines
                bctx.globalCompositeOperation = "source-over";
                bctx.strokeStyle = "rgba(20,60,20,0.12)";
                bctx.lineWidth = 1.2;
                for (let v = 0; v < 6; v++) {
                    const sx = bladeCanvas.width / 2 + (Math.random() - 0.5) * 6;
                    const sy = Math.random() * bladeCanvas.height * 0.1;
                    const ex = bladeCanvas.width / 2 + (Math.random() - 0.5) * 10;
                    const ey = bladeCanvas.height - Math.random() * bladeCanvas.height * 0.05;
                    bctx.beginPath();
                    bctx.moveTo(sx, sy);
                    bctx.quadraticCurveTo(
                        bladeCanvas.width / 2 + (Math.random() - 0.5) * 12,
                        bladeCanvas.height * 0.5,
                        ex,
                        ey
                    );
                    bctx.stroke();
                }

                const bladeTex = new THREE.CanvasTexture(bladeCanvas);
                try {
                    bladeTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                } catch (e) {}
                bladeTex.wrapS = bladeTex.wrapT = THREE.ClampToEdgeWrapping;

                const perMeshCount = 400;
                const planeGeom = new THREE.PlaneGeometry(0.06, 1.0);
                const bladeMat = new THREE.MeshStandardMaterial({
                    map: bladeTex,
                    transparent: true,
                    side: THREE.DoubleSide,
                    alphaTest: 0.4,
                    roughness: 0.95,
                });

                // Create two crossed instanced meshes
                const bladesA = new THREE.InstancedMesh(planeGeom, bladeMat, perMeshCount);
                const bladesB = new THREE.InstancedMesh(planeGeom, bladeMat, perMeshCount);
                bladesA.receiveShadow = true;
                bladesB.receiveShadow = true;

                const dummy = new THREE.Object3D();
                for (let i = 0; i < perMeshCount; i++) {
                    const x = (Math.random() - 0.5) * 30;
                    const z = (Math.random() - 0.5) * 30;
                    const h = 0.15 + Math.random() * 0.45;
                    const rotY = (Math.random() - 0.5) * 1.2;

                    // bladesA
                    dummy.position.set(x, h / 2, z);
                    dummy.rotation.set(0, rotY, 0);
                    dummy.scale.set(1, h, 1);
                    dummy.updateMatrix();
                    bladesA.setMatrixAt(i, dummy.matrix);

                    // bladesB: crossed 90deg
                    dummy.rotation.set(0, rotY + Math.PI / 2, 0);
                    dummy.updateMatrix();
                    bladesB.setMatrixAt(i, dummy.matrix);
                }

                bladesA.instanceMatrix.needsUpdate = true;
                bladesB.instanceMatrix.needsUpdate = true;
                group.add(bladesA);
                group.add(bladesB);
            } catch (e) {
                console.warn("Instanced grass blades failed", e);
            }

            group.position.set(0, 0, 0);
            return group;
        }

        // Create museum pedestal
        function createPedestal() {
            const group = new THREE.Group();
            group.name = 'Pedestal';

            // Base
            const baseGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.3, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.4,
                metalness: 0.6
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            base.receiveShadow = true;
            base.position.y = 0.15;
            group.add(base);

            // Column
            const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 32);
            const columnMaterial = new THREE.MeshStandardMaterial({
                color: 0xf5f5f5,
                roughness: 0.7,
                metalness: 0.2
            });
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.castShadow = true;
            column.receiveShadow = true;
            column.position.y = 1.3;
            group.add(column);

            // Top
            const topGeometry = new THREE.CylinderGeometry(1.1, 0.9, 0.2, 32);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.4,
                metalness: 0.6
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.castShadow = true;
            top.receiveShadow = true;
            top.position.y = 2.4;
            group.add(top);

            group.position.set(0, 0, 0);
            return group;
        }

        // Create art frame
        function createArtFrame() {
            const group = new THREE.Group();
            group.name = 'Art Frame';

            // Frame border
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b7355,
                roughness: 0.6,
                metalness: 0.3
            });

            const thickness = 0.15;
            const width = 3;
            const height = 4;
            const border = 0.3;

            // Top
            const topGeom = new THREE.BoxGeometry(width + border * 2, border, thickness);
            const top = new THREE.Mesh(topGeom, frameMaterial);
            top.position.set(0, height / 2 + border / 2, 0);
            group.add(top);

            // Bottom
            const bottom = new THREE.Mesh(topGeom, frameMaterial);
            bottom.position.set(0, -height / 2 - border / 2, 0);
            group.add(bottom);

            // Left
            const sideGeom = new THREE.BoxGeometry(border, height, thickness);
            const left = new THREE.Mesh(sideGeom, frameMaterial);
            left.position.set(-width / 2 - border / 2, 0, 0);
            group.add(left);

            // Right
            const right = new THREE.Mesh(sideGeom, frameMaterial);
            right.position.set(width / 2 + border / 2, 0, 0);
            group.add(right);

            // Canvas/backing
            const canvasGeom = new THREE.PlaneGeometry(width, height);
            const canvasMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.9
            });
            const canvas = new THREE.Mesh(canvasGeom, canvasMaterial);
            canvas.position.z = -thickness / 2;
            group.add(canvas);

            group.position.set(0, 3, 0);
            group.castShadow = true;
            group.receiveShadow = true;
            return group;
        }

        function createStairs() {
            const group = new THREE.Group();
            group.name = 'Stairs';

            const stepCount = 8;
            const stepWidth = 4;
            const stepHeight = 0.3;
            const stepDepth = 1;

            for (let i = 0; i < stepCount; i++) {
                const geometry = new THREE.BoxGeometry(stepWidth, stepHeight, stepDepth);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8b7355,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const step = new THREE.Mesh(geometry, material);
                step.castShadow = true;
                step.receiveShadow = true;
                step.position.set(0, i * stepHeight, -i * stepDepth);
                group.add(step);
            }

            addCollider(group);
            return group;
        }

        function createDoor() {
            const group = new THREE.Group();
            group.name = 'Door';

            // Frame
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });

            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 0.2), frameMaterial);
            leftFrame.position.set(-1.1, 2, 0);
            leftFrame.castShadow = true;
            group.add(leftFrame);

            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 0.2), frameMaterial);
            rightFrame.position.set(1.1, 2, 0);
            rightFrame.castShadow = true;
            group.add(rightFrame);

            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.2, 0.2), frameMaterial);
            topFrame.position.set(0, 4, 0);
            topFrame.castShadow = true;
            group.add(topFrame);

            // Door
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 });
            const door = new THREE.Mesh(new THREE.BoxGeometry(2, 3.8, 0.1), doorMaterial);
            door.position.set(0, 1.9, 0);
            door.castShadow = true;
            door.receiveShadow = true;
            group.add(door);

            addCollider(group);
            return group;
        }

        function createSpawnPoint() {
            const group = new THREE.Group();
            group.name = 'Spawn Point';
            group.userData.isSpawnPoint = true;

            // Body (capsule approximation)
            const bodyGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 16);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5,
                emissive: 0x00ff00,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.8;
            group.add(body);

            // Head
            const headGeom = new THREE.SphereGeometry(0.3, 16, 16);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.y = 1.8;
            group.add(head);

            // Direction arrow
            const arrowGeom = new THREE.ConeGeometry(0.2, 0.6, 8);
            const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const arrow = new THREE.Mesh(arrowGeom, arrowMat);
            arrow.rotation.x = Math.PI / 2;
            arrow.position.set(0, 1, 0.6);
            group.add(arrow);

            // Base circle
            const circleGeom = new THREE.RingGeometry(0.4, 0.5, 32);
            const circleMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(circleGeom, circleMat);
            circle.rotation.x = -Math.PI / 2;
            group.add(circle);

            group.position.y = 0;
            return group;
        }

        // ============================================
        // MODEL LOADING
        // ============================================
        function loadModel(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                const loader = new THREE.GLTFLoader();
                loader.load(
                    url,
                    function(gltf) {
                        const model = gltf.scene;
                        model.name = file.name.replace(/\.[^/.]+$/, "");

                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        model.position.set(0, 1, 0);
                        scene.add(model);
                        sceneObjects.push(model);
                        updateHierarchy();
                        selectObject(model);
                        saveUndoState(model, 'create');

                        URL.revokeObjectURL(url);
                    },
                    undefined,
                    function(error) {
                        console.error('Error loading model:', error);
                        alert('Error loading 3D model. Please check the file format.');
                    }
                );
            };
            reader.readAsArrayBuffer(file);
            event.target.value = '';
        }

        // ============================================
        // COLLISION SYSTEM
        // ============================================
        function addCollider(obj) {
            if (!colliderObjects.includes(obj)) {
                colliderObjects.push(obj);
                obj.userData.hasCollision = true;
                updateCollisionList();
            }
        }

        function removeCollider(obj) {
            const index = colliderObjects.indexOf(obj);
            if (index > -1) {
                colliderObjects.splice(index, 1);
                obj.userData.hasCollision = false;
                updateCollisionList();
            }
        }

        function toggleObjectCollision() {
            if (!selectedObject) return;

            const enabled = document.getElementById('has-collision').checked;
            if (enabled) {
                addCollider(selectedObject);
            } else {
                removeCollider(selectedObject);
            }
        }

        function toggleAllColliders() {
            showColliderHelpers = !showColliderHelpers;
            rebuildColliderHelpers();
        }

        function rebuildColliders() {
            rebuildColliderHelpers();
            updateCollisionList();
        }

        function rebuildColliderHelpers() {
            // Remove old helpers
            colliderHelpers.forEach(helper => {
                scene.remove(helper);
            });
            colliderHelpers = [];

            if (!showColliderHelpers) return;

            // Create new helpers
            colliderObjects.forEach(obj => {
                const helper = new THREE.BoxHelper(obj, 0x00ff00);
                helper.name = '_ColliderHelper';
                scene.add(helper);
                colliderHelpers.push(helper);
            });
        }

        function updateCollisionList() {
            const list = document.getElementById('collision-list');
            list.innerHTML = '';

            if (colliderObjects.length === 0) {
                list.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No collision objects</div>';
                return;
            }

            colliderObjects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'collision-item';
                item.innerHTML = `
                    <div class="collision-item-header">
                        <span>${obj.name || 'Unnamed'}</span>
                        <button class="collision-toggle enabled" onclick="removeCollider(sceneObjects.find(o => o.uuid === '${obj.uuid}'))">
                            <i class="fas fa-check"></i> Enabled
                        </button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // ============================================
        // OBJECT SELECTION & MANIPULATION
        // ============================================
        function onCanvasClick(event) {
            if (!transformControls || isPlayMode) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;

                while (object.parent && object.parent !== scene) {
                    if (sceneObjects.includes(object.parent)) {
                        object = object.parent;
                        break;
                    }
                    object = object.parent;
                }

                if (isSelectableObject(object)) {
                    selectObject(object);
                }
            } else {
                deselectObject();
            }
        }

        function isSelectableObject(obj) {
            if (!obj) return false;
            if (obj.name && obj.name.startsWith('_')) return false;
            return sceneObjects.includes(obj);
        }

        function selectObject(obj) {
            if (selectedObject === obj) return;

            deselectObject();
            selectedObject = obj;

            if (transformControls) {
                transformControls.attach(obj);
            }

            createHighlight(obj);
            updatePropertiesPanel();
            updateHierarchy();
        }

        function deselectObject() {
            if (!selectedObject) return;

            if (transformControls) {
                transformControls.detach();
            }

            removeHighlight();
            selectedObject = null;

            document.getElementById('no-selection').style.display = 'block';
            document.getElementById('properties-content').style.display = 'none';
            updateHierarchy();
        }

        function createHighlight(obj) {
            removeHighlight();

            if (obj.isLight) return;

            objectHighlight = new THREE.BoxHelper(obj, 0x00ddff);
            objectHighlight.material.linewidth = 2;
            scene.add(objectHighlight);
        }

        function removeHighlight() {
            if (objectHighlight) {
                scene.remove(objectHighlight);
                objectHighlight.geometry.dispose();
                objectHighlight.material.dispose();
                objectHighlight = null;
            }
        }

        // ============================================
        // PROPERTIES PANEL
        // ============================================
        function updatePropertiesPanel() {
            if (!selectedObject) {
                document.getElementById('no-selection').style.display = 'block';
                document.getElementById('properties-content').style.display = 'none';
                return;
            }

            document.getElementById('no-selection').style.display = 'none';
            document.getElementById('properties-content').style.display = 'block';

            document.getElementById('obj-name').value = selectedObject.name || '';

            document.getElementById('pos-x').value = selectedObject.position.x.toFixed(2);
            document.getElementById('pos-y').value = selectedObject.position.y.toFixed(2);
            document.getElementById('pos-z').value = selectedObject.position.z.toFixed(2);

            document.getElementById('rot-x').value = THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(0);
            document.getElementById('rot-y').value = THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(0);
            document.getElementById('rot-z').value = THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(0);

            document.getElementById('scale-x').value = selectedObject.scale.x.toFixed(2);
            document.getElementById('scale-y').value = selectedObject.scale.y.toFixed(2);
            document.getElementById('scale-z').value = selectedObject.scale.z.toFixed(2);

            // Material or Light
            if (selectedObject.isLight) {
                document.getElementById('material-section').style.display = 'none';
                document.getElementById('light-section').style.display = 'block';

                const color = '#' + selectedObject.color.getHexString();
                document.getElementById('light-color').value = color;
                document.getElementById('light-color-preview').style.backgroundColor = color;
                document.getElementById('light-intensity').value = selectedObject.intensity;
                document.getElementById('light-distance').value = selectedObject.distance || 0;
            } else if (selectedObject.material) {
                document.getElementById('material-section').style.display = 'block';
                document.getElementById('light-section').style.display = 'none';

                const color = '#' + selectedObject.material.color.getHexString();
                document.getElementById('obj-color').value = color;
                document.getElementById('color-preview').style.backgroundColor = color;
                document.getElementById('color-hex').value = color;
                document.getElementById('obj-roughness').value = selectedObject.material.roughness || 0.5;
                document.getElementById('obj-metalness').value = selectedObject.material.metalness || 0.5;
            } else {
                document.getElementById('material-section').style.display = 'none';
                document.getElementById('light-section').style.display = 'none';
            }

            // Collision
            document.getElementById('has-collision').checked = selectedObject.userData.hasCollision || false;
        }

        function updateObjectName() {
            if (!selectedObject) return;
            selectedObject.name = document.getElementById('obj-name').value;
            updateHierarchy();
            updateCollisionList();
        }

        function updatePosition(axis, value) {
            if (!selectedObject) return;
            selectedObject.position[axis] = parseFloat(value) || 0;
            if (objectHighlight) objectHighlight.update();
            if (selectedObject.userData.isSpawnPoint) updateSpawnInfo();
        }

        function updateRotation(axis, value) {
            if (!selectedObject) return;
            selectedObject.rotation[axis] = THREE.MathUtils.degToRad(parseFloat(value) || 0);
            if (objectHighlight) objectHighlight.update();
            if (selectedObject.userData.isSpawnPoint) updateSpawnInfo();
        }

        function updateScale(axis, value) {
            if (!selectedObject) return;
            selectedObject.scale[axis] = parseFloat(value) || 1;
            if (objectHighlight) objectHighlight.update();
        }

        function updateColor() {
            if (!selectedObject || !selectedObject.material) return;
            const color = document.getElementById('obj-color').value;
            selectedObject.material.color.setStyle(color);
            document.getElementById('color-preview').style.backgroundColor = color;
            document.getElementById('color-hex').value = color;
        }

        function updateColorFromHex() {
            if (!selectedObject || !selectedObject.material) return;
            const hex = document.getElementById('color-hex').value;
            try {
                selectedObject.material.color.setStyle(hex);
                document.getElementById('obj-color').value = hex;
                document.getElementById('color-preview').style.backgroundColor = hex;
            } catch(e) {}
        }

        function updateMaterial() {
            if (!selectedObject || !selectedObject.material) return;
            selectedObject.material.roughness = parseFloat(document.getElementById('obj-roughness').value);
            selectedObject.material.metalness = parseFloat(document.getElementById('obj-metalness').value);
        }

        function updateLightColor() {
            if (!selectedObject || !selectedObject.isLight) return;
            const color = document.getElementById('light-color').value;
            selectedObject.color.setStyle(color);
            document.getElementById('light-color-preview').style.backgroundColor = color;
        }

        function updateLightIntensity() {
            if (!selectedObject || !selectedObject.isLight) return;
            selectedObject.intensity = parseFloat(document.getElementById('light-intensity').value);
        }

        function updateLightDistance() {
            if (!selectedObject || !selectedObject.isLight) return;
            selectedObject.distance = parseFloat(document.getElementById('light-distance').value);
        }

        function setTransformMode(mode) {
            if (!transformControls) return;
            transformControls.setMode(mode);

            document.getElementById('mode-translate').classList.remove('active');
            document.getElementById('mode-rotate').classList.remove('active');
            document.getElementById('mode-scale').classList.remove('active');
            document.getElementById('mode-' + mode).classList.add('active');
        }

        function deleteSelectedObject() {
            if (!selectedObject) return;

            if (selectedObject.userData.isSpawnPoint) {
                spawnPoint = null;
                updateSpawnInfo();
            }

            saveUndoState(selectedObject, 'delete');
            scene.remove(selectedObject);

            if (selectedObject.geometry) selectedObject.geometry.dispose();
            if (selectedObject.material) {
                if (Array.isArray(selectedObject.material)) {
                    selectedObject.material.forEach(m => m.dispose());
                } else {
                    selectedObject.material.dispose();
                }
            }

            const index = sceneObjects.indexOf(selectedObject);
            if (index > -1) sceneObjects.splice(index, 1);

            removeCollider(selectedObject);
            deselectObject();
            updateHierarchy();
        }

        // ============================================
        // HIERARCHY
        // ============================================
        function updateHierarchy() {
            const list = document.getElementById('hierarchy-list');
            list.innerHTML = '';

            if (sceneObjects.length === 0) {
                list.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No objects in scene</div>';
                return;
            }

            sceneObjects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'hierarchy-item';
                if (obj === selectedObject) item.classList.add('selected');

                let icon = 'fa-cube';
                if (obj.isLight) icon = 'fa-lightbulb';
                if (obj.userData.isSpawnPoint) icon = 'fa-user';
                if (obj.type === 'Group') icon = 'fa-object-group';

                item.innerHTML = `<i class="fas ${icon}"></i><span>${obj.name || obj.type}</span>`;
                item.onclick = () => selectObject(obj);
                list.appendChild(item);
            });
        }

        // ============================================
        // SCENE SETTINGS
        // ============================================
        function updateBackgroundColor() {
            const color = document.getElementById('bg-color').value;
            scene.background.setStyle(color);
            document.getElementById('bg-color-preview').style.backgroundColor = color;
            if (scene.fog) scene.fog.color.setStyle(color);
        }

        function updateFog() {
            const enabled = document.getElementById('fog-enabled').checked;
            const distance = parseFloat(document.getElementById('fog-distance').value);

            if (enabled) {
                const color = scene.background.getHex();
                scene.fog = new THREE.Fog(color, 0, distance);
            } else {
                scene.fog = null;
            }
        }

        function updateGrid() {
            const enabled = document.getElementById('grid-enabled').checked;
            gridHelper.visible = enabled;
        }

        function updateAmbientLight() {
            const intensity = parseFloat(document.getElementById('ambient-intensity').value);
            ambientLight.intensity = intensity;
        }

        function updateSunLight() {
            const intensity = parseFloat(document.getElementById('sun-intensity').value);
            directionalLight.intensity = intensity;
        }

        function updateSpawnInfo() {
            const info = document.getElementById('spawn-info');
            if (!spawnPoint) {
                info.innerHTML = 'No spawn point in scene. Add one from the Assets panel.';
                return;
            }

            const pos = spawnPoint.position;
            const rot = spawnPoint.rotation;
            info.innerHTML = `
                Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})<br>
                Rotation: ${THREE.MathUtils.radToDeg(rot.y).toFixed(0)}
            `;
        }

        // ============================================
        // SIDEBAR TABS
        // ============================================
        function switchLeftTab(tab) {
            document.querySelectorAll('.left-sidebar .sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.left-sidebar .sidebar-panel').forEach(p => p.classList.remove('active'));

            event.target.closest('.sidebar-tab').classList.add('active');
            document.getElementById('panel-' + tab).classList.add('active');
        }

        function switchRightTab(tab) {
            document.querySelectorAll('.right-sidebar .sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.right-sidebar .sidebar-panel').forEach(p => p.classList.remove('active'));

            event.target.closest('.sidebar-tab').classList.add('active');
            document.getElementById('panel-' + tab).classList.add('active');
        }

        // ============================================
        // PLAY MODE
        // ============================================
        function togglePlayMode() {
            isPlayMode = !isPlayMode;

            const overlay = document.getElementById('play-mode-overlay');
            const modeText = document.getElementById('mode-text');
            const modeBtn = document.getElementById('mode-toggle');
            const leftSidebar = document.getElementById('left-sidebar');
            const rightSidebar = document.getElementById('right-sidebar');

            if (isPlayMode) {
                overlay.classList.add('active');
                modeText.textContent = 'Exit Play';
                modeBtn.classList.add('active');
                leftSidebar.style.display = 'none';
                rightSidebar.style.display = 'none';

                if (transformControls) transformControls.enabled = false;
                if (orbitControls) orbitControls.enabled = false;

                // Hide grid in play mode (save previous state)
                if (gridHelper) {
                    window.gridWasVisible = gridHelper.visible;
                    gridHelper.visible = false;
                }

                // Setup play camera
                if (spawnPoint) {
                    camera.position.copy(spawnPoint.position);
                    camera.position.y += 1.6;
                    camera.rotation.y = spawnPoint.rotation.y;
                }

                renderer.domElement.addEventListener('click', requestPointerLock);
            } else {
                overlay.classList.remove('active');
                modeText.textContent = 'Play Mode';
                modeBtn.classList.remove('active');
                leftSidebar.style.display = 'flex';
                rightSidebar.style.display = 'flex';

                if (transformControls) transformControls.enabled = true;
                if (orbitControls) orbitControls.enabled = true;

                // Restore grid visibility from before play mode
                if (gridHelper && window.gridWasVisible !== undefined) {
                    gridHelper.visible = window.gridWasVisible;
                    const checkbox = document.getElementById('show-grid-checkbox');
                    if (checkbox) {
                        checkbox.checked = gridHelper.visible;
                    }
                }

                exitPointerLock();
            }
        }

        function requestPointerLock() {
            if (!isPlayMode) return;
            renderer.domElement.requestPointerLock();
        }

        function exitPointerLock() {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isLocked || !isPlayMode) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });

        function onKeyDown(event) {
            if (isPlayMode) {
                switch(event.code) {
                    case 'KeyW': case 'ArrowUp': moveForward = true; break;
                    case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                    case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                    case 'KeyD': case 'ArrowRight': moveRight = true; break;
                    case 'Escape': togglePlayMode(); break;
                }
            } else {
                // Editor shortcuts
                if (event.ctrlKey && event.key === 'z') {
                    event.preventDefault();
                    undo();
                }
                if (event.ctrlKey && event.key === 'y') {
                    event.preventDefault();
                    redo();
                }
                if (event.ctrlKey && event.key === 's') {
                    event.preventDefault();
                    saveScene();
                }
                if (event.key === 'Delete' && selectedObject) {
                    deleteSelectedObject();
                }
                if (event.key === 'g' && !event.ctrlKey) {
                    event.preventDefault();
                    toggleGrid();
                }
                if (event.key === 'w' && !event.ctrlKey) setTransformMode('translate');
                if (event.key === 'e' && !event.ctrlKey) setTransformMode('rotate');
                if (event.key === 'r' && !event.ctrlKey) setTransformMode('scale');
            }
        }

        function onKeyUp(event) {
            if (!isPlayMode) return;

            switch(event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        }

        // ============================================
        // UNDO/REDO
        // ============================================
        function saveUndoState(object, actionType = 'transform') {
            const state = {
                object: object,
                objectId: object.uuid,
                name: object.name || object.type,
                actionType: actionType,
                position: object.position.clone(),
                rotation: new THREE.Euler().copy(object.rotation),
                scale: object.scale.clone(),
                timestamp: Date.now()
            };

            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_HISTORY) undoStack.shift();
            redoStack = [];
        }

        function undo() {
            if (undoStack.length === 0) return;

            const state = undoStack.pop();
            const redoState = {
                object: state.object,
                objectId: state.objectId,
                name: state.name,
                actionType: state.actionType,
                position: state.object.position.clone(),
                rotation: new THREE.Euler().copy(state.object.rotation),
                scale: state.object.scale.clone(),
                timestamp: Date.now()
            };
            redoStack.push(redoState);

            state.object.position.copy(state.position);
            state.object.rotation.copy(state.rotation);
            state.object.scale.copy(state.scale);

            if (selectedObject === state.object) {
                updatePropertiesPanel();
                if (objectHighlight) objectHighlight.update();
            }
        }

        function redo() {
            if (redoStack.length === 0) return;

            const state = redoStack.pop();
            const undoState = {
                object: state.object,
                objectId: state.objectId,
                name: state.name,
                actionType: state.actionType,
                position: state.object.position.clone(),
                rotation: new THREE.Euler().copy(state.object.rotation),
                scale: state.object.scale.clone(),
                timestamp: Date.now()
            };
            undoStack.push(undoState);

            state.object.position.copy(state.position);
            state.object.rotation.copy(state.rotation);
            state.object.scale.copy(state.scale);

            if (selectedObject === state.object) {
                updatePropertiesPanel();
                if (objectHighlight) objectHighlight.update();
            }
        }

        // ============================================
        // SAVE/LOAD
        // ============================================
        function saveScene() {
            const sceneData = {
                version: '1.0',
                objects: sceneObjects.map(obj => {
                    const data = {
                        type: obj.type,
                        name: obj.name,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray(),
                        scale: obj.scale.toArray(),
                        userData: obj.userData,
                        isLight: obj.isLight || false
                    };

                    if (obj.geometry) {
                        data.geometryType = obj.geometry.type;
                        data.geometryParams = obj.geometry.parameters;
                    }

                    if (obj.material) {
                        data.material = {
                            color: obj.material.color.getHex(),
                            roughness: obj.material.roughness,
                            metalness: obj.material.metalness,
                            side: obj.material.side
                        };
                    }

                    if (obj.isLight) {
                        data.lightColor = obj.color.getHex();
                        data.lightIntensity = obj.intensity;
                        data.lightDistance = obj.distance;
                    }

                    return data;
                }),
                scene: {
                    backgroundColor: '#' + scene.background.getHexString(),
                    fog: scene.fog ? {
                        enabled: true,
                        distance: document.getElementById('fog-distance').value
                    } : { enabled: false },
                    ambientLightIntensity: ambientLight.intensity,
                    sunLightIntensity: directionalLight.intensity
                },
                camera: {
                    position: camera.position.toArray(),
                    rotation: camera.rotation.toArray()
                }
            };

            const json = JSON.stringify(sceneData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'scene-' + Date.now() + '.json';
            link.click();

            URL.revokeObjectURL(url);
        }

        function loadScene() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sceneData = JSON.parse(e.target.result);

                        // Clear scene
                        while(sceneObjects.length > 0) {
                            const obj = sceneObjects[0];
                            scene.remove(obj);
                            sceneObjects.shift();
                        }
                        colliderObjects = [];
                        spawnPoint = null;

                        // Restore objects
                        sceneData.objects.forEach(data => {
                            let object;

                            if (data.isLight) {
                                if (data.type === 'PointLight') {
                                    object = new THREE.PointLight(data.lightColor, data.lightIntensity, data.lightDistance);
                                    const sphere = new THREE.Mesh(
                                        new THREE.SphereGeometry(0.2, 8, 8),
                                        new THREE.MeshBasicMaterial({ color: 0xffff00 })
                                    );
                                    object.add(sphere);
                                } else if (data.type === 'SpotLight') {
                                    object = new THREE.SpotLight(data.lightColor, data.lightIntensity, data.lightDistance);
                                    const cone = new THREE.Mesh(
                                        new THREE.ConeGeometry(0.3, 0.6, 8),
                                        new THREE.MeshBasicMaterial({ color: 0xffff00 })
                                    );
                                    cone.rotation.x = Math.PI;
                                    object.add(cone);
                                }
                                object.castShadow = true;
                            } else if (data.userData.isSpawnPoint) {
                                object = createSpawnPoint();
                                spawnPoint = object;
                            } else if (data.type === 'Group') {
                                object = new THREE.Group();
                            } else if (data.type === 'Mesh') {
                                // Recreate geometry
                                let geometry;
                                // ... (geometry recreation logic)

                                const material = new THREE.MeshStandardMaterial(data.material);
                                object = new THREE.Mesh(geometry, material);
                                object.castShadow = true;
                                object.receiveShadow = true;
                            }

                            if (object) {
                                object.name = data.name;
                                object.position.fromArray(data.position);
                                object.rotation.fromArray(data.rotation);
                                object.scale.fromArray(data.scale);
                                object.userData = data.userData;

                                if (data.userData.hasCollision) {
                                    addCollider(object);
                                }

                                scene.add(object);
                                sceneObjects.push(object);
                            }
                        });

                        // Restore scene settings
                        if (sceneData.scene) {
                            scene.background.setStyle(sceneData.scene.backgroundColor);
                            document.getElementById('bg-color').value = sceneData.scene.backgroundColor;

                            if (sceneData.scene.fog.enabled) {
                                document.getElementById('fog-enabled').checked = true;
                                document.getElementById('fog-distance').value = sceneData.scene.fog.distance;
                                updateFog();
                            }

                            ambientLight.intensity = sceneData.scene.ambientLightIntensity;
                            directionalLight.intensity = sceneData.scene.sunLightIntensity;
                        }

                        // Restore camera
                        if (sceneData.camera) {
                            camera.position.fromArray(sceneData.camera.position);
                            camera.rotation.fromArray(sceneData.camera.rotation);
                        }

                        updateHierarchy();
                        updateCollisionList();
                        updateSpawnInfo();
                        deselectObject();
                    } catch (err) {
                        alert('Error loading scene: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        function exportCode() {
            alert('Code export feature coming soon! This will generate a standalone HTML file with your scene.');
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const delta = 0.016; // ~60fps

            if (isPlayMode && isLocked) {
                // Play mode movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveLeft) - Number(moveRight);  // FIXED: was reversed
                direction.normalize();

                const speed = 50;  // INCREASED: was 10, now much faster
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                camera.translateX(velocity.x * delta);
                camera.translateZ(velocity.z * delta);
            } else {
                if (orbitControls) orbitControls.update();
            }

            // Update collider helpers
            if (showColliderHelpers) {
                colliderHelpers.forEach(helper => helper.update());
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // MOBILE & TOOLTIP SYSTEM
        // ============================================

        // Mobile panel management
        let currentMobilePanel = null;

        function toggleHamburger() {
            const hamburger = document.getElementById('hamburger-btn');
            const leftSidebar = document.getElementById('left-sidebar');
            const overlay = document.getElementById('panel-overlay');

            hamburger.classList.toggle('active');
            leftSidebar.classList.toggle('mobile-open');
            overlay.classList.toggle('active');

            if (leftSidebar.classList.contains('mobile-open')) {
                currentMobilePanel = 'left';
            } else {
                currentMobilePanel = null;
            }
        }

        function toggleMobilePanel(panel) {
            const leftSidebar = document.getElementById('left-sidebar');
            const rightSidebar = document.getElementById('right-sidebar');
            const overlay = document.getElementById('panel-overlay');
            const navItems = document.querySelectorAll('.mobile-nav-item');

            // Remove active class from all nav items
            navItems.forEach(item => item.classList.remove('active'));

            if (panel === 'assets') {
                event.currentTarget.classList.add('active');
                leftSidebar.classList.add('mobile-open');
                rightSidebar.classList.remove('mobile-open');
                overlay.classList.add('active');
                currentMobilePanel = 'left';
                switchLeftTab('assets');
            } else if (panel === 'tools') {
                event.currentTarget.classList.add('active');
                rightSidebar.classList.add('mobile-open');
                leftSidebar.classList.remove('mobile-open');
                overlay.classList.add('active');
                currentMobilePanel = 'right';
                switchRightTab('properties');
            } else if (panel === 'properties') {
                event.currentTarget.classList.add('active');
                rightSidebar.classList.add('mobile-open');
                leftSidebar.classList.remove('mobile-open');
                overlay.classList.add('active');
                currentMobilePanel = 'right';
                switchRightTab('properties');
            } else if (panel === 'menu') {
                event.currentTarget.classList.add('active');
                rightSidebar.classList.add('mobile-open');
                leftSidebar.classList.remove('mobile-open');
                overlay.classList.add('active');
                currentMobilePanel = 'right';
                switchRightTab('scene');
            }
        }

        function togglePlayMode() {
            const playBtn = document.getElementById('mode-toggle');
            if (playBtn) {
                playBtn.click();
            }
            closeMobilePanels();
        }

        function closeMobilePanels() {
            const leftSidebar = document.getElementById('left-sidebar');
            const rightSidebar = document.getElementById('right-sidebar');
            const overlay = document.getElementById('panel-overlay');
            const hamburger = document.getElementById('hamburger-btn');

            leftSidebar.classList.remove('mobile-open');
            rightSidebar.classList.remove('mobile-open');
            overlay.classList.remove('active');
            hamburger.classList.remove('active');
            currentMobilePanel = null;
        }

        // Tooltip System
        const tooltipElement = document.getElementById('tooltip');
        let tooltipTimeout = null;

        function showTooltip(text, element, position = 'top') {
            if (!text || !element) return;

            clearTimeout(tooltipTimeout);

            tooltipTimeout = setTimeout(() => {
                tooltipElement.textContent = text;
                tooltipElement.className = 'tooltip ' + position;

                const rect = element.getBoundingClientRect();
                let top, left;

                switch(position) {
                    case 'top':
                        top = rect.top - tooltipElement.offsetHeight - 10;
                        left = rect.left + (rect.width / 2) - (tooltipElement.offsetWidth / 2);
                        break;
                    case 'bottom':
                        top = rect.bottom + 10;
                        left = rect.left + (rect.width / 2) - (tooltipElement.offsetWidth / 2);
                        break;
                    case 'left':
                        top = rect.top + (rect.height / 2) - (tooltipElement.offsetHeight / 2);
                        left = rect.left - tooltipElement.offsetWidth - 10;
                        break;
                    case 'right':
                        top = rect.top + (rect.height / 2) - (tooltipElement.offsetHeight / 2);
                        left = rect.right + 10;
                        break;
                }

                // Keep tooltip in viewport
                if (top < 10) top = rect.bottom + 10;
                if (left < 10) left = 10;
                if (left + tooltipElement.offsetWidth > window.innerWidth - 10) {
                    left = window.innerWidth - tooltipElement.offsetWidth - 10;
                }

                tooltipElement.style.top = top + 'px';
                tooltipElement.style.left = left + 'px';
                tooltipElement.classList.add('show');
            }, 500); // 500ms delay before showing
        }

        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            tooltipElement.classList.remove('show');
        }

        // Initialize tooltips on all elements with data-tooltip attribute
        function initTooltips() {
            document.querySelectorAll('[data-tooltip]').forEach(element => {
                element.addEventListener('mouseenter', function(e) {
                    const text = this.getAttribute('data-tooltip');
                    const position = this.getAttribute('data-tooltip-position') || 'top';
                    showTooltip(text, this, position);
                });

                element.addEventListener('mouseleave', hideTooltip);
            });
        }

        // Touch gesture support
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let isPinching = false;
        let initialPinchDistance = 0;

        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
            } else if (e.touches.length === 2) {
                isPinching = true;
                initialPinchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }

        function handleTouchMove(e) {
            if (isPinching && e.touches.length === 2) {
                const currentDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const scale = currentDistance / initialPinchDistance;

                // Zoom camera based on pinch
                if (camera && !isPlayMode) {
                    const newZ = Math.max(2, Math.min(50, camera.position.z / scale));
                    camera.position.z = newZ;
                }

                initialPinchDistance = currentDistance;
                e.preventDefault();
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                isPinching = false;
            }

            if (e.touches.length === 0) {
                const touchDuration = Date.now() - touchStartTime;
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                // Detect swipe gestures
                if (Math.abs(deltaX) > 100 && touchDuration < 300) {
                    if (deltaX > 0 && currentMobilePanel === null) {
                        // Swipe right - open left panel
                        toggleMobilePanel('assets');
                    } else if (deltaX < 0 && currentMobilePanel !== null) {
                        // Swipe left - close panel
                        closeMobilePanels();
                    }
                }
            }
        }

        // Add touch event listeners
        function initTouchGestures() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
        }

        // Close mobile panels when clicking outside
        document.addEventListener('click', function(e) {
            if (window.innerWidth <= 768) {
                const leftSidebar = document.getElementById('left-sidebar');
                const rightSidebar = document.getElementById('right-sidebar');
                const hamburger = document.getElementById('hamburger-btn');

                if (!leftSidebar.contains(e.target) &&
                    !rightSidebar.contains(e.target) &&
                    !hamburger.contains(e.target) &&
                    !e.target.classList.contains('mobile-nav-item')) {
                    closeMobilePanels();
                }
            }
        });

        // ESC key to close mobile panels
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && currentMobilePanel !== null) {
                closeMobilePanels();
            }
        });

        // ============================================
        // PHASE 1.3: UI ORGANIZATION & ENHANCEMENT FUNCTIONS
        // ============================================

        // Search functionality
        let searchResults = [];

        function searchAssets(query) {
            const searchInput = document.getElementById('asset-search');
            const searchClear = document.getElementById('search-clear');
            const assetItems = document.querySelectorAll('.asset-item');

            // Show/hide clear button
            if (query.length > 0) {
                searchClear.classList.add('show');
            } else {
                searchClear.classList.remove('show');
            }

            // Filter assets
            query = query.toLowerCase();
            let visibleCount = 0;

            assetItems.forEach(item => {
                const itemName = item.querySelector('.asset-item-name');
                if (itemName) {
                    const text = itemName.textContent.toLowerCase();
                    const tooltip = item.getAttribute('data-tooltip') || '';

                    if (text.includes(query) || tooltip.toLowerCase().includes(query)) {
                        item.style.display = 'flex';
                        visibleCount++;
                    } else {
                        item.style.display = 'none';
                    }
                }
            });

            // Show "no results" message if needed
            const assetPanels = document.querySelectorAll('.asset-grid');
            assetPanels.forEach(panel => {
                let hasVisible = false;
                panel.querySelectorAll('.asset-item').forEach(item => {
                    if (item.style.display !== 'none') {
                        hasVisible = true;
                    }
                });

                // Hide section title if no results
                const sectionTitle = panel.previousElementSibling;
                if (sectionTitle && sectionTitle.classList.contains('section-title')) {
                    sectionTitle.style.display = hasVisible ? 'block' : 'none';
                }
            });
        }

        function clearSearch() {
            const searchInput = document.getElementById('asset-search');
            const searchClear = document.getElementById('search-clear');
            searchInput.value = '';
            searchClear.classList.remove('show');
            searchAssets('');
        }

        // UI Mode Toggle (Beginner / Advanced)
        let currentUIMode = 'beginner';

        function setUIMode(mode) {
            currentUIMode = mode;
            const buttons = document.querySelectorAll('.ui-mode-btn');
            buttons.forEach(btn => btn.classList.remove('active'));

            if (mode === 'advanced') {
                document.body.classList.add('advanced-mode');
                buttons[1].classList.add('active');
            } else {
                document.body.classList.remove('advanced-mode');
                buttons[0].classList.add('active');
            }

            // Save preference
            localStorage.setItem('ui-mode', mode);
        }

        // Workspace Presets
        let currentWorkspace = 'general';

        function setWorkspacePreset(preset) {
            currentWorkspace = preset;
            const buttons = document.querySelectorAll('.workspace-preset-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Apply workspace-specific layout changes
            switch(preset) {
                case 'modeling':
                    // Focus on assets and transform tools
                    if (!document.getElementById('left-sidebar').classList.contains('mobile-open')) {
                        document.getElementById('left-sidebar').style.display = 'flex';
                    }
                    switchLeftTab('assets');
                    break;
                case 'lighting':
                    // Focus on lights and materials
                    switchRightTab('scene');
                    break;
                case 'animation':
                    // Focus on timeline (future feature)
                    console.log('Animation workspace selected (coming soon)');
                    break;
                case 'scripting':
                    // Focus on code editor (future feature)
                    console.log('Scripting workspace selected (coming soon)');
                    break;
                default:
                    // General layout
                    break;
            }

            // Save preference
            localStorage.setItem('workspace-preset', preset);
        }

        // Keyboard Shortcuts Overlay
        function toggleShortcuts() {
            const overlay = document.getElementById('shortcuts-overlay');
            overlay.classList.toggle('show');
        }

        // Favorites System
        let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');

        function toggleFavorite(assetType) {
            const index = favorites.indexOf(assetType);
            if (index > -1) {
                favorites.splice(index, 1);
            } else {
                favorites.push(assetType);
            }
            localStorage.setItem('favorites', JSON.stringify(favorites));
            updateFavoritesUI();
        }

        function updateFavoritesUI() {
            document.querySelectorAll('.favorite-star').forEach(star => {
                const assetType = star.getAttribute('data-asset');
                if (favorites.includes(assetType)) {
                    star.classList.add('active');
                } else {
                    star.classList.remove('active');
                }
            });
        }

        // Recent Items System
        let recentItems = JSON.parse(localStorage.getItem('recentItems') || '[]');
        const MAX_RECENT = 10;

        function addToRecent(assetType, assetName) {
            const item = {
                type: assetType,
                name: assetName,
                timestamp: Date.now()
            };

            // Remove if already exists
            recentItems = recentItems.filter(i => i.type !== assetType);

            // Add to front
            recentItems.unshift(item);

            // Limit to MAX_RECENT
            if (recentItems.length > MAX_RECENT) {
                recentItems = recentItems.slice(0, MAX_RECENT);
            }

            localStorage.setItem('recentItems', JSON.stringify(recentItems));
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }

        // Global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // F1 - Show shortcuts
            if (e.key === 'F1') {
                e.preventDefault();
                toggleShortcuts();
            }

            // Ctrl+S - Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveScene();
            }

            // Ctrl+Z - Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }

            // Ctrl+Y or Ctrl+Shift+Z - Redo
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redo();
            }

            // Ctrl+F - Search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                const searchInput = document.getElementById('asset-search');
                if (searchInput) {
                    searchInput.focus();
                }
            }

            // W - Move mode
            if (e.key === 'w' && !e.ctrlKey && !e.altKey && document.activeElement.tagName !== 'INPUT') {
                setTransformMode('translate');
            }

            // E - Rotate mode
            if (e.key === 'e' && !e.ctrlKey && !e.altKey && document.activeElement.tagName !== 'INPUT') {
                setTransformMode('rotate');
            }

            // R - Scale mode
            if (e.key === 'r' && !e.ctrlKey && !e.altKey && document.activeElement.tagName !== 'INPUT') {
                setTransformMode('scale');
            }

            // Delete - Delete selected object
            if (e.key === 'Delete' && selectedObject) {
                deleteSelectedObject();
            }

            // Ctrl+D - Duplicate (future feature)
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                console.log('Duplicate feature coming soon');
            }
        });

        // Load preferences on startup
        function loadPreferences() {
            // Load UI mode
            const savedMode = localStorage.getItem('ui-mode');
            if (savedMode) {
                setUIMode(savedMode);
            }

            // Load workspace preset
            const savedWorkspace = localStorage.getItem('workspace-preset');
            if (savedWorkspace) {
                const btn = document.querySelector(`[onclick="setWorkspacePreset('${savedWorkspace}')"]`);
                if (btn) {
                    btn.click();
                }
            }

            // Update favorites UI
            updateFavoritesUI();
        }

        // ============================================
        // START
        // ============================================
        init();
        initTooltips();
        initTouchGestures();
        loadPreferences();
    </script>

    <!-- Hamburger Menu Button -->
    <div class="hamburger-btn" id="hamburger-btn" onclick="toggleHamburger()">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Panel Overlay (for mobile) -->
    <div class="panel-overlay" id="panel-overlay" onclick="closeMobilePanels()"></div>

    <!-- Mobile Bottom Navigation -->
    <div class="mobile-bottom-nav" id="mobile-bottom-nav">
        <div class="mobile-nav-items">
            <div class="mobile-nav-item active" onclick="toggleMobilePanel('assets')" data-tooltip="Assets & Objects">
                <i class="fas fa-box"></i>
                <span>Assets</span>
            </div>
            <div class="mobile-nav-item" onclick="toggleMobilePanel('tools')" data-tooltip="Transform Tools">
                <i class="fas fa-tools"></i>
                <span>Tools</span>
            </div>
            <div class="mobile-nav-item" onclick="togglePlayMode()" data-tooltip="Play/Test Mode">
                <i class="fas fa-play"></i>
                <span>Play</span>
            </div>
            <div class="mobile-nav-item" onclick="toggleMobilePanel('properties')" data-tooltip="Properties">
                <i class="fas fa-sliders-h"></i>
                <span>Props</span>
            </div>
            <div class="mobile-nav-item" onclick="toggleMobilePanel('menu')" data-tooltip="Menu">
                <i class="fas fa-bars"></i>
                <span>Menu</span>
            </div>
        </div>
    </div>

    <!-- Tooltip Container -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Keyboard Shortcuts Overlay -->
    <div class="shortcuts-overlay" id="shortcuts-overlay">
        <div class="shortcuts-panel">
            <div class="shortcuts-header">
                <div class="shortcuts-title">
                    <i class="fas fa-keyboard"></i> Keyboard Shortcuts
                </div>
                <div class="shortcuts-close" onclick="toggleShortcuts()">
                    <i class="fas fa-times"></i>
                </div>
            </div>
            <div class="shortcuts-grid">
                <div class="shortcuts-category">
                    <div class="shortcuts-category-title">General</div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Show Shortcuts</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">F1</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Save Scene</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Ctrl</span>
                            <span class="shortcut-key">S</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Undo</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Ctrl</span>
                            <span class="shortcut-key">Z</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Redo</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Ctrl</span>
                            <span class="shortcut-key">Y</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Toggle Grid</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">G</span>
                        </div>
                    </div>
                </div>

                <div class="shortcuts-category">
                    <div class="shortcuts-category-title">Transform</div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Move Mode</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">W</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Rotate Mode</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">E</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Scale Mode</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">R</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Delete Object</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Del</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Duplicate</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Ctrl</span>
                            <span class="shortcut-key">D</span>
                        </div>
                    </div>
                </div>

                <div class="shortcuts-category">
                    <div class="shortcuts-category-title">View</div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Focus Object</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">F</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Frame All</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">A</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Search Assets</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Ctrl</span>
                            <span class="shortcut-key">F</span>
                        </div>
                    </div>
                </div>

                <div class="shortcuts-category">
                    <div class="shortcuts-category-title">Camera</div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Orbit View</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Left Click + Drag</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Pan View</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Middle Click + Drag</span>
                        </div>
                    </div>
                    <div class="shortcut-item">
                        <div class="shortcut-action">Zoom</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">Scroll Wheel</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Button -->
    <button class="settings-btn" onclick="toggleShortcuts()" data-tooltip="Keyboard shortcuts (F1)">
        <i class="fas fa-keyboard"></i>
    </button>

</body>
</html>
